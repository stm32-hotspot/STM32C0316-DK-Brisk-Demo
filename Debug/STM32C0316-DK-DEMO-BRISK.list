
STM32C0316-DK-DEMO-BRISK.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005798  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000018d0  08005858  08005858  00015858  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08007128  08007128  00020218  2**0
                  CONTENTS
  4 .ARM          00000000  08007128  08007128  00020218  2**0
                  CONTENTS
  5 .preinit_array 00000000  08007128  08007128  00020218  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08007128  08007128  00017128  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0800712c  0800712c  0001712c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000218  20000000  08007130  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00002084  20000218  08007348  00020218  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000229c  08007348  0002229c  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020218  2**0
                  CONTENTS, READONLY
 12 .debug_info   0002755c  00000000  00000000  00020240  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00005a89  00000000  00000000  0004779c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0000f2ef  00000000  00000000  0004d225  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001280  00000000  00000000  0005c518  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00001288  00000000  00000000  0005d798  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00009af3  00000000  00000000  0005ea20  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000256a1  00000000  00000000  00068513  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0009373f  00000000  00000000  0008dbb4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  001212f3  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00002f38  00000000  00000000  00121344  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000218 	.word	0x20000218
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08005840 	.word	0x08005840

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	2000021c 	.word	0x2000021c
 8000104:	08005840 	.word	0x08005840

08000108 <__udivsi3>:
 8000108:	2200      	movs	r2, #0
 800010a:	0843      	lsrs	r3, r0, #1
 800010c:	428b      	cmp	r3, r1
 800010e:	d374      	bcc.n	80001fa <__udivsi3+0xf2>
 8000110:	0903      	lsrs	r3, r0, #4
 8000112:	428b      	cmp	r3, r1
 8000114:	d35f      	bcc.n	80001d6 <__udivsi3+0xce>
 8000116:	0a03      	lsrs	r3, r0, #8
 8000118:	428b      	cmp	r3, r1
 800011a:	d344      	bcc.n	80001a6 <__udivsi3+0x9e>
 800011c:	0b03      	lsrs	r3, r0, #12
 800011e:	428b      	cmp	r3, r1
 8000120:	d328      	bcc.n	8000174 <__udivsi3+0x6c>
 8000122:	0c03      	lsrs	r3, r0, #16
 8000124:	428b      	cmp	r3, r1
 8000126:	d30d      	bcc.n	8000144 <__udivsi3+0x3c>
 8000128:	22ff      	movs	r2, #255	; 0xff
 800012a:	0209      	lsls	r1, r1, #8
 800012c:	ba12      	rev	r2, r2
 800012e:	0c03      	lsrs	r3, r0, #16
 8000130:	428b      	cmp	r3, r1
 8000132:	d302      	bcc.n	800013a <__udivsi3+0x32>
 8000134:	1212      	asrs	r2, r2, #8
 8000136:	0209      	lsls	r1, r1, #8
 8000138:	d065      	beq.n	8000206 <__udivsi3+0xfe>
 800013a:	0b03      	lsrs	r3, r0, #12
 800013c:	428b      	cmp	r3, r1
 800013e:	d319      	bcc.n	8000174 <__udivsi3+0x6c>
 8000140:	e000      	b.n	8000144 <__udivsi3+0x3c>
 8000142:	0a09      	lsrs	r1, r1, #8
 8000144:	0bc3      	lsrs	r3, r0, #15
 8000146:	428b      	cmp	r3, r1
 8000148:	d301      	bcc.n	800014e <__udivsi3+0x46>
 800014a:	03cb      	lsls	r3, r1, #15
 800014c:	1ac0      	subs	r0, r0, r3
 800014e:	4152      	adcs	r2, r2
 8000150:	0b83      	lsrs	r3, r0, #14
 8000152:	428b      	cmp	r3, r1
 8000154:	d301      	bcc.n	800015a <__udivsi3+0x52>
 8000156:	038b      	lsls	r3, r1, #14
 8000158:	1ac0      	subs	r0, r0, r3
 800015a:	4152      	adcs	r2, r2
 800015c:	0b43      	lsrs	r3, r0, #13
 800015e:	428b      	cmp	r3, r1
 8000160:	d301      	bcc.n	8000166 <__udivsi3+0x5e>
 8000162:	034b      	lsls	r3, r1, #13
 8000164:	1ac0      	subs	r0, r0, r3
 8000166:	4152      	adcs	r2, r2
 8000168:	0b03      	lsrs	r3, r0, #12
 800016a:	428b      	cmp	r3, r1
 800016c:	d301      	bcc.n	8000172 <__udivsi3+0x6a>
 800016e:	030b      	lsls	r3, r1, #12
 8000170:	1ac0      	subs	r0, r0, r3
 8000172:	4152      	adcs	r2, r2
 8000174:	0ac3      	lsrs	r3, r0, #11
 8000176:	428b      	cmp	r3, r1
 8000178:	d301      	bcc.n	800017e <__udivsi3+0x76>
 800017a:	02cb      	lsls	r3, r1, #11
 800017c:	1ac0      	subs	r0, r0, r3
 800017e:	4152      	adcs	r2, r2
 8000180:	0a83      	lsrs	r3, r0, #10
 8000182:	428b      	cmp	r3, r1
 8000184:	d301      	bcc.n	800018a <__udivsi3+0x82>
 8000186:	028b      	lsls	r3, r1, #10
 8000188:	1ac0      	subs	r0, r0, r3
 800018a:	4152      	adcs	r2, r2
 800018c:	0a43      	lsrs	r3, r0, #9
 800018e:	428b      	cmp	r3, r1
 8000190:	d301      	bcc.n	8000196 <__udivsi3+0x8e>
 8000192:	024b      	lsls	r3, r1, #9
 8000194:	1ac0      	subs	r0, r0, r3
 8000196:	4152      	adcs	r2, r2
 8000198:	0a03      	lsrs	r3, r0, #8
 800019a:	428b      	cmp	r3, r1
 800019c:	d301      	bcc.n	80001a2 <__udivsi3+0x9a>
 800019e:	020b      	lsls	r3, r1, #8
 80001a0:	1ac0      	subs	r0, r0, r3
 80001a2:	4152      	adcs	r2, r2
 80001a4:	d2cd      	bcs.n	8000142 <__udivsi3+0x3a>
 80001a6:	09c3      	lsrs	r3, r0, #7
 80001a8:	428b      	cmp	r3, r1
 80001aa:	d301      	bcc.n	80001b0 <__udivsi3+0xa8>
 80001ac:	01cb      	lsls	r3, r1, #7
 80001ae:	1ac0      	subs	r0, r0, r3
 80001b0:	4152      	adcs	r2, r2
 80001b2:	0983      	lsrs	r3, r0, #6
 80001b4:	428b      	cmp	r3, r1
 80001b6:	d301      	bcc.n	80001bc <__udivsi3+0xb4>
 80001b8:	018b      	lsls	r3, r1, #6
 80001ba:	1ac0      	subs	r0, r0, r3
 80001bc:	4152      	adcs	r2, r2
 80001be:	0943      	lsrs	r3, r0, #5
 80001c0:	428b      	cmp	r3, r1
 80001c2:	d301      	bcc.n	80001c8 <__udivsi3+0xc0>
 80001c4:	014b      	lsls	r3, r1, #5
 80001c6:	1ac0      	subs	r0, r0, r3
 80001c8:	4152      	adcs	r2, r2
 80001ca:	0903      	lsrs	r3, r0, #4
 80001cc:	428b      	cmp	r3, r1
 80001ce:	d301      	bcc.n	80001d4 <__udivsi3+0xcc>
 80001d0:	010b      	lsls	r3, r1, #4
 80001d2:	1ac0      	subs	r0, r0, r3
 80001d4:	4152      	adcs	r2, r2
 80001d6:	08c3      	lsrs	r3, r0, #3
 80001d8:	428b      	cmp	r3, r1
 80001da:	d301      	bcc.n	80001e0 <__udivsi3+0xd8>
 80001dc:	00cb      	lsls	r3, r1, #3
 80001de:	1ac0      	subs	r0, r0, r3
 80001e0:	4152      	adcs	r2, r2
 80001e2:	0883      	lsrs	r3, r0, #2
 80001e4:	428b      	cmp	r3, r1
 80001e6:	d301      	bcc.n	80001ec <__udivsi3+0xe4>
 80001e8:	008b      	lsls	r3, r1, #2
 80001ea:	1ac0      	subs	r0, r0, r3
 80001ec:	4152      	adcs	r2, r2
 80001ee:	0843      	lsrs	r3, r0, #1
 80001f0:	428b      	cmp	r3, r1
 80001f2:	d301      	bcc.n	80001f8 <__udivsi3+0xf0>
 80001f4:	004b      	lsls	r3, r1, #1
 80001f6:	1ac0      	subs	r0, r0, r3
 80001f8:	4152      	adcs	r2, r2
 80001fa:	1a41      	subs	r1, r0, r1
 80001fc:	d200      	bcs.n	8000200 <__udivsi3+0xf8>
 80001fe:	4601      	mov	r1, r0
 8000200:	4152      	adcs	r2, r2
 8000202:	4610      	mov	r0, r2
 8000204:	4770      	bx	lr
 8000206:	e7ff      	b.n	8000208 <__udivsi3+0x100>
 8000208:	b501      	push	{r0, lr}
 800020a:	2000      	movs	r0, #0
 800020c:	f000 f8f0 	bl	80003f0 <__aeabi_idiv0>
 8000210:	bd02      	pop	{r1, pc}
 8000212:	46c0      	nop			; (mov r8, r8)

08000214 <__aeabi_uidivmod>:
 8000214:	2900      	cmp	r1, #0
 8000216:	d0f7      	beq.n	8000208 <__udivsi3+0x100>
 8000218:	e776      	b.n	8000108 <__udivsi3>
 800021a:	4770      	bx	lr

0800021c <__divsi3>:
 800021c:	4603      	mov	r3, r0
 800021e:	430b      	orrs	r3, r1
 8000220:	d47f      	bmi.n	8000322 <__divsi3+0x106>
 8000222:	2200      	movs	r2, #0
 8000224:	0843      	lsrs	r3, r0, #1
 8000226:	428b      	cmp	r3, r1
 8000228:	d374      	bcc.n	8000314 <__divsi3+0xf8>
 800022a:	0903      	lsrs	r3, r0, #4
 800022c:	428b      	cmp	r3, r1
 800022e:	d35f      	bcc.n	80002f0 <__divsi3+0xd4>
 8000230:	0a03      	lsrs	r3, r0, #8
 8000232:	428b      	cmp	r3, r1
 8000234:	d344      	bcc.n	80002c0 <__divsi3+0xa4>
 8000236:	0b03      	lsrs	r3, r0, #12
 8000238:	428b      	cmp	r3, r1
 800023a:	d328      	bcc.n	800028e <__divsi3+0x72>
 800023c:	0c03      	lsrs	r3, r0, #16
 800023e:	428b      	cmp	r3, r1
 8000240:	d30d      	bcc.n	800025e <__divsi3+0x42>
 8000242:	22ff      	movs	r2, #255	; 0xff
 8000244:	0209      	lsls	r1, r1, #8
 8000246:	ba12      	rev	r2, r2
 8000248:	0c03      	lsrs	r3, r0, #16
 800024a:	428b      	cmp	r3, r1
 800024c:	d302      	bcc.n	8000254 <__divsi3+0x38>
 800024e:	1212      	asrs	r2, r2, #8
 8000250:	0209      	lsls	r1, r1, #8
 8000252:	d065      	beq.n	8000320 <__divsi3+0x104>
 8000254:	0b03      	lsrs	r3, r0, #12
 8000256:	428b      	cmp	r3, r1
 8000258:	d319      	bcc.n	800028e <__divsi3+0x72>
 800025a:	e000      	b.n	800025e <__divsi3+0x42>
 800025c:	0a09      	lsrs	r1, r1, #8
 800025e:	0bc3      	lsrs	r3, r0, #15
 8000260:	428b      	cmp	r3, r1
 8000262:	d301      	bcc.n	8000268 <__divsi3+0x4c>
 8000264:	03cb      	lsls	r3, r1, #15
 8000266:	1ac0      	subs	r0, r0, r3
 8000268:	4152      	adcs	r2, r2
 800026a:	0b83      	lsrs	r3, r0, #14
 800026c:	428b      	cmp	r3, r1
 800026e:	d301      	bcc.n	8000274 <__divsi3+0x58>
 8000270:	038b      	lsls	r3, r1, #14
 8000272:	1ac0      	subs	r0, r0, r3
 8000274:	4152      	adcs	r2, r2
 8000276:	0b43      	lsrs	r3, r0, #13
 8000278:	428b      	cmp	r3, r1
 800027a:	d301      	bcc.n	8000280 <__divsi3+0x64>
 800027c:	034b      	lsls	r3, r1, #13
 800027e:	1ac0      	subs	r0, r0, r3
 8000280:	4152      	adcs	r2, r2
 8000282:	0b03      	lsrs	r3, r0, #12
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__divsi3+0x70>
 8000288:	030b      	lsls	r3, r1, #12
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	0ac3      	lsrs	r3, r0, #11
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__divsi3+0x7c>
 8000294:	02cb      	lsls	r3, r1, #11
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0a83      	lsrs	r3, r0, #10
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__divsi3+0x88>
 80002a0:	028b      	lsls	r3, r1, #10
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	0a43      	lsrs	r3, r0, #9
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__divsi3+0x94>
 80002ac:	024b      	lsls	r3, r1, #9
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	0a03      	lsrs	r3, r0, #8
 80002b4:	428b      	cmp	r3, r1
 80002b6:	d301      	bcc.n	80002bc <__divsi3+0xa0>
 80002b8:	020b      	lsls	r3, r1, #8
 80002ba:	1ac0      	subs	r0, r0, r3
 80002bc:	4152      	adcs	r2, r2
 80002be:	d2cd      	bcs.n	800025c <__divsi3+0x40>
 80002c0:	09c3      	lsrs	r3, r0, #7
 80002c2:	428b      	cmp	r3, r1
 80002c4:	d301      	bcc.n	80002ca <__divsi3+0xae>
 80002c6:	01cb      	lsls	r3, r1, #7
 80002c8:	1ac0      	subs	r0, r0, r3
 80002ca:	4152      	adcs	r2, r2
 80002cc:	0983      	lsrs	r3, r0, #6
 80002ce:	428b      	cmp	r3, r1
 80002d0:	d301      	bcc.n	80002d6 <__divsi3+0xba>
 80002d2:	018b      	lsls	r3, r1, #6
 80002d4:	1ac0      	subs	r0, r0, r3
 80002d6:	4152      	adcs	r2, r2
 80002d8:	0943      	lsrs	r3, r0, #5
 80002da:	428b      	cmp	r3, r1
 80002dc:	d301      	bcc.n	80002e2 <__divsi3+0xc6>
 80002de:	014b      	lsls	r3, r1, #5
 80002e0:	1ac0      	subs	r0, r0, r3
 80002e2:	4152      	adcs	r2, r2
 80002e4:	0903      	lsrs	r3, r0, #4
 80002e6:	428b      	cmp	r3, r1
 80002e8:	d301      	bcc.n	80002ee <__divsi3+0xd2>
 80002ea:	010b      	lsls	r3, r1, #4
 80002ec:	1ac0      	subs	r0, r0, r3
 80002ee:	4152      	adcs	r2, r2
 80002f0:	08c3      	lsrs	r3, r0, #3
 80002f2:	428b      	cmp	r3, r1
 80002f4:	d301      	bcc.n	80002fa <__divsi3+0xde>
 80002f6:	00cb      	lsls	r3, r1, #3
 80002f8:	1ac0      	subs	r0, r0, r3
 80002fa:	4152      	adcs	r2, r2
 80002fc:	0883      	lsrs	r3, r0, #2
 80002fe:	428b      	cmp	r3, r1
 8000300:	d301      	bcc.n	8000306 <__divsi3+0xea>
 8000302:	008b      	lsls	r3, r1, #2
 8000304:	1ac0      	subs	r0, r0, r3
 8000306:	4152      	adcs	r2, r2
 8000308:	0843      	lsrs	r3, r0, #1
 800030a:	428b      	cmp	r3, r1
 800030c:	d301      	bcc.n	8000312 <__divsi3+0xf6>
 800030e:	004b      	lsls	r3, r1, #1
 8000310:	1ac0      	subs	r0, r0, r3
 8000312:	4152      	adcs	r2, r2
 8000314:	1a41      	subs	r1, r0, r1
 8000316:	d200      	bcs.n	800031a <__divsi3+0xfe>
 8000318:	4601      	mov	r1, r0
 800031a:	4152      	adcs	r2, r2
 800031c:	4610      	mov	r0, r2
 800031e:	4770      	bx	lr
 8000320:	e05d      	b.n	80003de <__divsi3+0x1c2>
 8000322:	0fca      	lsrs	r2, r1, #31
 8000324:	d000      	beq.n	8000328 <__divsi3+0x10c>
 8000326:	4249      	negs	r1, r1
 8000328:	1003      	asrs	r3, r0, #32
 800032a:	d300      	bcc.n	800032e <__divsi3+0x112>
 800032c:	4240      	negs	r0, r0
 800032e:	4053      	eors	r3, r2
 8000330:	2200      	movs	r2, #0
 8000332:	469c      	mov	ip, r3
 8000334:	0903      	lsrs	r3, r0, #4
 8000336:	428b      	cmp	r3, r1
 8000338:	d32d      	bcc.n	8000396 <__divsi3+0x17a>
 800033a:	0a03      	lsrs	r3, r0, #8
 800033c:	428b      	cmp	r3, r1
 800033e:	d312      	bcc.n	8000366 <__divsi3+0x14a>
 8000340:	22fc      	movs	r2, #252	; 0xfc
 8000342:	0189      	lsls	r1, r1, #6
 8000344:	ba12      	rev	r2, r2
 8000346:	0a03      	lsrs	r3, r0, #8
 8000348:	428b      	cmp	r3, r1
 800034a:	d30c      	bcc.n	8000366 <__divsi3+0x14a>
 800034c:	0189      	lsls	r1, r1, #6
 800034e:	1192      	asrs	r2, r2, #6
 8000350:	428b      	cmp	r3, r1
 8000352:	d308      	bcc.n	8000366 <__divsi3+0x14a>
 8000354:	0189      	lsls	r1, r1, #6
 8000356:	1192      	asrs	r2, r2, #6
 8000358:	428b      	cmp	r3, r1
 800035a:	d304      	bcc.n	8000366 <__divsi3+0x14a>
 800035c:	0189      	lsls	r1, r1, #6
 800035e:	d03a      	beq.n	80003d6 <__divsi3+0x1ba>
 8000360:	1192      	asrs	r2, r2, #6
 8000362:	e000      	b.n	8000366 <__divsi3+0x14a>
 8000364:	0989      	lsrs	r1, r1, #6
 8000366:	09c3      	lsrs	r3, r0, #7
 8000368:	428b      	cmp	r3, r1
 800036a:	d301      	bcc.n	8000370 <__divsi3+0x154>
 800036c:	01cb      	lsls	r3, r1, #7
 800036e:	1ac0      	subs	r0, r0, r3
 8000370:	4152      	adcs	r2, r2
 8000372:	0983      	lsrs	r3, r0, #6
 8000374:	428b      	cmp	r3, r1
 8000376:	d301      	bcc.n	800037c <__divsi3+0x160>
 8000378:	018b      	lsls	r3, r1, #6
 800037a:	1ac0      	subs	r0, r0, r3
 800037c:	4152      	adcs	r2, r2
 800037e:	0943      	lsrs	r3, r0, #5
 8000380:	428b      	cmp	r3, r1
 8000382:	d301      	bcc.n	8000388 <__divsi3+0x16c>
 8000384:	014b      	lsls	r3, r1, #5
 8000386:	1ac0      	subs	r0, r0, r3
 8000388:	4152      	adcs	r2, r2
 800038a:	0903      	lsrs	r3, r0, #4
 800038c:	428b      	cmp	r3, r1
 800038e:	d301      	bcc.n	8000394 <__divsi3+0x178>
 8000390:	010b      	lsls	r3, r1, #4
 8000392:	1ac0      	subs	r0, r0, r3
 8000394:	4152      	adcs	r2, r2
 8000396:	08c3      	lsrs	r3, r0, #3
 8000398:	428b      	cmp	r3, r1
 800039a:	d301      	bcc.n	80003a0 <__divsi3+0x184>
 800039c:	00cb      	lsls	r3, r1, #3
 800039e:	1ac0      	subs	r0, r0, r3
 80003a0:	4152      	adcs	r2, r2
 80003a2:	0883      	lsrs	r3, r0, #2
 80003a4:	428b      	cmp	r3, r1
 80003a6:	d301      	bcc.n	80003ac <__divsi3+0x190>
 80003a8:	008b      	lsls	r3, r1, #2
 80003aa:	1ac0      	subs	r0, r0, r3
 80003ac:	4152      	adcs	r2, r2
 80003ae:	d2d9      	bcs.n	8000364 <__divsi3+0x148>
 80003b0:	0843      	lsrs	r3, r0, #1
 80003b2:	428b      	cmp	r3, r1
 80003b4:	d301      	bcc.n	80003ba <__divsi3+0x19e>
 80003b6:	004b      	lsls	r3, r1, #1
 80003b8:	1ac0      	subs	r0, r0, r3
 80003ba:	4152      	adcs	r2, r2
 80003bc:	1a41      	subs	r1, r0, r1
 80003be:	d200      	bcs.n	80003c2 <__divsi3+0x1a6>
 80003c0:	4601      	mov	r1, r0
 80003c2:	4663      	mov	r3, ip
 80003c4:	4152      	adcs	r2, r2
 80003c6:	105b      	asrs	r3, r3, #1
 80003c8:	4610      	mov	r0, r2
 80003ca:	d301      	bcc.n	80003d0 <__divsi3+0x1b4>
 80003cc:	4240      	negs	r0, r0
 80003ce:	2b00      	cmp	r3, #0
 80003d0:	d500      	bpl.n	80003d4 <__divsi3+0x1b8>
 80003d2:	4249      	negs	r1, r1
 80003d4:	4770      	bx	lr
 80003d6:	4663      	mov	r3, ip
 80003d8:	105b      	asrs	r3, r3, #1
 80003da:	d300      	bcc.n	80003de <__divsi3+0x1c2>
 80003dc:	4240      	negs	r0, r0
 80003de:	b501      	push	{r0, lr}
 80003e0:	2000      	movs	r0, #0
 80003e2:	f000 f805 	bl	80003f0 <__aeabi_idiv0>
 80003e6:	bd02      	pop	{r1, pc}

080003e8 <__aeabi_idivmod>:
 80003e8:	2900      	cmp	r1, #0
 80003ea:	d0f8      	beq.n	80003de <__divsi3+0x1c2>
 80003ec:	e716      	b.n	800021c <__divsi3>
 80003ee:	4770      	bx	lr

080003f0 <__aeabi_idiv0>:
 80003f0:	4770      	bx	lr
 80003f2:	46c0      	nop			; (mov r8, r8)

080003f4 <__clzsi2>:
 80003f4:	211c      	movs	r1, #28
 80003f6:	2301      	movs	r3, #1
 80003f8:	041b      	lsls	r3, r3, #16
 80003fa:	4298      	cmp	r0, r3
 80003fc:	d301      	bcc.n	8000402 <__clzsi2+0xe>
 80003fe:	0c00      	lsrs	r0, r0, #16
 8000400:	3910      	subs	r1, #16
 8000402:	0a1b      	lsrs	r3, r3, #8
 8000404:	4298      	cmp	r0, r3
 8000406:	d301      	bcc.n	800040c <__clzsi2+0x18>
 8000408:	0a00      	lsrs	r0, r0, #8
 800040a:	3908      	subs	r1, #8
 800040c:	091b      	lsrs	r3, r3, #4
 800040e:	4298      	cmp	r0, r3
 8000410:	d301      	bcc.n	8000416 <__clzsi2+0x22>
 8000412:	0900      	lsrs	r0, r0, #4
 8000414:	3904      	subs	r1, #4
 8000416:	a202      	add	r2, pc, #8	; (adr r2, 8000420 <__clzsi2+0x2c>)
 8000418:	5c10      	ldrb	r0, [r2, r0]
 800041a:	1840      	adds	r0, r0, r1
 800041c:	4770      	bx	lr
 800041e:	46c0      	nop			; (mov r8, r8)
 8000420:	02020304 	.word	0x02020304
 8000424:	01010101 	.word	0x01010101
	...

08000430 <__aeabi_fdiv>:
 8000430:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000432:	464f      	mov	r7, r9
 8000434:	4646      	mov	r6, r8
 8000436:	46d6      	mov	lr, sl
 8000438:	0245      	lsls	r5, r0, #9
 800043a:	b5c0      	push	{r6, r7, lr}
 800043c:	0047      	lsls	r7, r0, #1
 800043e:	1c0c      	adds	r4, r1, #0
 8000440:	0a6d      	lsrs	r5, r5, #9
 8000442:	0e3f      	lsrs	r7, r7, #24
 8000444:	0fc6      	lsrs	r6, r0, #31
 8000446:	2f00      	cmp	r7, #0
 8000448:	d100      	bne.n	800044c <__aeabi_fdiv+0x1c>
 800044a:	e070      	b.n	800052e <__aeabi_fdiv+0xfe>
 800044c:	2fff      	cmp	r7, #255	; 0xff
 800044e:	d100      	bne.n	8000452 <__aeabi_fdiv+0x22>
 8000450:	e075      	b.n	800053e <__aeabi_fdiv+0x10e>
 8000452:	00eb      	lsls	r3, r5, #3
 8000454:	2580      	movs	r5, #128	; 0x80
 8000456:	04ed      	lsls	r5, r5, #19
 8000458:	431d      	orrs	r5, r3
 800045a:	2300      	movs	r3, #0
 800045c:	4699      	mov	r9, r3
 800045e:	469a      	mov	sl, r3
 8000460:	3f7f      	subs	r7, #127	; 0x7f
 8000462:	0260      	lsls	r0, r4, #9
 8000464:	0a43      	lsrs	r3, r0, #9
 8000466:	4698      	mov	r8, r3
 8000468:	0063      	lsls	r3, r4, #1
 800046a:	0e1b      	lsrs	r3, r3, #24
 800046c:	0fe4      	lsrs	r4, r4, #31
 800046e:	2b00      	cmp	r3, #0
 8000470:	d04e      	beq.n	8000510 <__aeabi_fdiv+0xe0>
 8000472:	2bff      	cmp	r3, #255	; 0xff
 8000474:	d046      	beq.n	8000504 <__aeabi_fdiv+0xd4>
 8000476:	4642      	mov	r2, r8
 8000478:	00d0      	lsls	r0, r2, #3
 800047a:	2280      	movs	r2, #128	; 0x80
 800047c:	04d2      	lsls	r2, r2, #19
 800047e:	4302      	orrs	r2, r0
 8000480:	4690      	mov	r8, r2
 8000482:	2200      	movs	r2, #0
 8000484:	3b7f      	subs	r3, #127	; 0x7f
 8000486:	0031      	movs	r1, r6
 8000488:	1aff      	subs	r7, r7, r3
 800048a:	464b      	mov	r3, r9
 800048c:	4061      	eors	r1, r4
 800048e:	b2c9      	uxtb	r1, r1
 8000490:	4313      	orrs	r3, r2
 8000492:	2b0f      	cmp	r3, #15
 8000494:	d900      	bls.n	8000498 <__aeabi_fdiv+0x68>
 8000496:	e0b5      	b.n	8000604 <__aeabi_fdiv+0x1d4>
 8000498:	486e      	ldr	r0, [pc, #440]	; (8000654 <__aeabi_fdiv+0x224>)
 800049a:	009b      	lsls	r3, r3, #2
 800049c:	58c3      	ldr	r3, [r0, r3]
 800049e:	469f      	mov	pc, r3
 80004a0:	2300      	movs	r3, #0
 80004a2:	4698      	mov	r8, r3
 80004a4:	0026      	movs	r6, r4
 80004a6:	4645      	mov	r5, r8
 80004a8:	4692      	mov	sl, r2
 80004aa:	4653      	mov	r3, sl
 80004ac:	2b02      	cmp	r3, #2
 80004ae:	d100      	bne.n	80004b2 <__aeabi_fdiv+0x82>
 80004b0:	e089      	b.n	80005c6 <__aeabi_fdiv+0x196>
 80004b2:	2b03      	cmp	r3, #3
 80004b4:	d100      	bne.n	80004b8 <__aeabi_fdiv+0x88>
 80004b6:	e09e      	b.n	80005f6 <__aeabi_fdiv+0x1c6>
 80004b8:	2b01      	cmp	r3, #1
 80004ba:	d018      	beq.n	80004ee <__aeabi_fdiv+0xbe>
 80004bc:	003b      	movs	r3, r7
 80004be:	337f      	adds	r3, #127	; 0x7f
 80004c0:	2b00      	cmp	r3, #0
 80004c2:	dd69      	ble.n	8000598 <__aeabi_fdiv+0x168>
 80004c4:	076a      	lsls	r2, r5, #29
 80004c6:	d004      	beq.n	80004d2 <__aeabi_fdiv+0xa2>
 80004c8:	220f      	movs	r2, #15
 80004ca:	402a      	ands	r2, r5
 80004cc:	2a04      	cmp	r2, #4
 80004ce:	d000      	beq.n	80004d2 <__aeabi_fdiv+0xa2>
 80004d0:	3504      	adds	r5, #4
 80004d2:	012a      	lsls	r2, r5, #4
 80004d4:	d503      	bpl.n	80004de <__aeabi_fdiv+0xae>
 80004d6:	4b60      	ldr	r3, [pc, #384]	; (8000658 <__aeabi_fdiv+0x228>)
 80004d8:	401d      	ands	r5, r3
 80004da:	003b      	movs	r3, r7
 80004dc:	3380      	adds	r3, #128	; 0x80
 80004de:	2bfe      	cmp	r3, #254	; 0xfe
 80004e0:	dd00      	ble.n	80004e4 <__aeabi_fdiv+0xb4>
 80004e2:	e070      	b.n	80005c6 <__aeabi_fdiv+0x196>
 80004e4:	01ad      	lsls	r5, r5, #6
 80004e6:	0a6d      	lsrs	r5, r5, #9
 80004e8:	b2d8      	uxtb	r0, r3
 80004ea:	e002      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 80004ec:	000e      	movs	r6, r1
 80004ee:	2000      	movs	r0, #0
 80004f0:	2500      	movs	r5, #0
 80004f2:	05c0      	lsls	r0, r0, #23
 80004f4:	4328      	orrs	r0, r5
 80004f6:	07f6      	lsls	r6, r6, #31
 80004f8:	4330      	orrs	r0, r6
 80004fa:	bce0      	pop	{r5, r6, r7}
 80004fc:	46ba      	mov	sl, r7
 80004fe:	46b1      	mov	r9, r6
 8000500:	46a8      	mov	r8, r5
 8000502:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000504:	4643      	mov	r3, r8
 8000506:	2b00      	cmp	r3, #0
 8000508:	d13f      	bne.n	800058a <__aeabi_fdiv+0x15a>
 800050a:	2202      	movs	r2, #2
 800050c:	3fff      	subs	r7, #255	; 0xff
 800050e:	e003      	b.n	8000518 <__aeabi_fdiv+0xe8>
 8000510:	4643      	mov	r3, r8
 8000512:	2b00      	cmp	r3, #0
 8000514:	d12d      	bne.n	8000572 <__aeabi_fdiv+0x142>
 8000516:	2201      	movs	r2, #1
 8000518:	0031      	movs	r1, r6
 800051a:	464b      	mov	r3, r9
 800051c:	4061      	eors	r1, r4
 800051e:	b2c9      	uxtb	r1, r1
 8000520:	4313      	orrs	r3, r2
 8000522:	2b0f      	cmp	r3, #15
 8000524:	d834      	bhi.n	8000590 <__aeabi_fdiv+0x160>
 8000526:	484d      	ldr	r0, [pc, #308]	; (800065c <__aeabi_fdiv+0x22c>)
 8000528:	009b      	lsls	r3, r3, #2
 800052a:	58c3      	ldr	r3, [r0, r3]
 800052c:	469f      	mov	pc, r3
 800052e:	2d00      	cmp	r5, #0
 8000530:	d113      	bne.n	800055a <__aeabi_fdiv+0x12a>
 8000532:	2304      	movs	r3, #4
 8000534:	4699      	mov	r9, r3
 8000536:	3b03      	subs	r3, #3
 8000538:	2700      	movs	r7, #0
 800053a:	469a      	mov	sl, r3
 800053c:	e791      	b.n	8000462 <__aeabi_fdiv+0x32>
 800053e:	2d00      	cmp	r5, #0
 8000540:	d105      	bne.n	800054e <__aeabi_fdiv+0x11e>
 8000542:	2308      	movs	r3, #8
 8000544:	4699      	mov	r9, r3
 8000546:	3b06      	subs	r3, #6
 8000548:	27ff      	movs	r7, #255	; 0xff
 800054a:	469a      	mov	sl, r3
 800054c:	e789      	b.n	8000462 <__aeabi_fdiv+0x32>
 800054e:	230c      	movs	r3, #12
 8000550:	4699      	mov	r9, r3
 8000552:	3b09      	subs	r3, #9
 8000554:	27ff      	movs	r7, #255	; 0xff
 8000556:	469a      	mov	sl, r3
 8000558:	e783      	b.n	8000462 <__aeabi_fdiv+0x32>
 800055a:	0028      	movs	r0, r5
 800055c:	f7ff ff4a 	bl	80003f4 <__clzsi2>
 8000560:	2776      	movs	r7, #118	; 0x76
 8000562:	1f43      	subs	r3, r0, #5
 8000564:	409d      	lsls	r5, r3
 8000566:	2300      	movs	r3, #0
 8000568:	427f      	negs	r7, r7
 800056a:	4699      	mov	r9, r3
 800056c:	469a      	mov	sl, r3
 800056e:	1a3f      	subs	r7, r7, r0
 8000570:	e777      	b.n	8000462 <__aeabi_fdiv+0x32>
 8000572:	4640      	mov	r0, r8
 8000574:	f7ff ff3e 	bl	80003f4 <__clzsi2>
 8000578:	4642      	mov	r2, r8
 800057a:	1f43      	subs	r3, r0, #5
 800057c:	409a      	lsls	r2, r3
 800057e:	2376      	movs	r3, #118	; 0x76
 8000580:	425b      	negs	r3, r3
 8000582:	4690      	mov	r8, r2
 8000584:	1a1b      	subs	r3, r3, r0
 8000586:	2200      	movs	r2, #0
 8000588:	e77d      	b.n	8000486 <__aeabi_fdiv+0x56>
 800058a:	23ff      	movs	r3, #255	; 0xff
 800058c:	2203      	movs	r2, #3
 800058e:	e77a      	b.n	8000486 <__aeabi_fdiv+0x56>
 8000590:	000e      	movs	r6, r1
 8000592:	20ff      	movs	r0, #255	; 0xff
 8000594:	2500      	movs	r5, #0
 8000596:	e7ac      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 8000598:	2001      	movs	r0, #1
 800059a:	1ac0      	subs	r0, r0, r3
 800059c:	281b      	cmp	r0, #27
 800059e:	dca6      	bgt.n	80004ee <__aeabi_fdiv+0xbe>
 80005a0:	379e      	adds	r7, #158	; 0x9e
 80005a2:	002a      	movs	r2, r5
 80005a4:	40bd      	lsls	r5, r7
 80005a6:	40c2      	lsrs	r2, r0
 80005a8:	1e6b      	subs	r3, r5, #1
 80005aa:	419d      	sbcs	r5, r3
 80005ac:	4315      	orrs	r5, r2
 80005ae:	076b      	lsls	r3, r5, #29
 80005b0:	d004      	beq.n	80005bc <__aeabi_fdiv+0x18c>
 80005b2:	230f      	movs	r3, #15
 80005b4:	402b      	ands	r3, r5
 80005b6:	2b04      	cmp	r3, #4
 80005b8:	d000      	beq.n	80005bc <__aeabi_fdiv+0x18c>
 80005ba:	3504      	adds	r5, #4
 80005bc:	016b      	lsls	r3, r5, #5
 80005be:	d544      	bpl.n	800064a <__aeabi_fdiv+0x21a>
 80005c0:	2001      	movs	r0, #1
 80005c2:	2500      	movs	r5, #0
 80005c4:	e795      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 80005c6:	20ff      	movs	r0, #255	; 0xff
 80005c8:	2500      	movs	r5, #0
 80005ca:	e792      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 80005cc:	2580      	movs	r5, #128	; 0x80
 80005ce:	2600      	movs	r6, #0
 80005d0:	20ff      	movs	r0, #255	; 0xff
 80005d2:	03ed      	lsls	r5, r5, #15
 80005d4:	e78d      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 80005d6:	2300      	movs	r3, #0
 80005d8:	4698      	mov	r8, r3
 80005da:	2080      	movs	r0, #128	; 0x80
 80005dc:	03c0      	lsls	r0, r0, #15
 80005de:	4205      	tst	r5, r0
 80005e0:	d009      	beq.n	80005f6 <__aeabi_fdiv+0x1c6>
 80005e2:	4643      	mov	r3, r8
 80005e4:	4203      	tst	r3, r0
 80005e6:	d106      	bne.n	80005f6 <__aeabi_fdiv+0x1c6>
 80005e8:	4645      	mov	r5, r8
 80005ea:	4305      	orrs	r5, r0
 80005ec:	026d      	lsls	r5, r5, #9
 80005ee:	0026      	movs	r6, r4
 80005f0:	20ff      	movs	r0, #255	; 0xff
 80005f2:	0a6d      	lsrs	r5, r5, #9
 80005f4:	e77d      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 80005f6:	2080      	movs	r0, #128	; 0x80
 80005f8:	03c0      	lsls	r0, r0, #15
 80005fa:	4305      	orrs	r5, r0
 80005fc:	026d      	lsls	r5, r5, #9
 80005fe:	20ff      	movs	r0, #255	; 0xff
 8000600:	0a6d      	lsrs	r5, r5, #9
 8000602:	e776      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 8000604:	4642      	mov	r2, r8
 8000606:	016b      	lsls	r3, r5, #5
 8000608:	0150      	lsls	r0, r2, #5
 800060a:	4283      	cmp	r3, r0
 800060c:	d219      	bcs.n	8000642 <__aeabi_fdiv+0x212>
 800060e:	221b      	movs	r2, #27
 8000610:	2500      	movs	r5, #0
 8000612:	3f01      	subs	r7, #1
 8000614:	2601      	movs	r6, #1
 8000616:	001c      	movs	r4, r3
 8000618:	006d      	lsls	r5, r5, #1
 800061a:	005b      	lsls	r3, r3, #1
 800061c:	2c00      	cmp	r4, #0
 800061e:	db01      	blt.n	8000624 <__aeabi_fdiv+0x1f4>
 8000620:	4298      	cmp	r0, r3
 8000622:	d801      	bhi.n	8000628 <__aeabi_fdiv+0x1f8>
 8000624:	1a1b      	subs	r3, r3, r0
 8000626:	4335      	orrs	r5, r6
 8000628:	3a01      	subs	r2, #1
 800062a:	2a00      	cmp	r2, #0
 800062c:	d1f3      	bne.n	8000616 <__aeabi_fdiv+0x1e6>
 800062e:	1e5a      	subs	r2, r3, #1
 8000630:	4193      	sbcs	r3, r2
 8000632:	431d      	orrs	r5, r3
 8000634:	003b      	movs	r3, r7
 8000636:	337f      	adds	r3, #127	; 0x7f
 8000638:	000e      	movs	r6, r1
 800063a:	2b00      	cmp	r3, #0
 800063c:	dd00      	ble.n	8000640 <__aeabi_fdiv+0x210>
 800063e:	e741      	b.n	80004c4 <__aeabi_fdiv+0x94>
 8000640:	e7aa      	b.n	8000598 <__aeabi_fdiv+0x168>
 8000642:	221a      	movs	r2, #26
 8000644:	2501      	movs	r5, #1
 8000646:	1a1b      	subs	r3, r3, r0
 8000648:	e7e4      	b.n	8000614 <__aeabi_fdiv+0x1e4>
 800064a:	01ad      	lsls	r5, r5, #6
 800064c:	2000      	movs	r0, #0
 800064e:	0a6d      	lsrs	r5, r5, #9
 8000650:	e74f      	b.n	80004f2 <__aeabi_fdiv+0xc2>
 8000652:	46c0      	nop			; (mov r8, r8)
 8000654:	0800585c 	.word	0x0800585c
 8000658:	f7ffffff 	.word	0xf7ffffff
 800065c:	0800589c 	.word	0x0800589c

08000660 <__aeabi_f2iz>:
 8000660:	0241      	lsls	r1, r0, #9
 8000662:	0042      	lsls	r2, r0, #1
 8000664:	0fc3      	lsrs	r3, r0, #31
 8000666:	0a49      	lsrs	r1, r1, #9
 8000668:	2000      	movs	r0, #0
 800066a:	0e12      	lsrs	r2, r2, #24
 800066c:	2a7e      	cmp	r2, #126	; 0x7e
 800066e:	dd03      	ble.n	8000678 <__aeabi_f2iz+0x18>
 8000670:	2a9d      	cmp	r2, #157	; 0x9d
 8000672:	dd02      	ble.n	800067a <__aeabi_f2iz+0x1a>
 8000674:	4a09      	ldr	r2, [pc, #36]	; (800069c <__aeabi_f2iz+0x3c>)
 8000676:	1898      	adds	r0, r3, r2
 8000678:	4770      	bx	lr
 800067a:	2080      	movs	r0, #128	; 0x80
 800067c:	0400      	lsls	r0, r0, #16
 800067e:	4301      	orrs	r1, r0
 8000680:	2a95      	cmp	r2, #149	; 0x95
 8000682:	dc07      	bgt.n	8000694 <__aeabi_f2iz+0x34>
 8000684:	2096      	movs	r0, #150	; 0x96
 8000686:	1a82      	subs	r2, r0, r2
 8000688:	40d1      	lsrs	r1, r2
 800068a:	4248      	negs	r0, r1
 800068c:	2b00      	cmp	r3, #0
 800068e:	d1f3      	bne.n	8000678 <__aeabi_f2iz+0x18>
 8000690:	0008      	movs	r0, r1
 8000692:	e7f1      	b.n	8000678 <__aeabi_f2iz+0x18>
 8000694:	3a96      	subs	r2, #150	; 0x96
 8000696:	4091      	lsls	r1, r2
 8000698:	e7f7      	b.n	800068a <__aeabi_f2iz+0x2a>
 800069a:	46c0      	nop			; (mov r8, r8)
 800069c:	7fffffff 	.word	0x7fffffff

080006a0 <OI_IsPlugged>:
int32_t OI_Init(void) {
  // we use the 4 byte sub address buffer as data, as this slave has few registers
 return 0;
}

int32_t OI_IsPlugged(void) {
 80006a0:	b510      	push	{r4, lr}
  BriskTimedLED_Disable(); // LED and Key used by add-on board
 80006a2:	f001 fd2b 	bl	80020fc <BriskTimedLED_Disable>

  IO_PadInit(&OI_ISM_CS_STMod);
 80006a6:	481d      	ldr	r0, [pc, #116]	; (800071c <OI_IsPlugged+0x7c>)
 80006a8:	f004 fef8 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_ISM_MOSI_STMod);
 80006ac:	481c      	ldr	r0, [pc, #112]	; (8000720 <OI_IsPlugged+0x80>)
 80006ae:	f004 fef5 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_ISM_MISO_STMod);
 80006b2:	481c      	ldr	r0, [pc, #112]	; (8000724 <OI_IsPlugged+0x84>)
 80006b4:	f004 fef2 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_ISM_SCK_STMod);
 80006b8:	481b      	ldr	r0, [pc, #108]	; (8000728 <OI_IsPlugged+0x88>)
 80006ba:	f004 feef 	bl	800549c <IO_PadInit>
#ifdef BMX055_ENABLED  
  IO_PadInit(&OI_BMX_INT2_STMod);
  IO_PadInit(&OI_BMX_INT5_STMod);
#endif  
  IO_PadInit(&OI_ISM_INT1_STMod);
 80006be:	481b      	ldr	r0, [pc, #108]	; (800072c <OI_IsPlugged+0x8c>)
 80006c0:	f004 feec 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_VEML_RES_STMod);
 80006c4:	481a      	ldr	r0, [pc, #104]	; (8000730 <OI_IsPlugged+0x90>)
 80006c6:	f004 fee9 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_PIR_ADC_STMod);
 80006ca:	4c1a      	ldr	r4, [pc, #104]	; (8000734 <OI_IsPlugged+0x94>)
 80006cc:	0020      	movs	r0, r4
 80006ce:	f004 fee5 	bl	800549c <IO_PadInit>
  IO_PadSetHigh(OI_PIR_ADC_STMod.PadName);
 80006d2:	2000      	movs	r0, #0
 80006d4:	5620      	ldrsb	r0, [r4, r0]
 80006d6:	f004 ffef 	bl	80056b8 <IO_PadSetHigh>
  IO_PadInit(&OI_VL53_XSHUT_STMod);
 80006da:	4817      	ldr	r0, [pc, #92]	; (8000738 <OI_IsPlugged+0x98>)
 80006dc:	f004 fede 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_ISM_INTMAG_STMod);
 80006e0:	4816      	ldr	r0, [pc, #88]	; (800073c <OI_IsPlugged+0x9c>)
 80006e2:	f004 fedb 	bl	800549c <IO_PadInit>
  IO_PadInit(&OI_VEML_ACK_STMod);
 80006e6:	4816      	ldr	r0, [pc, #88]	; (8000740 <OI_IsPlugged+0xa0>)
 80006e8:	f004 fed8 	bl	800549c <IO_PadInit>
#ifdef BMX055_ENABLED  
  IO_PadInit(&OI_BMX_DRDYM_STMod);
#endif  
  
  LV0104CS_Init(&LV0104CS);
 80006ec:	4c15      	ldr	r4, [pc, #84]	; (8000744 <OI_IsPlugged+0xa4>)
 80006ee:	0020      	movs	r0, r4
 80006f0:	f000 f98b 	bl	8000a0a <LV0104CS_Init>
  LV0104CS_StartContinuousConversion(&LV0104CS);
 80006f4:	0020      	movs	r0, r4
 80006f6:	f000 fa01 	bl	8000afc <LV0104CS_StartContinuousConversion>
  
  VEML6070_Init(&VEML6070);
 80006fa:	4c13      	ldr	r4, [pc, #76]	; (8000748 <OI_IsPlugged+0xa8>)
 80006fc:	0020      	movs	r0, r4
 80006fe:	f000 fa37 	bl	8000b70 <VEML6070_Init>
  VEML6070_StartContinuousConversion(&VEML6070);
 8000702:	0020      	movs	r0, r4
 8000704:	f000 fa84 	bl	8000c10 <VEML6070_StartContinuousConversion>
//-  HAL_DAC_Stop(&hdac1,DAC_CHANNEL_1);
//-  HAL_DAC_Stop(&hdac1,DAC_CHANNEL_2);
  
  // time of flight VL53L1
  //VL53L1_Init();
  VL53L1_IsPlugged(); // temp location
 8000708:	f000 faa6 	bl	8000c58 <VL53L1_IsPlugged>
  BMX055_Init();
#endif  
#ifdef ISMDLC_ENABLED
  ISM330DLC_IsPlugged();
#endif  
  BTEL.PanelSelector = 0;
 800070c:	4b0f      	ldr	r3, [pc, #60]	; (800074c <OI_IsPlugged+0xac>)
 800070e:	2200      	movs	r2, #0
 8000710:	70da      	strb	r2, [r3, #3]
  BTEL.PanelSelectorMax = BRISK_PANELS + 3;
 8000712:	3204      	adds	r2, #4
 8000714:	711a      	strb	r2, [r3, #4]
  return 0;
}
 8000716:	2000      	movs	r0, #0
 8000718:	bd10      	pop	{r4, pc}
 800071a:	46c0      	nop			; (mov r8, r8)
 800071c:	20000040 	.word	0x20000040
 8000720:	20000050 	.word	0x20000050
 8000724:	2000004c 	.word	0x2000004c
 8000728:	20000054 	.word	0x20000054
 800072c:	20000044 	.word	0x20000044
 8000730:	20000060 	.word	0x20000060
 8000734:	20000058 	.word	0x20000058
 8000738:	20000064 	.word	0x20000064
 800073c:	20000048 	.word	0x20000048
 8000740:	2000005c 	.word	0x2000005c
 8000744:	20000068 	.word	0x20000068
 8000748:	2000009c 	.word	0x2000009c
 800074c:	20000354 	.word	0x20000354

08000750 <OI_IsUnplugged>:

int32_t OI_IsUnplugged(void) {
 8000750:	b510      	push	{r4, lr}
  BriskTimedLED_Enable();
 8000752:	f001 fcd9 	bl	8002108 <BriskTimedLED_Enable>
  BriskTimedLEDsInit(); // reinit LEDs when unplugged don't forget the DEMO SWITCH for good output voltage swing
 8000756:	f001 fe6b 	bl	8002430 <BriskTimedLEDsInit>
  return 0;
}
 800075a:	2000      	movs	r0, #0
 800075c:	bd10      	pop	{r4, pc}
	...

08000760 <OI_50ms>:


int32_t OI_50ms(void) {
 8000760:	b510      	push	{r4, lr}
   
  int32_t result = 0;
  LV0104CS_50msec(&LV0104CS); // this will make continuous conversion (ODR-less sensor)
 8000762:	4805      	ldr	r0, [pc, #20]	; (8000778 <OI_50ms+0x18>)
 8000764:	f000 f9d1 	bl	8000b0a <LV0104CS_50msec>
  VEML6070_50msec(&VEML6070); // implements non blocking continuous conversion (ODR-less sensor)
 8000768:	4804      	ldr	r0, [pc, #16]	; (800077c <OI_50ms+0x1c>)
 800076a:	f000 fa58 	bl	8000c1e <VEML6070_50msec>
  VL53L1_50ms();
 800076e:	f000 fab7 	bl	8000ce0 <VL53L1_50ms>
#endif  
#ifdef ISMDLC_ENABLED  
  ISM330DLC_Polling();
#endif  
  return result;
}
 8000772:	2000      	movs	r0, #0
 8000774:	bd10      	pop	{r4, pc}
 8000776:	46c0      	nop			; (mov r8, r8)
 8000778:	20000068 	.word	0x20000068
 800077c:	2000009c 	.word	0x2000009c

08000780 <OI_1sec>:

int32_t OI_1sec(void) {
  
  return 0;  
}
 8000780:	2000      	movs	r0, #0
 8000782:	4770      	bx	lr

08000784 <OI_Report>:
#endif
//ByteVein_t* pReport = &BV_to_SPIP[STM_SERIAL];

extern float acceleration_mg[3];

int32_t OI_Report(void) {
 8000784:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000786:	46c6      	mov	lr, r8
 8000788:	b500      	push	{lr}
 800078a:	b082      	sub	sp, #8

  OI_AddOn.PIR_Raw = (Analog.ADCs.Normal_Lsb[2/*9*/]);
 800078c:	4b53      	ldr	r3, [pc, #332]	; (80008dc <OI_Report+0x158>)
 800078e:	889b      	ldrh	r3, [r3, #4]
 8000790:	4c53      	ldr	r4, [pc, #332]	; (80008e0 <OI_Report+0x15c>)
 8000792:	6263      	str	r3, [r4, #36]	; 0x24
  OI_AddOn.SubSample = (OI_AddOn.SubSample+1)%3;// every 0.5 msec (2Hz)
 8000794:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8000796:	1c58      	adds	r0, r3, #1
 8000798:	2103      	movs	r1, #3
 800079a:	f7ff fe25 	bl	80003e8 <__aeabi_idivmod>
 800079e:	62a1      	str	r1, [r4, #40]	; 0x28
  
    // bluetooth electronics
  switch(BTEL.PanelSelector) {
 80007a0:	4b50      	ldr	r3, [pc, #320]	; (80008e4 <OI_Report+0x160>)
 80007a2:	78db      	ldrb	r3, [r3, #3]
 80007a4:	2b03      	cmp	r3, #3
 80007a6:	d827      	bhi.n	80007f8 <OI_Report+0x74>
 80007a8:	2b02      	cmp	r3, #2
 80007aa:	d21f      	bcs.n	80007ec <OI_Report+0x68>
 80007ac:	2b01      	cmp	r3, #1
 80007ae:	d122      	bne.n	80007f6 <OI_Report+0x72>
  case (0+BRISK_PANELS):
    // Time Of Flight, text [t] and gauge [T]
    BTEL_Printf(OI_AddOn.pReport, "*T%d", pVL53L1->Distance); // distance in mm
 80007b0:	4b4d      	ldr	r3, [pc, #308]	; (80008e8 <OI_Report+0x164>)
 80007b2:	681b      	ldr	r3, [r3, #0]
 80007b4:	891a      	ldrh	r2, [r3, #8]
 80007b6:	4c4a      	ldr	r4, [pc, #296]	; (80008e0 <OI_Report+0x15c>)
 80007b8:	494c      	ldr	r1, [pc, #304]	; (80008ec <OI_Report+0x168>)
 80007ba:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80007bc:	f000 fd9c 	bl	80012f8 <BTEL_Printf>
    // VEML UV index
    BTEL_Printf(OI_AddOn.pReport, "*U%d", pVEML6070->UV_Index); //
 80007c0:	4b4b      	ldr	r3, [pc, #300]	; (80008f0 <OI_Report+0x16c>)
 80007c2:	681b      	ldr	r3, [r3, #0]
 80007c4:	68da      	ldr	r2, [r3, #12]
 80007c6:	494b      	ldr	r1, [pc, #300]	; (80008f4 <OI_Report+0x170>)
 80007c8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80007ca:	f000 fd95 	bl	80012f8 <BTEL_Printf>
    // VEML Lux
    BTEL_Printf(OI_AddOn.pReport,"*L%C", pLV0104CS->Lux_x100); //
 80007ce:	4b4a      	ldr	r3, [pc, #296]	; (80008f8 <OI_Report+0x174>)
 80007d0:	681b      	ldr	r3, [r3, #0]
 80007d2:	68da      	ldr	r2, [r3, #12]
 80007d4:	4949      	ldr	r1, [pc, #292]	; (80008fc <OI_Report+0x178>)
 80007d6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80007d8:	f000 fd8e 	bl	80012f8 <BTEL_Printf>
    // PIR analog
    BTEL_Printf(OI_AddOn.pReport, "*G%d.0", (int32_t) OI_AddOn.PIR_Raw ); //
 80007dc:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80007de:	4948      	ldr	r1, [pc, #288]	; (8000900 <OI_Report+0x17c>)
 80007e0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80007e2:	f000 fd89 	bl	80012f8 <BTEL_Printf>
    
    // slow down textual update on screen
    
    if(OI_AddOn.SubSample) return 0;
 80007e6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80007e8:	2b00      	cmp	r3, #0
 80007ea:	d04b      	beq.n	8000884 <OI_Report+0x100>
  default:
    TrapError();
  }

  //return 0;
}
 80007ec:	2000      	movs	r0, #0
 80007ee:	b002      	add	sp, #8
 80007f0:	bc80      	pop	{r7}
 80007f2:	46b8      	mov	r8, r7
 80007f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    TrapError();
 80007f6:	e7fe      	b.n	80007f6 <OI_Report+0x72>
  switch(BTEL.PanelSelector) {
 80007f8:	2b04      	cmp	r3, #4
 80007fa:	d142      	bne.n	8000882 <OI_Report+0xfe>
    BTEL_Printf(OI_AddOn.pReport,"*G%M,%M,%M*", (int32_t)(acceleration_mg[0]), (int32_t)(acceleration_mg[1]), (int32_t)(acceleration_mg[2]) ); //
 80007fc:	4b41      	ldr	r3, [pc, #260]	; (8000904 <OI_Report+0x180>)
 80007fe:	681c      	ldr	r4, [r3, #0]
 8000800:	6858      	ldr	r0, [r3, #4]
 8000802:	689b      	ldr	r3, [r3, #8]
 8000804:	4698      	mov	r8, r3
 8000806:	f7ff ff2b 	bl	8000660 <__aeabi_f2iz>
 800080a:	0005      	movs	r5, r0
 800080c:	1c20      	adds	r0, r4, #0
 800080e:	f7ff ff27 	bl	8000660 <__aeabi_f2iz>
 8000812:	0004      	movs	r4, r0
 8000814:	4e32      	ldr	r6, [pc, #200]	; (80008e0 <OI_Report+0x15c>)
 8000816:	6af7      	ldr	r7, [r6, #44]	; 0x2c
 8000818:	4640      	mov	r0, r8
 800081a:	f7ff ff21 	bl	8000660 <__aeabi_f2iz>
 800081e:	9000      	str	r0, [sp, #0]
 8000820:	002b      	movs	r3, r5
 8000822:	0022      	movs	r2, r4
 8000824:	4938      	ldr	r1, [pc, #224]	; (8000908 <OI_Report+0x184>)
 8000826:	0038      	movs	r0, r7
 8000828:	f000 fd66 	bl	80012f8 <BTEL_Printf>
    if(OI_AddOn.SubSample) return 0;
 800082c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800082e:	2b00      	cmp	r3, #0
 8000830:	d1dc      	bne.n	80007ec <OI_Report+0x68>
    BTEL_Printf(OI_AddOn.pReport,"*aAccX=%C g", (int32_t)(acceleration_mg[0]/10));
 8000832:	4d34      	ldr	r5, [pc, #208]	; (8000904 <OI_Report+0x180>)
 8000834:	4935      	ldr	r1, [pc, #212]	; (800090c <OI_Report+0x188>)
 8000836:	6828      	ldr	r0, [r5, #0]
 8000838:	f7ff fdfa 	bl	8000430 <__aeabi_fdiv>
 800083c:	f7ff ff10 	bl	8000660 <__aeabi_f2iz>
 8000840:	0002      	movs	r2, r0
 8000842:	4c27      	ldr	r4, [pc, #156]	; (80008e0 <OI_Report+0x15c>)
 8000844:	4932      	ldr	r1, [pc, #200]	; (8000910 <OI_Report+0x18c>)
 8000846:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000848:	f000 fd56 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport,"*bAccY=%C g", (int32_t)(acceleration_mg[1]/10));
 800084c:	492f      	ldr	r1, [pc, #188]	; (800090c <OI_Report+0x188>)
 800084e:	6868      	ldr	r0, [r5, #4]
 8000850:	f7ff fdee 	bl	8000430 <__aeabi_fdiv>
 8000854:	f7ff ff04 	bl	8000660 <__aeabi_f2iz>
 8000858:	0002      	movs	r2, r0
 800085a:	492e      	ldr	r1, [pc, #184]	; (8000914 <OI_Report+0x190>)
 800085c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800085e:	f000 fd4b 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport,"*cAccZ=%C g", (int32_t)(acceleration_mg[2]/10));
 8000862:	68a8      	ldr	r0, [r5, #8]
 8000864:	4929      	ldr	r1, [pc, #164]	; (800090c <OI_Report+0x188>)
 8000866:	f7ff fde3 	bl	8000430 <__aeabi_fdiv>
 800086a:	f7ff fef9 	bl	8000660 <__aeabi_f2iz>
 800086e:	0002      	movs	r2, r0
 8000870:	4929      	ldr	r1, [pc, #164]	; (8000918 <OI_Report+0x194>)
 8000872:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000874:	f000 fd40 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport,"*d0.0*");
 8000878:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800087a:	4928      	ldr	r1, [pc, #160]	; (800091c <OI_Report+0x198>)
 800087c:	f000 fd3c 	bl	80012f8 <BTEL_Printf>
    return 0;
 8000880:	e7b4      	b.n	80007ec <OI_Report+0x68>
 8000882:	e7b8      	b.n	80007f6 <OI_Report+0x72>
    BTEL_Printf(OI_AddOn.pReport, "*t%D cm", pVL53L1->Distance); // distance in mm
 8000884:	4d18      	ldr	r5, [pc, #96]	; (80008e8 <OI_Report+0x164>)
 8000886:	682b      	ldr	r3, [r5, #0]
 8000888:	891a      	ldrh	r2, [r3, #8]
 800088a:	4c15      	ldr	r4, [pc, #84]	; (80008e0 <OI_Report+0x15c>)
 800088c:	4924      	ldr	r1, [pc, #144]	; (8000920 <OI_Report+0x19c>)
 800088e:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000890:	f000 fd32 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport, "*uUV %d", pVEML6070->UV_Index); //
 8000894:	4b16      	ldr	r3, [pc, #88]	; (80008f0 <OI_Report+0x16c>)
 8000896:	681b      	ldr	r3, [r3, #0]
 8000898:	68da      	ldr	r2, [r3, #12]
 800089a:	4922      	ldr	r1, [pc, #136]	; (8000924 <OI_Report+0x1a0>)
 800089c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800089e:	f000 fd2b 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport, "*l%d lux", pLV0104CS->Lux_x100/100); //
 80008a2:	4b15      	ldr	r3, [pc, #84]	; (80008f8 <OI_Report+0x174>)
 80008a4:	681b      	ldr	r3, [r3, #0]
 80008a6:	68d8      	ldr	r0, [r3, #12]
 80008a8:	2164      	movs	r1, #100	; 0x64
 80008aa:	f7ff fc2d 	bl	8000108 <__udivsi3>
 80008ae:	0002      	movs	r2, r0
 80008b0:	491d      	ldr	r1, [pc, #116]	; (8000928 <OI_Report+0x1a4>)
 80008b2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80008b4:	f000 fd20 	bl	80012f8 <BTEL_Printf>
    BTEL_Printf(OI_AddOn.pReport, "*gPIR %d*", (int32_t)OI_AddOn.PIR_Raw ); //
 80008b8:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80008ba:	491c      	ldr	r1, [pc, #112]	; (800092c <OI_Report+0x1a8>)
 80008bc:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80008be:	f000 fd1b 	bl	80012f8 <BTEL_Printf>
    OI_AddOn.TOF_Delta_mm = ABS(OI_AddOn.TOF_Ref_mm-pVL53L1->Distance);
 80008c2:	682b      	ldr	r3, [r5, #0]
 80008c4:	891a      	ldrh	r2, [r3, #8]
 80008c6:	68a3      	ldr	r3, [r4, #8]
 80008c8:	1a9a      	subs	r2, r3, r2
 80008ca:	17d3      	asrs	r3, r2, #31
 80008cc:	18d2      	adds	r2, r2, r3
 80008ce:	405a      	eors	r2, r3
 80008d0:	60e2      	str	r2, [r4, #12]
    BTEL_Printf(OI_AddOn.pReport, "*d<%d mm>*", OI_AddOn.TOF_Delta_mm);
 80008d2:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80008d4:	4916      	ldr	r1, [pc, #88]	; (8000930 <OI_Report+0x1ac>)
 80008d6:	f000 fd0f 	bl	80012f8 <BTEL_Printf>
    return 0;
 80008da:	e787      	b.n	80007ec <OI_Report+0x68>
 80008dc:	200021bc 	.word	0x200021bc
 80008e0:	20000010 	.word	0x20000010
 80008e4:	20000354 	.word	0x20000354
 80008e8:	200000ec 	.word	0x200000ec
 80008ec:	080058dc 	.word	0x080058dc
 80008f0:	200000cc 	.word	0x200000cc
 80008f4:	080058e4 	.word	0x080058e4
 80008f8:	20000098 	.word	0x20000098
 80008fc:	080058ec 	.word	0x080058ec
 8000900:	080058f4 	.word	0x080058f4
 8000904:	20000234 	.word	0x20000234
 8000908:	08005930 	.word	0x08005930
 800090c:	41200000 	.word	0x41200000
 8000910:	0800593c 	.word	0x0800593c
 8000914:	08005948 	.word	0x08005948
 8000918:	08005954 	.word	0x08005954
 800091c:	08005960 	.word	0x08005960
 8000920:	080058fc 	.word	0x080058fc
 8000924:	08005904 	.word	0x08005904
 8000928:	0800590c 	.word	0x0800590c
 800092c:	08005918 	.word	0x08005918
 8000930:	08005924 	.word	0x08005924

08000934 <OI_PaneProcess>:

int32_t OI_PaneProcess(void) {
  
  char c = BTEL.incoming[0];
 8000934:	4b08      	ldr	r3, [pc, #32]	; (8000958 <OI_PaneProcess+0x24>)
 8000936:	7c1a      	ldrb	r2, [r3, #16]
  
  // called when this is the add-on board of this STM32
  // for now, we assume it is master brisk.
  if(pBTEL->PanelSelector==(0+BRISK_PANELS)) { // no interaction
 8000938:	4b08      	ldr	r3, [pc, #32]	; (800095c <OI_PaneProcess+0x28>)
 800093a:	681b      	ldr	r3, [r3, #0]
 800093c:	78db      	ldrb	r3, [r3, #3]
 800093e:	2b01      	cmp	r3, #1
 8000940:	d001      	beq.n	8000946 <OI_PaneProcess+0x12>

  if(pBTEL->PanelSelector==(2+BRISK_PANELS)) { // no interaction
  };
  
  return 0;
}
 8000942:	2000      	movs	r0, #0
 8000944:	4770      	bx	lr
    if(c=='o') // time of flight autozero
 8000946:	2a6f      	cmp	r2, #111	; 0x6f
 8000948:	d1fb      	bne.n	8000942 <OI_PaneProcess+0xe>
      OI_AddOn.TOF_Ref_mm = pVL53L1->Distance;
 800094a:	4b05      	ldr	r3, [pc, #20]	; (8000960 <OI_PaneProcess+0x2c>)
 800094c:	681b      	ldr	r3, [r3, #0]
 800094e:	891a      	ldrh	r2, [r3, #8]
 8000950:	4b04      	ldr	r3, [pc, #16]	; (8000964 <OI_PaneProcess+0x30>)
 8000952:	609a      	str	r2, [r3, #8]
 8000954:	e7f5      	b.n	8000942 <OI_PaneProcess+0xe>
 8000956:	46c0      	nop			; (mov r8, r8)
 8000958:	20000354 	.word	0x20000354
 800095c:	200000f0 	.word	0x200000f0
 8000960:	200000ec 	.word	0x200000ec
 8000964:	20000010 	.word	0x20000010

08000968 <OI_SetPanel>:
add_roll_graph(3,0,8,-2.0,2.0,100,G,Accelero,,,0,0,1,0,0,1,medium,none,3,x,42,97,222,y,237,115,7,z,255,255,0)\n\
run()\n\
*\n";
//add_gauge(11,0,3,0,100,0,V,0,,10,2)\n

int32_t OI_SetPanel(void) {
 8000968:	b510      	push	{r4, lr}

  switch(BTEL.PanelSelector) {
 800096a:	4b15      	ldr	r3, [pc, #84]	; (80009c0 <OI_SetPanel+0x58>)
 800096c:	78db      	ldrb	r3, [r3, #3]
 800096e:	2b03      	cmp	r3, #3
 8000970:	d01e      	beq.n	80009b0 <OI_SetPanel+0x48>
 8000972:	d80b      	bhi.n	800098c <OI_SetPanel+0x24>
 8000974:	2b01      	cmp	r3, #1
 8000976:	d013      	beq.n	80009a0 <OI_SetPanel+0x38>
 8000978:	2b02      	cmp	r3, #2
 800097a:	d106      	bne.n	800098a <OI_SetPanel+0x22>
  case (0+BRISK_PANELS):
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel1);
  break;
  case (1+BRISK_PANELS):
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel2);
 800097c:	4b11      	ldr	r3, [pc, #68]	; (80009c4 <OI_SetPanel+0x5c>)
 800097e:	6819      	ldr	r1, [r3, #0]
 8000980:	4b11      	ldr	r3, [pc, #68]	; (80009c8 <OI_SetPanel+0x60>)
 8000982:	6818      	ldr	r0, [r3, #0]
 8000984:	f000 fe36 	bl	80015f4 <TransmitPanel>
  break;
 8000988:	e010      	b.n	80009ac <OI_SetPanel+0x44>
 800098a:	e008      	b.n	800099e <OI_SetPanel+0x36>
  switch(BTEL.PanelSelector) {
 800098c:	2b04      	cmp	r3, #4
 800098e:	d106      	bne.n	800099e <OI_SetPanel+0x36>
  case (2+BRISK_PANELS):
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel3);
  break;
  case (3+BRISK_PANELS):
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel4);
 8000990:	4b0e      	ldr	r3, [pc, #56]	; (80009cc <OI_SetPanel+0x64>)
 8000992:	6819      	ldr	r1, [r3, #0]
 8000994:	4b0c      	ldr	r3, [pc, #48]	; (80009c8 <OI_SetPanel+0x60>)
 8000996:	6818      	ldr	r0, [r3, #0]
 8000998:	f000 fe2c 	bl	80015f4 <TransmitPanel>
  break;
 800099c:	e006      	b.n	80009ac <OI_SetPanel+0x44>
  default:
    TrapError();
 800099e:	e7fe      	b.n	800099e <OI_SetPanel+0x36>
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel1);
 80009a0:	4b0b      	ldr	r3, [pc, #44]	; (80009d0 <OI_SetPanel+0x68>)
 80009a2:	6819      	ldr	r1, [r3, #0]
 80009a4:	4b08      	ldr	r3, [pc, #32]	; (80009c8 <OI_SetPanel+0x60>)
 80009a6:	6818      	ldr	r0, [r3, #0]
 80009a8:	f000 fe24 	bl	80015f4 <TransmitPanel>
  }
  
  return 0;
}
 80009ac:	2000      	movs	r0, #0
 80009ae:	bd10      	pop	{r4, pc}
    TransmitPanel(pBrisk_Report, (char*)BTEL_OI_Panel3);
 80009b0:	4b08      	ldr	r3, [pc, #32]	; (80009d4 <OI_SetPanel+0x6c>)
 80009b2:	6819      	ldr	r1, [r3, #0]
 80009b4:	4b04      	ldr	r3, [pc, #16]	; (80009c8 <OI_SetPanel+0x60>)
 80009b6:	6818      	ldr	r0, [r3, #0]
 80009b8:	f000 fe1c 	bl	80015f4 <TransmitPanel>
  break;
 80009bc:	e7f6      	b.n	80009ac <OI_SetPanel+0x44>
 80009be:	46c0      	nop			; (mov r8, r8)
 80009c0:	20000354 	.word	0x20000354
 80009c4:	20000004 	.word	0x20000004
 80009c8:	200001f0 	.word	0x200001f0
 80009cc:	2000000c 	.word	0x2000000c
 80009d0:	20000000 	.word	0x20000000
 80009d4:	20000008 	.word	0x20000008

080009d8 <LV0104CS_WriteReg>:
I2C_SlaveDevice_t gSTModLV0104CS  = {   &gI2C_STMod, 0x26, 0 };
LV0104CS_t LV0104CS = { &gSTModLV0104CS, 0, 0, 0 };
LV0104CS_t* pLV0104CS = &LV0104CS;


int32_t LV0104CS_WriteReg(LV0104CS_t* pLV, uint8_t w1) {
 80009d8:	b510      	push	{r4, lr}
  
  int32_t result = 0;
  
  pLV->pD->pWriteByte[0] = w1;
 80009da:	6803      	ldr	r3, [r0, #0]
 80009dc:	68db      	ldr	r3, [r3, #12]
 80009de:	7019      	strb	r1, [r3, #0]
  pLV->pD->WriteByteCount = 1;
 80009e0:	2301      	movs	r3, #1
 80009e2:	6802      	ldr	r2, [r0, #0]
 80009e4:	8213      	strh	r3, [r2, #16]
  pLV->pD->ReadByteCount = 0;
 80009e6:	2300      	movs	r3, #0
 80009e8:	6802      	ldr	r2, [r0, #0]
 80009ea:	8313      	strh	r3, [r2, #24]
  
  result = I2C_MasterIO_AccessSlave(pLV->pD);
 80009ec:	6800      	ldr	r0, [r0, #0]
 80009ee:	f000 ffff 	bl	80019f0 <I2C_MasterIO_AccessSlave>
  
  return result;
}
 80009f2:	bd10      	pop	{r4, pc}

080009f4 <LV0104CS_ReadReg>:

int32_t LV0104CS_ReadReg(LV0104CS_t* pLV);
int32_t LV0104CS_ReadReg(LV0104CS_t* pLV) {
 80009f4:	b510      	push	{r4, lr}
  
  int32_t result;
  
  //pLV->pD->pWriteByte[0] = w1;
  pLV->pD->WriteByteCount = 0;
 80009f6:	2300      	movs	r3, #0
 80009f8:	6802      	ldr	r2, [r0, #0]
 80009fa:	8213      	strh	r3, [r2, #16]
  pLV->pD->ReadByteCount = 2;
 80009fc:	3302      	adds	r3, #2
 80009fe:	6802      	ldr	r2, [r0, #0]
 8000a00:	8313      	strh	r3, [r2, #24]
  
  result = I2C_MasterIO_AccessSlave(pLV->pD);
 8000a02:	6800      	ldr	r0, [r0, #0]
 8000a04:	f000 fff4 	bl	80019f0 <I2C_MasterIO_AccessSlave>
  return result;
}
 8000a08:	bd10      	pop	{r4, pc}

08000a0a <LV0104CS_Init>:

int32_t LV0104CS_Init(LV0104CS_t* pLV) {

  int32_t result = 0;
  
  pLV->pD->pWriteByte = &pLV->pD->SubAdrBytes[0]; // first unused 2 bytes of sub address to write up to 2 data bytes registers
 8000a0a:	6803      	ldr	r3, [r0, #0]
 8000a0c:	1d9a      	adds	r2, r3, #6
 8000a0e:	60da      	str	r2, [r3, #12]
  pLV->pD->pReadByte = &pLV->pD->SubAdrBytes[2];  // last unused 2 bytes of sub address to read up to 2 data bytes registers
 8000a10:	6803      	ldr	r3, [r0, #0]
 8000a12:	001a      	movs	r2, r3
 8000a14:	3208      	adds	r2, #8
 8000a16:	615a      	str	r2, [r3, #20]

  pLV->CR = 0xEC;
 8000a18:	23ec      	movs	r3, #236	; 0xec
 8000a1a:	7103      	strb	r3, [r0, #4]
  pLV->Sensitivity = 0x80;
 8000a1c:	3b6c      	subs	r3, #108	; 0x6c
 8000a1e:	7143      	strb	r3, [r0, #5]
  
  return result;
}
 8000a20:	2000      	movs	r0, #0
 8000a22:	4770      	bx	lr

08000a24 <LV0104CS_ReadData>:

int32_t LV0104CS_ReadData(LV0104CS_t* pLV) {
 8000a24:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a26:	46c6      	mov	lr, r8
 8000a28:	b500      	push	{lr}
 8000a2a:	0004      	movs	r4, r0
  
  int32_t result = 0;
  int32_t read;
  int32_t gain_x1000 = 1000; // 1000 / 1000 = 100% 
  uint8_t sens = pLV->Sensitivity & 0x3F;
 8000a2c:	7946      	ldrb	r6, [r0, #5]
 8000a2e:	273f      	movs	r7, #63	; 0x3f
 8000a30:	4037      	ands	r7, r6
 
  result |= LV0104CS_ReadReg(pLV);
 8000a32:	f7ff ffdf 	bl	80009f4 <LV0104CS_ReadReg>
 8000a36:	4680      	mov	r8, r0
  
  read = pLV->Readout = MAKEWORD(pLV->pD->SubAdrBytes[2],pLV->pD->SubAdrBytes[3]);
 8000a38:	6823      	ldr	r3, [r4, #0]
 8000a3a:	7a5d      	ldrb	r5, [r3, #9]
 8000a3c:	7a1b      	ldrb	r3, [r3, #8]
 8000a3e:	021b      	lsls	r3, r3, #8
 8000a40:	431d      	orrs	r5, r3
 8000a42:	8125      	strh	r5, [r4, #8]
  
  // convert to lux with gain adjustment
  if(sens) {
 8000a44:	2f00      	cmp	r7, #0
 8000a46:	d019      	beq.n	8000a7c <LV0104CS_ReadData+0x58>
    if(sens & 0x20) { // sign = 1
 8000a48:	06b3      	lsls	r3, r6, #26
 8000a4a:	d50b      	bpl.n	8000a64 <LV0104CS_ReadData+0x40>
      sens &= 0x1F;
 8000a4c:	211f      	movs	r1, #31
 8000a4e:	4031      	ands	r1, r6
      gain_x1000 = (2*sens*1000)/(2*sens+1);
 8000a50:	0148      	lsls	r0, r1, #5
 8000a52:	1a40      	subs	r0, r0, r1
 8000a54:	0080      	lsls	r0, r0, #2
 8000a56:	1840      	adds	r0, r0, r1
 8000a58:	0100      	lsls	r0, r0, #4
 8000a5a:	0049      	lsls	r1, r1, #1
 8000a5c:	3101      	adds	r1, #1
 8000a5e:	f7ff fbdd 	bl	800021c <__divsi3>
 8000a62:	e00d      	b.n	8000a80 <LV0104CS_ReadData+0x5c>
    }else{
      sens&= 0x1F;
 8000a64:	211f      	movs	r1, #31
 8000a66:	4031      	ands	r1, r6
      gain_x1000 = ((2*sens+1)*1000)/(2*sens);     
 8000a68:	0049      	lsls	r1, r1, #1
 8000a6a:	1c4a      	adds	r2, r1, #1
 8000a6c:	0153      	lsls	r3, r2, #5
 8000a6e:	1a9b      	subs	r3, r3, r2
 8000a70:	0098      	lsls	r0, r3, #2
 8000a72:	1880      	adds	r0, r0, r2
 8000a74:	00c0      	lsls	r0, r0, #3
 8000a76:	f7ff fbd1 	bl	800021c <__divsi3>
 8000a7a:	e001      	b.n	8000a80 <LV0104CS_ReadData+0x5c>
  int32_t gain_x1000 = 1000; // 1000 / 1000 = 100% 
 8000a7c:	20fa      	movs	r0, #250	; 0xfa
 8000a7e:	0080      	lsls	r0, r0, #2
    }
  }

  switch((pLV->CR >>3)&0x03) { // factor out the gain
 8000a80:	7922      	ldrb	r2, [r4, #4]
 8000a82:	08d2      	lsrs	r2, r2, #3
 8000a84:	2303      	movs	r3, #3
 8000a86:	4013      	ands	r3, r2
 8000a88:	2b02      	cmp	r3, #2
 8000a8a:	d00e      	beq.n	8000aaa <LV0104CS_ReadData+0x86>
 8000a8c:	2b03      	cmp	r3, #3
 8000a8e:	d010      	beq.n	8000ab2 <LV0104CS_ReadData+0x8e>
 8000a90:	2b00      	cmp	r3, #0
 8000a92:	d008      	beq.n	8000aa6 <LV0104CS_ReadData+0x82>
  case 1:;break; // gain 1 = no change
  case 2:gain_x1000 /= 2;break;// gain x2, real value /2
  case 3:gain_x1000 /= 8;break;
  }
  
  pLV->Lux_x100 = (100 * read * gain_x1000)/1000;
 8000a94:	4368      	muls	r0, r5
 8000a96:	210a      	movs	r1, #10
 8000a98:	f7ff fbc0 	bl	800021c <__divsi3>
 8000a9c:	60e0      	str	r0, [r4, #12]
  
  return result;
}
 8000a9e:	4640      	mov	r0, r8
 8000aa0:	bc80      	pop	{r7}
 8000aa2:	46b8      	mov	r8, r7
 8000aa4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  case 0:gain_x1000 *= 4;break; // gain x0.25, real value x4
 8000aa6:	0080      	lsls	r0, r0, #2
 8000aa8:	e7f4      	b.n	8000a94 <LV0104CS_ReadData+0x70>
  case 2:gain_x1000 /= 2;break;// gain x2, real value /2
 8000aaa:	0fc3      	lsrs	r3, r0, #31
 8000aac:	1818      	adds	r0, r3, r0
 8000aae:	1040      	asrs	r0, r0, #1
 8000ab0:	e7f0      	b.n	8000a94 <LV0104CS_ReadData+0x70>
  case 3:gain_x1000 /= 8;break;
 8000ab2:	17c2      	asrs	r2, r0, #31
 8000ab4:	2307      	movs	r3, #7
 8000ab6:	4013      	ands	r3, r2
 8000ab8:	1818      	adds	r0, r3, r0
 8000aba:	10c0      	asrs	r0, r0, #3
 8000abc:	e7ea      	b.n	8000a94 <LV0104CS_ReadData+0x70>

08000abe <LV0104CS_StartOneShotConversion>:
  result |= LV0104CS_ReadData(pLV);
  pLV->ReadoutUpdated = 1;
  return result;
}

int32_t LV0104CS_StartOneShotConversion(LV0104CS_t* pLV) {
 8000abe:	b510      	push	{r4, lr}
 8000ac0:	0004      	movs	r4, r0
  
  int32_t result;
  int8_t counts;

  switch((pLV->CR >>1)&0x03) {
 8000ac2:	7901      	ldrb	r1, [r0, #4]
 8000ac4:	084a      	lsrs	r2, r1, #1
 8000ac6:	2303      	movs	r3, #3
 8000ac8:	4013      	ands	r3, r2
 8000aca:	2b01      	cmp	r3, #1
 8000acc:	d004      	beq.n	8000ad8 <LV0104CS_StartOneShotConversion+0x1a>
 8000ace:	2b02      	cmp	r3, #2
 8000ad0:	d004      	beq.n	8000adc <LV0104CS_StartOneShotConversion+0x1e>
 8000ad2:	2b00      	cmp	r3, #0
 8000ad4:	d010      	beq.n	8000af8 <LV0104CS_StartOneShotConversion+0x3a>
  case 0:counts = 2;break;
  case 1:counts = 3;break;
  case 2:counts = 5;break;
  default:TrapError(); break; // unsupported
 8000ad6:	e7fe      	b.n	8000ad6 <LV0104CS_StartOneShotConversion+0x18>
  case 1:counts = 3;break;
 8000ad8:	2303      	movs	r3, #3
 8000ada:	e000      	b.n	8000ade <LV0104CS_StartOneShotConversion+0x20>
  case 2:counts = 5;break;
 8000adc:	2305      	movs	r3, #5
  }
  pLV->Countdown_50msInit = counts;
 8000ade:	b2db      	uxtb	r3, r3
 8000ae0:	7423      	strb	r3, [r4, #16]
  pLV->Countdown_50ms = counts;
 8000ae2:	7463      	strb	r3, [r4, #17]
  pLV->ContinuousEnable = 0;
 8000ae4:	2300      	movs	r3, #0
 8000ae6:	71a3      	strb	r3, [r4, #6]
  
  result = LV0104CS_WriteReg(pLV, pLV->CR);          // 11xG GTTS
 8000ae8:	0020      	movs	r0, r4
 8000aea:	f7ff ff75 	bl	80009d8 <LV0104CS_WriteReg>
  result = LV0104CS_WriteReg(pLV, pLV->Sensitivity); // 10Ss ssss
 8000aee:	7961      	ldrb	r1, [r4, #5]
 8000af0:	0020      	movs	r0, r4
 8000af2:	f7ff ff71 	bl	80009d8 <LV0104CS_WriteReg>

  return result;
}
 8000af6:	bd10      	pop	{r4, pc}
  switch((pLV->CR >>1)&0x03) {
 8000af8:	2302      	movs	r3, #2
 8000afa:	e7f0      	b.n	8000ade <LV0104CS_StartOneShotConversion+0x20>

08000afc <LV0104CS_StartContinuousConversion>:

int32_t LV0104CS_StartContinuousConversion(LV0104CS_t* pLV) {
 8000afc:	b510      	push	{r4, lr}
 8000afe:	0004      	movs	r4, r0
  
  int32_t result;
  
  result = LV0104CS_StartOneShotConversion(pLV);
 8000b00:	f7ff ffdd 	bl	8000abe <LV0104CS_StartOneShotConversion>
  pLV->ContinuousEnable = 1;
 8000b04:	2301      	movs	r3, #1
 8000b06:	71a3      	strb	r3, [r4, #6]
  
  return result;
}
 8000b08:	bd10      	pop	{r4, pc}

08000b0a <LV0104CS_50msec>:


int32_t LV0104CS_50msec(LV0104CS_t* pLV) { // the device is free run by SW, based on CR and sensitivity levels
 8000b0a:	b570      	push	{r4, r5, r6, lr}
 8000b0c:	0004      	movs	r4, r0

  int32_t result = 0;
// manually update all values
  if(pLV->Countdown_50ms==0) return result;
 8000b0e:	7c43      	ldrb	r3, [r0, #17]
 8000b10:	2b00      	cmp	r3, #0
 8000b12:	d013      	beq.n	8000b3c <LV0104CS_50msec+0x32>
  
  pLV->Countdown_50ms--;
 8000b14:	3b01      	subs	r3, #1
 8000b16:	b2db      	uxtb	r3, r3
 8000b18:	7443      	strb	r3, [r0, #17]
  if(pLV->Countdown_50ms!=0) return result;
 8000b1a:	2b00      	cmp	r3, #0
 8000b1c:	d001      	beq.n	8000b22 <LV0104CS_50msec+0x18>
 8000b1e:	2500      	movs	r5, #0
 8000b20:	e00d      	b.n	8000b3e <LV0104CS_50msec+0x34>
  
  // time elapsed!
  result |= LV0104CS_ReadData(pLV);
 8000b22:	f7ff ff7f 	bl	8000a24 <LV0104CS_ReadData>
 8000b26:	0005      	movs	r5, r0
  pLV->ReadoutUpdated = 1;
 8000b28:	2301      	movs	r3, #1
 8000b2a:	71e3      	strb	r3, [r4, #7]
  
  if(pLV->ContinuousEnable) {
 8000b2c:	79a3      	ldrb	r3, [r4, #6]
 8000b2e:	2b00      	cmp	r3, #0
 8000b30:	d005      	beq.n	8000b3e <LV0104CS_50msec+0x34>
    result |= LV0104CS_StartContinuousConversion(pLV); // at this point, the CR and Sensitivity fields will be updated to the sensor registers no change during conversion
 8000b32:	0020      	movs	r0, r4
 8000b34:	f7ff ffe2 	bl	8000afc <LV0104CS_StartContinuousConversion>
 8000b38:	4305      	orrs	r5, r0
 8000b3a:	e000      	b.n	8000b3e <LV0104CS_50msec+0x34>
  if(pLV->Countdown_50ms==0) return result;
 8000b3c:	2500      	movs	r5, #0
  }

  return result;
}
 8000b3e:	0028      	movs	r0, r5
 8000b40:	bd70      	pop	{r4, r5, r6, pc}

08000b42 <VEML6070_WriteReg>:
 
  return result;
}


int32_t VEML6070_WriteReg(VEML6070_t* pVE, uint8_t w1) {
 8000b42:	b570      	push	{r4, r5, r6, lr}
 8000b44:	0004      	movs	r4, r0
 8000b46:	000d      	movs	r5, r1
  pVE->pD->pReadByte = &pVE->pD->SubAdrBytes[2];  // read LSB
  pVE->pD->ReadByteCount = 1;
  result = I2C_MasterIO_AccessDevice(pVE->pD);
  //== ACK ======== 8>< ------------------
  */
  pVE->pD->SlaveAdr = 0x70;
 8000b48:	2370      	movs	r3, #112	; 0x70
 8000b4a:	6802      	ldr	r2, [r0, #0]
 8000b4c:	7113      	strb	r3, [r2, #4]
  pVE->pD->pWriteByte[0] = w1;
 8000b4e:	6803      	ldr	r3, [r0, #0]
 8000b50:	68db      	ldr	r3, [r3, #12]
 8000b52:	7019      	strb	r1, [r3, #0]
  pVE->pD->pWriteByte = &pVE->pD->SubAdrBytes[0]; // first unused 2 bytes of sub address to write up to 2 data bytes registers
 8000b54:	6803      	ldr	r3, [r0, #0]
 8000b56:	1d9a      	adds	r2, r3, #6
 8000b58:	60da      	str	r2, [r3, #12]
  pVE->pD->WriteByteCount = 1;
 8000b5a:	2301      	movs	r3, #1
 8000b5c:	6802      	ldr	r2, [r0, #0]
 8000b5e:	8213      	strh	r3, [r2, #16]

  pVE->pD->ReadByteCount = 0;
 8000b60:	2300      	movs	r3, #0
 8000b62:	6802      	ldr	r2, [r0, #0]
 8000b64:	8313      	strh	r3, [r2, #24]
  
  result |= I2C_MasterIO_AccessSlave(pVE->pD);
 8000b66:	6800      	ldr	r0, [r0, #0]
 8000b68:	f000 ff42 	bl	80019f0 <I2C_MasterIO_AccessSlave>
  pVE->CR = w1; // remember what was written
 8000b6c:	7125      	strb	r5, [r4, #4]
    
  return result;
}
 8000b6e:	bd70      	pop	{r4, r5, r6, pc}

08000b70 <VEML6070_Init>:
int32_t VEML6070_Init(VEML6070_t* pVE) {
 8000b70:	b510      	push	{r4, lr}
  VEML6070_WriteReg(pVE, 0x02); // no INT, no ACK
 8000b72:	2102      	movs	r1, #2
 8000b74:	f7ff ffe5 	bl	8000b42 <VEML6070_WriteReg>
}
 8000b78:	2000      	movs	r0, #0
 8000b7a:	bd10      	pop	{r4, pc}

08000b7c <VEML6070_ReadReg>:

int32_t VEML6070_ReadReg(VEML6070_t* pVE) {
 8000b7c:	b510      	push	{r4, lr}
 8000b7e:	0004      	movs	r4, r0
  pVE->pD->pReadByte = &pVE->pD->SubAdrBytes[2];  // read LSB
  pVE->pD->ReadByteCount = 1;
  result = I2C_MasterIO_AccessDevice(pVE->pD);
  //== ACK ======== 8>< ------------------
*/  
  pVE->pD->SlaveAdr = 0x70;
 8000b80:	2370      	movs	r3, #112	; 0x70
 8000b82:	6802      	ldr	r2, [r0, #0]
 8000b84:	7113      	strb	r3, [r2, #4]
  pVE->pD->WriteByteCount = 0;
 8000b86:	2300      	movs	r3, #0
 8000b88:	6802      	ldr	r2, [r0, #0]
 8000b8a:	8213      	strh	r3, [r2, #16]
  pVE->pD->pReadByte = &pVE->pD->SubAdrBytes[2];  // read LSB
 8000b8c:	6803      	ldr	r3, [r0, #0]
 8000b8e:	001a      	movs	r2, r3
 8000b90:	3208      	adds	r2, #8
 8000b92:	615a      	str	r2, [r3, #20]
  pVE->pD->ReadByteCount = 1;
 8000b94:	2301      	movs	r3, #1
 8000b96:	6802      	ldr	r2, [r0, #0]
 8000b98:	8313      	strh	r3, [r2, #24]
  result = I2C_MasterIO_AccessSlave(pVE->pD);
 8000b9a:	6800      	ldr	r0, [r0, #0]
 8000b9c:	f000 ff28 	bl	80019f0 <I2C_MasterIO_AccessSlave>

  pVE->pD->SlaveAdr = 0x72;  
 8000ba0:	2372      	movs	r3, #114	; 0x72
 8000ba2:	6822      	ldr	r2, [r4, #0]
 8000ba4:	7113      	strb	r3, [r2, #4]
  pVE->pD->pReadByte = &pVE->pD->SubAdrBytes[3];  // read MSB
 8000ba6:	6823      	ldr	r3, [r4, #0]
 8000ba8:	001a      	movs	r2, r3
 8000baa:	3209      	adds	r2, #9
 8000bac:	615a      	str	r2, [r3, #20]
  result = I2C_MasterIO_AccessSlave(pVE->pD);
 8000bae:	6820      	ldr	r0, [r4, #0]
 8000bb0:	f000 ff1e 	bl	80019f0 <I2C_MasterIO_AccessSlave>
  
  return result;
}
 8000bb4:	bd10      	pop	{r4, pc}

08000bb6 <VEML6070_ReadData>:

//==== VEML6070 no sub address


int32_t VEML6070_ReadData(VEML6070_t* pVE) {
 8000bb6:	b510      	push	{r4, lr}
 8000bb8:	0004      	movs	r4, r0
  
  int32_t result = 0;
 
  result |= VEML6070_ReadReg(pVE);
 8000bba:	f7ff ffdf 	bl	8000b7c <VEML6070_ReadReg>
  pVE->UV_Index = pVE->Readout = MAKEWORD(pVE->pD->SubAdrBytes[3],pVE->pD->SubAdrBytes[2]);
 8000bbe:	6822      	ldr	r2, [r4, #0]
 8000bc0:	7a13      	ldrb	r3, [r2, #8]
 8000bc2:	7a52      	ldrb	r2, [r2, #9]
 8000bc4:	0212      	lsls	r2, r2, #8
 8000bc6:	4313      	orrs	r3, r2
 8000bc8:	8123      	strh	r3, [r4, #8]
 8000bca:	60e3      	str	r3, [r4, #12]
  
  return result;
}
 8000bcc:	bd10      	pop	{r4, pc}

08000bce <VEML6070_StartOneShotConversion>:
  result |= VEML6070_ReadData(pVE);
  pVE->ReadoutUpdated = 1;
  return result;
}

int32_t VEML6070_StartOneShotConversion(VEML6070_t* pVE) {
 8000bce:	b510      	push	{r4, lr}
  
  int32_t result;
  int8_t counts = 0;

  switch((pVE->CR >>2)&0x03) {
 8000bd0:	7901      	ldrb	r1, [r0, #4]
 8000bd2:	088a      	lsrs	r2, r1, #2
 8000bd4:	2303      	movs	r3, #3
 8000bd6:	4013      	ands	r3, r2
 8000bd8:	2b02      	cmp	r3, #2
 8000bda:	d011      	beq.n	8000c00 <VEML6070_StartOneShotConversion+0x32>
 8000bdc:	d80c      	bhi.n	8000bf8 <VEML6070_StartOneShotConversion+0x2a>
 8000bde:	2b00      	cmp	r3, #0
 8000be0:	d010      	beq.n	8000c04 <VEML6070_StartOneShotConversion+0x36>
 8000be2:	2b01      	cmp	r3, #1
 8000be4:	d110      	bne.n	8000c08 <VEML6070_StartOneShotConversion+0x3a>
  case 0:counts = 3;break;  // 62.5ms ==> 150ms = 3x50
  case 1:counts = 4;break;  // 125+50=175=200 = 4x50
 8000be6:	3303      	adds	r3, #3
  case 2:counts = 6;break;  // 250ms + 50 = 300 = 6x30
  case 3:counts = 11;break; // 500+50 = 11
  }
  pVE->Countdown_50msInit = counts;
 8000be8:	b2db      	uxtb	r3, r3
 8000bea:	7403      	strb	r3, [r0, #16]
  pVE->Countdown_50ms = counts;
 8000bec:	7443      	strb	r3, [r0, #17]
  pVE->ContinuousEnable = 0;
 8000bee:	2300      	movs	r3, #0
 8000bf0:	7143      	strb	r3, [r0, #5]
  
  result = VEML6070_WriteReg(pVE, pVE->CR);          // write command register
 8000bf2:	f7ff ffa6 	bl	8000b42 <VEML6070_WriteReg>

  return result;
}
 8000bf6:	bd10      	pop	{r4, pc}
  switch((pVE->CR >>2)&0x03) {
 8000bf8:	2b03      	cmp	r3, #3
 8000bfa:	d107      	bne.n	8000c0c <VEML6070_StartOneShotConversion+0x3e>
  case 3:counts = 11;break; // 500+50 = 11
 8000bfc:	3308      	adds	r3, #8
 8000bfe:	e7f3      	b.n	8000be8 <VEML6070_StartOneShotConversion+0x1a>
  case 2:counts = 6;break;  // 250ms + 50 = 300 = 6x30
 8000c00:	2306      	movs	r3, #6
 8000c02:	e7f1      	b.n	8000be8 <VEML6070_StartOneShotConversion+0x1a>
  case 0:counts = 3;break;  // 62.5ms ==> 150ms = 3x50
 8000c04:	2303      	movs	r3, #3
 8000c06:	e7ef      	b.n	8000be8 <VEML6070_StartOneShotConversion+0x1a>
  switch((pVE->CR >>2)&0x03) {
 8000c08:	2300      	movs	r3, #0
 8000c0a:	e7ed      	b.n	8000be8 <VEML6070_StartOneShotConversion+0x1a>
 8000c0c:	2300      	movs	r3, #0
 8000c0e:	e7eb      	b.n	8000be8 <VEML6070_StartOneShotConversion+0x1a>

08000c10 <VEML6070_StartContinuousConversion>:

int32_t VEML6070_StartContinuousConversion(VEML6070_t* pVE) {
 8000c10:	b510      	push	{r4, lr}
 8000c12:	0004      	movs	r4, r0
  
  int32_t result;
  
  result = VEML6070_StartOneShotConversion(pVE);
 8000c14:	f7ff ffdb 	bl	8000bce <VEML6070_StartOneShotConversion>
  pVE->ContinuousEnable = 1;
 8000c18:	2301      	movs	r3, #1
 8000c1a:	7163      	strb	r3, [r4, #5]
  
  return result;
}
 8000c1c:	bd10      	pop	{r4, pc}

08000c1e <VEML6070_50msec>:


int32_t VEML6070_50msec(VEML6070_t* pVE) { // the device is free run by SW, based on CR and sensitivity levels
 8000c1e:	b570      	push	{r4, r5, r6, lr}
 8000c20:	0004      	movs	r4, r0

  int32_t result = 0;
// manually update all values
  if(pVE->Countdown_50ms==0) return result;
 8000c22:	7c43      	ldrb	r3, [r0, #17]
 8000c24:	2b00      	cmp	r3, #0
 8000c26:	d013      	beq.n	8000c50 <VEML6070_50msec+0x32>
  
  pVE->Countdown_50ms--;
 8000c28:	3b01      	subs	r3, #1
 8000c2a:	b2db      	uxtb	r3, r3
 8000c2c:	7443      	strb	r3, [r0, #17]
  if(pVE->Countdown_50ms!=0) return result;
 8000c2e:	2b00      	cmp	r3, #0
 8000c30:	d001      	beq.n	8000c36 <VEML6070_50msec+0x18>
 8000c32:	2500      	movs	r5, #0
 8000c34:	e00d      	b.n	8000c52 <VEML6070_50msec+0x34>
  
  // time elapsed!
  result |= VEML6070_ReadData(pVE);
 8000c36:	f7ff ffbe 	bl	8000bb6 <VEML6070_ReadData>
 8000c3a:	0005      	movs	r5, r0
  pVE->ReadoutUpdated = 1;
 8000c3c:	2301      	movs	r3, #1
 8000c3e:	71a3      	strb	r3, [r4, #6]
  
  if(pVE->ContinuousEnable) {
 8000c40:	7963      	ldrb	r3, [r4, #5]
 8000c42:	2b00      	cmp	r3, #0
 8000c44:	d005      	beq.n	8000c52 <VEML6070_50msec+0x34>
    result |= VEML6070_StartContinuousConversion(pVE); // at this point, the CR and Sensitivity fields will be updated to the sensor registers no change during conversion
 8000c46:	0020      	movs	r0, r4
 8000c48:	f7ff ffe2 	bl	8000c10 <VEML6070_StartContinuousConversion>
 8000c4c:	4305      	orrs	r5, r0
 8000c4e:	e000      	b.n	8000c52 <VEML6070_50msec+0x34>
  if(pVE->Countdown_50ms==0) return result;
 8000c50:	2500      	movs	r5, #0
  }

  return result;
}
 8000c52:	0028      	movs	r0, r5
 8000c54:	bd70      	pop	{r4, r5, r6, pc}
	...

08000c58 <VL53L1_IsPlugged>:



int32_t VL53L1_Init(void) { NOPs(1); return 0;}

int32_t VL53L1_IsPlugged(void) {
 8000c58:	b570      	push	{r4, r5, r6, lr}
 8000c5a:	b082      	sub	sp, #8
  
  int status=0;
  
  pVL53L1->pSD = &VL53L1SD; 
 8000c5c:	4d1c      	ldr	r5, [pc, #112]	; (8000cd0 <VL53L1_IsPlugged+0x78>)
 8000c5e:	682b      	ldr	r3, [r5, #0]
 8000c60:	4a1c      	ldr	r2, [pc, #112]	; (8000cd4 <VL53L1_IsPlugged+0x7c>)
 8000c62:	601a      	str	r2, [r3, #0]
  
/* Those basic I2C read functions can be used to check your own I2C functions */
  status = VL53L1_RdByte(&dev, 0x010F, &pVL53L1->ModelID); // printf("VL53L1X Model_ID: %X\n", byteData);
 8000c64:	682b      	ldr	r3, [r5, #0]
 8000c66:	1d1a      	adds	r2, r3, #4
 8000c68:	2610      	movs	r6, #16
 8000c6a:	36ff      	adds	r6, #255	; 0xff
 8000c6c:	4c1a      	ldr	r4, [pc, #104]	; (8000cd8 <VL53L1_IsPlugged+0x80>)
 8000c6e:	0031      	movs	r1, r6
 8000c70:	0020      	movs	r0, r4
 8000c72:	f000 fa25 	bl	80010c0 <VL53L1_RdByte>
  status = VL53L1_RdByte(&dev, 0x0110, &pVL53L1->ModuleType); // printf("VL53L1X Module_Type: %X\n", byteData);
 8000c76:	682a      	ldr	r2, [r5, #0]
 8000c78:	3205      	adds	r2, #5
 8000c7a:	2188      	movs	r1, #136	; 0x88
 8000c7c:	0049      	lsls	r1, r1, #1
 8000c7e:	0020      	movs	r0, r4
 8000c80:	f000 fa1e 	bl	80010c0 <VL53L1_RdByte>
  status = VL53L1_RdWord(&dev, 0x010F, &wordData); // printf("VL53L1X: %X\n", wordData);
 8000c84:	4a15      	ldr	r2, [pc, #84]	; (8000cdc <VL53L1_IsPlugged+0x84>)
 8000c86:	0031      	movs	r1, r6
 8000c88:	0020      	movs	r0, r4
 8000c8a:	f000 fa35 	bl	80010f8 <VL53L1_RdWord>
  while(pVL53L1->sensorState==0){
 8000c8e:	e00b      	b.n	8000ca8 <VL53L1_IsPlugged+0x50>
	status = VL53L1X_BootState(dev, &pVL53L1->sensorState);
 8000c90:	4c11      	ldr	r4, [pc, #68]	; (8000cd8 <VL53L1_IsPlugged+0x80>)
 8000c92:	3306      	adds	r3, #6
 8000c94:	9300      	str	r3, [sp, #0]
 8000c96:	6820      	ldr	r0, [r4, #0]
 8000c98:	6861      	ldr	r1, [r4, #4]
 8000c9a:	68a2      	ldr	r2, [r4, #8]
 8000c9c:	68e3      	ldr	r3, [r4, #12]
 8000c9e:	f000 f91f 	bl	8000ee0 <VL53L1X_BootState>
	HAL_Delay(2);
 8000ca2:	2002      	movs	r0, #2
 8000ca4:	f002 fd44 	bl	8003730 <HAL_Delay>
  while(pVL53L1->sensorState==0){
 8000ca8:	4b09      	ldr	r3, [pc, #36]	; (8000cd0 <VL53L1_IsPlugged+0x78>)
 8000caa:	681b      	ldr	r3, [r3, #0]
 8000cac:	799a      	ldrb	r2, [r3, #6]
 8000cae:	2a00      	cmp	r2, #0
 8000cb0:	d0ee      	beq.n	8000c90 <VL53L1_IsPlugged+0x38>
  }
  
  /* This function must to be called */
  status = VL53L1X_SensorInit(dev);
 8000cb2:	4c09      	ldr	r4, [pc, #36]	; (8000cd8 <VL53L1_IsPlugged+0x80>)
 8000cb4:	6820      	ldr	r0, [r4, #0]
 8000cb6:	6861      	ldr	r1, [r4, #4]
 8000cb8:	68a2      	ldr	r2, [r4, #8]
 8000cba:	68e3      	ldr	r3, [r4, #12]
 8000cbc:	f000 f8c4 	bl	8000e48 <VL53L1X_SensorInit>
//  status = VL53L1X_SetOffset(dev,20); /* offset compensation in mm */
//  status = VL53L1X_SetROI(dev, 16, 16); /* minimum ROI 4,4 */
//	status = VL53L1X_CalibrateOffset(dev, 140, &offset); /* may take few second to perform the offset cal*/
//	status = VL53L1X_CalibrateXtalk(dev, 1000, &xtalk); /* may take few second to perform the xtalk cal */
//  printf("VL53L1X Ultra Lite Driver Example running ...\n");
  status = VL53L1X_StartRanging(dev);   /* This function has to be called to enable the ranging */
 8000cc0:	6820      	ldr	r0, [r4, #0]
 8000cc2:	6861      	ldr	r1, [r4, #4]
 8000cc4:	68a2      	ldr	r2, [r4, #8]
 8000cc6:	68e3      	ldr	r3, [r4, #12]
 8000cc8:	f000 f87c 	bl	8000dc4 <VL53L1X_StartRanging>

  return status;
}
 8000ccc:	b002      	add	sp, #8
 8000cce:	bd70      	pop	{r4, r5, r6, pc}
 8000cd0:	200000ec 	.word	0x200000ec
 8000cd4:	200000d0 	.word	0x200000d0
 8000cd8:	20000240 	.word	0x20000240
 8000cdc:	20000250 	.word	0x20000250

08000ce0 <VL53L1_50ms>:


int32_t VL53L1_50ms(void) {
 8000ce0:	b530      	push	{r4, r5, lr}
 8000ce2:	b085      	sub	sp, #20

  int status;
  uint8_t dataReady;
  
  status = VL53L1X_CheckForDataReady(dev, &dataReady);  
 8000ce4:	4b22      	ldr	r3, [pc, #136]	; (8000d70 <VL53L1_50ms+0x90>)
 8000ce6:	240f      	movs	r4, #15
 8000ce8:	446c      	add	r4, sp
 8000cea:	9400      	str	r4, [sp, #0]
 8000cec:	6818      	ldr	r0, [r3, #0]
 8000cee:	6859      	ldr	r1, [r3, #4]
 8000cf0:	689a      	ldr	r2, [r3, #8]
 8000cf2:	68db      	ldr	r3, [r3, #12]
 8000cf4:	f000 f880 	bl	8000df8 <VL53L1X_CheckForDataReady>
  if(dataReady == 0)
 8000cf8:	7823      	ldrb	r3, [r4, #0]
 8000cfa:	2b00      	cmp	r3, #0
 8000cfc:	d103      	bne.n	8000d06 <VL53L1_50ms+0x26>
    return 0;
 8000cfe:	2400      	movs	r4, #0
  status = VL53L1X_GetSignalRate(dev, &pVL53L1->SignalRate);
  status = VL53L1X_GetAmbientRate(dev, &pVL53L1->AmbientRate);
  status = VL53L1X_ClearInterrupt(dev); /* clear interrupt has to be called to enable next interrupt*/
  NOPs(1); // breakpoint hook point
  return status;
}
 8000d00:	0020      	movs	r0, r4
 8000d02:	b005      	add	sp, #20
 8000d04:	bd30      	pop	{r4, r5, pc}
  HAL_Delay(2);
 8000d06:	2002      	movs	r0, #2
 8000d08:	f002 fd12 	bl	8003730 <HAL_Delay>
  status = VL53L1X_GetRangeStatus(dev, &pVL53L1->RangeStatus);
 8000d0c:	4d19      	ldr	r5, [pc, #100]	; (8000d74 <VL53L1_50ms+0x94>)
 8000d0e:	4c18      	ldr	r4, [pc, #96]	; (8000d70 <VL53L1_50ms+0x90>)
 8000d10:	682b      	ldr	r3, [r5, #0]
 8000d12:	3307      	adds	r3, #7
 8000d14:	9300      	str	r3, [sp, #0]
 8000d16:	6820      	ldr	r0, [r4, #0]
 8000d18:	6861      	ldr	r1, [r4, #4]
 8000d1a:	68a2      	ldr	r2, [r4, #8]
 8000d1c:	68e3      	ldr	r3, [r4, #12]
 8000d1e:	f000 f92d 	bl	8000f7c <VL53L1X_GetRangeStatus>
  status = VL53L1X_GetDistance(dev, &pVL53L1->Distance);
 8000d22:	682b      	ldr	r3, [r5, #0]
 8000d24:	3308      	adds	r3, #8
 8000d26:	9300      	str	r3, [sp, #0]
 8000d28:	6820      	ldr	r0, [r4, #0]
 8000d2a:	6861      	ldr	r1, [r4, #4]
 8000d2c:	68a2      	ldr	r2, [r4, #8]
 8000d2e:	68e3      	ldr	r3, [r4, #12]
 8000d30:	f000 f8ec 	bl	8000f0c <VL53L1X_GetDistance>
  status = VL53L1X_GetSignalRate(dev, &pVL53L1->SignalRate);
 8000d34:	682b      	ldr	r3, [r5, #0]
 8000d36:	330a      	adds	r3, #10
 8000d38:	9300      	str	r3, [sp, #0]
 8000d3a:	6820      	ldr	r0, [r4, #0]
 8000d3c:	6861      	ldr	r1, [r4, #4]
 8000d3e:	68a2      	ldr	r2, [r4, #8]
 8000d40:	68e3      	ldr	r3, [r4, #12]
 8000d42:	f000 f8f5 	bl	8000f30 <VL53L1X_GetSignalRate>
  status = VL53L1X_GetAmbientRate(dev, &pVL53L1->AmbientRate);
 8000d46:	682b      	ldr	r3, [r5, #0]
 8000d48:	330c      	adds	r3, #12
 8000d4a:	9300      	str	r3, [sp, #0]
 8000d4c:	6820      	ldr	r0, [r4, #0]
 8000d4e:	6861      	ldr	r1, [r4, #4]
 8000d50:	68a2      	ldr	r2, [r4, #8]
 8000d52:	68e3      	ldr	r3, [r4, #12]
 8000d54:	f000 f8ff 	bl	8000f56 <VL53L1X_GetAmbientRate>
  status = VL53L1X_ClearInterrupt(dev); /* clear interrupt has to be called to enable next interrupt*/
 8000d58:	6820      	ldr	r0, [r4, #0]
 8000d5a:	6861      	ldr	r1, [r4, #4]
 8000d5c:	68a2      	ldr	r2, [r4, #8]
 8000d5e:	68e3      	ldr	r3, [r4, #12]
 8000d60:	f000 f80a 	bl	8000d78 <VL53L1X_ClearInterrupt>
 8000d64:	0004      	movs	r4, r0
  NOPs(1); // breakpoint hook point
 8000d66:	2001      	movs	r0, #1
 8000d68:	f002 fa90 	bl	800328c <NOPs>
  return status;
 8000d6c:	e7c8      	b.n	8000d00 <VL53L1_50ms+0x20>
 8000d6e:	46c0      	nop			; (mov r8, r8)
 8000d70:	20000240 	.word	0x20000240
 8000d74:	200000ec 	.word	0x200000ec

08000d78 <VL53L1X_ClearInterrupt>:
	status = VL53L1_WrByte(&dev, 0x0B, 0); /* start VHV from the previous temperature */
	return status;
}

VL53L1X_ERROR VL53L1X_ClearInterrupt(VL53L1_Dev_t dev)
{
 8000d78:	b500      	push	{lr}
 8000d7a:	b085      	sub	sp, #20
 8000d7c:	9000      	str	r0, [sp, #0]
 8000d7e:	9101      	str	r1, [sp, #4]
 8000d80:	9202      	str	r2, [sp, #8]
 8000d82:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;

	status = VL53L1_WrByte(&dev, SYSTEM__INTERRUPT_CLEAR, 0x01);
 8000d84:	2201      	movs	r2, #1
 8000d86:	2186      	movs	r1, #134	; 0x86
 8000d88:	4668      	mov	r0, sp
 8000d8a:	f000 f987 	bl	800109c <VL53L1_WrByte>
	return status;
}
 8000d8e:	b005      	add	sp, #20
 8000d90:	bd00      	pop	{pc}

08000d92 <VL53L1X_GetInterruptPolarity>:
	status = VL53L1_WrByte(&dev, GPIO_HV_MUX__CTRL, Temp | (!(NewPolarity & 1)) << 4);
	return status;
}

VL53L1X_ERROR VL53L1X_GetInterruptPolarity(VL53L1_Dev_t dev, uint8_t *pInterruptPolarity)
{
 8000d92:	b500      	push	{lr}
 8000d94:	b087      	sub	sp, #28
 8000d96:	9000      	str	r0, [sp, #0]
 8000d98:	9101      	str	r1, [sp, #4]
 8000d9a:	9202      	str	r2, [sp, #8]
 8000d9c:	9303      	str	r3, [sp, #12]
	uint8_t Temp;
	VL53L1X_ERROR status = 0;

	status = VL53L1_RdByte(&dev, GPIO_HV_MUX__CTRL, &Temp);
 8000d9e:	2317      	movs	r3, #23
 8000da0:	446b      	add	r3, sp
 8000da2:	001a      	movs	r2, r3
 8000da4:	2130      	movs	r1, #48	; 0x30
 8000da6:	4668      	mov	r0, sp
 8000da8:	f000 f98a 	bl	80010c0 <VL53L1_RdByte>
	Temp = Temp & 0x10;
 8000dac:	466b      	mov	r3, sp
 8000dae:	7dda      	ldrb	r2, [r3, #23]
 8000db0:	2310      	movs	r3, #16
 8000db2:	4013      	ands	r3, r2
 8000db4:	466a      	mov	r2, sp
 8000db6:	75d3      	strb	r3, [r2, #23]
	*pInterruptPolarity = !(Temp>>4);
 8000db8:	425a      	negs	r2, r3
 8000dba:	4153      	adcs	r3, r2
 8000dbc:	9a08      	ldr	r2, [sp, #32]
 8000dbe:	7013      	strb	r3, [r2, #0]
	return status;
}
 8000dc0:	b007      	add	sp, #28
 8000dc2:	bd00      	pop	{pc}

08000dc4 <VL53L1X_StartRanging>:

VL53L1X_ERROR VL53L1X_StartRanging(VL53L1_Dev_t dev)
{
 8000dc4:	b500      	push	{lr}
 8000dc6:	b085      	sub	sp, #20
 8000dc8:	9000      	str	r0, [sp, #0]
 8000dca:	9101      	str	r1, [sp, #4]
 8000dcc:	9202      	str	r2, [sp, #8]
 8000dce:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;

	status = VL53L1_WrByte(&dev, SYSTEM__MODE_START, 0x40);	/* Enable VL53L1X */
 8000dd0:	2240      	movs	r2, #64	; 0x40
 8000dd2:	2187      	movs	r1, #135	; 0x87
 8000dd4:	4668      	mov	r0, sp
 8000dd6:	f000 f961 	bl	800109c <VL53L1_WrByte>
	return status;
}
 8000dda:	b005      	add	sp, #20
 8000ddc:	bd00      	pop	{pc}

08000dde <VL53L1X_StopRanging>:

VL53L1X_ERROR VL53L1X_StopRanging(VL53L1_Dev_t dev)
{
 8000dde:	b500      	push	{lr}
 8000de0:	b085      	sub	sp, #20
 8000de2:	9000      	str	r0, [sp, #0]
 8000de4:	9101      	str	r1, [sp, #4]
 8000de6:	9202      	str	r2, [sp, #8]
 8000de8:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;

	status = VL53L1_WrByte(&dev, SYSTEM__MODE_START, 0x00);	/* Disable VL53L1X */
 8000dea:	2200      	movs	r2, #0
 8000dec:	2187      	movs	r1, #135	; 0x87
 8000dee:	4668      	mov	r0, sp
 8000df0:	f000 f954 	bl	800109c <VL53L1_WrByte>
	return status;
}
 8000df4:	b005      	add	sp, #20
 8000df6:	bd00      	pop	{pc}

08000df8 <VL53L1X_CheckForDataReady>:

VL53L1X_ERROR VL53L1X_CheckForDataReady(VL53L1_Dev_t dev, uint8_t *isDataReady)
{
 8000df8:	b500      	push	{lr}
 8000dfa:	b089      	sub	sp, #36	; 0x24
 8000dfc:	9002      	str	r0, [sp, #8]
 8000dfe:	9103      	str	r1, [sp, #12]
 8000e00:	9204      	str	r2, [sp, #16]
 8000e02:	9305      	str	r3, [sp, #20]
	uint8_t Temp;
	uint8_t IntPol;
	VL53L1X_ERROR status = 0;

	status = VL53L1X_GetInterruptPolarity(dev, &IntPol);
 8000e04:	231e      	movs	r3, #30
 8000e06:	446b      	add	r3, sp
 8000e08:	9300      	str	r3, [sp, #0]
 8000e0a:	9b05      	ldr	r3, [sp, #20]
 8000e0c:	f7ff ffc1 	bl	8000d92 <VL53L1X_GetInterruptPolarity>
	status = VL53L1_RdByte(&dev, GPIO__TIO_HV_STATUS, &Temp);
 8000e10:	221f      	movs	r2, #31
 8000e12:	446a      	add	r2, sp
 8000e14:	2131      	movs	r1, #49	; 0x31
 8000e16:	a802      	add	r0, sp, #8
 8000e18:	f000 f952 	bl	80010c0 <VL53L1_RdByte>
	/* Read in the register to check if a new value is available */
	if (status == 0){
 8000e1c:	2800      	cmp	r0, #0
 8000e1e:	d10c      	bne.n	8000e3a <VL53L1X_CheckForDataReady+0x42>
		if ((Temp & 1) == IntPol)
 8000e20:	231f      	movs	r3, #31
 8000e22:	446b      	add	r3, sp
 8000e24:	7819      	ldrb	r1, [r3, #0]
 8000e26:	231e      	movs	r3, #30
 8000e28:	446b      	add	r3, sp
 8000e2a:	781a      	ldrb	r2, [r3, #0]
 8000e2c:	2301      	movs	r3, #1
 8000e2e:	400b      	ands	r3, r1
 8000e30:	429a      	cmp	r2, r3
 8000e32:	d004      	beq.n	8000e3e <VL53L1X_CheckForDataReady+0x46>
			*isDataReady = 1;
		else
			*isDataReady = 0;
 8000e34:	2300      	movs	r3, #0
 8000e36:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000e38:	7013      	strb	r3, [r2, #0]
	}
	return status;
}
 8000e3a:	b009      	add	sp, #36	; 0x24
 8000e3c:	bd00      	pop	{pc}
			*isDataReady = 1;
 8000e3e:	2301      	movs	r3, #1
 8000e40:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8000e42:	7013      	strb	r3, [r2, #0]
 8000e44:	e7f9      	b.n	8000e3a <VL53L1X_CheckForDataReady+0x42>
	...

08000e48 <VL53L1X_SensorInit>:
{
 8000e48:	b510      	push	{r4, lr}
 8000e4a:	b088      	sub	sp, #32
 8000e4c:	9002      	str	r0, [sp, #8]
 8000e4e:	9103      	str	r1, [sp, #12]
 8000e50:	9204      	str	r2, [sp, #16]
 8000e52:	9305      	str	r3, [sp, #20]
	uint8_t Addr = 0x00, tmp=0;
 8000e54:	231f      	movs	r3, #31
 8000e56:	446b      	add	r3, sp
 8000e58:	2200      	movs	r2, #0
 8000e5a:	701a      	strb	r2, [r3, #0]
	for (Addr = 0x2D; Addr <= 0x87; Addr++){
 8000e5c:	242d      	movs	r4, #45	; 0x2d
 8000e5e:	e009      	b.n	8000e74 <VL53L1X_SensorInit+0x2c>
		status = VL53L1_WrByte(&dev, Addr, VL51L1X_DEFAULT_CONFIGURATION[Addr - 0x2D]);
 8000e60:	0023      	movs	r3, r4
 8000e62:	3b2d      	subs	r3, #45	; 0x2d
 8000e64:	4a1d      	ldr	r2, [pc, #116]	; (8000edc <VL53L1X_SensorInit+0x94>)
 8000e66:	5cd2      	ldrb	r2, [r2, r3]
 8000e68:	b2a1      	uxth	r1, r4
 8000e6a:	a802      	add	r0, sp, #8
 8000e6c:	f000 f916 	bl	800109c <VL53L1_WrByte>
	for (Addr = 0x2D; Addr <= 0x87; Addr++){
 8000e70:	3401      	adds	r4, #1
 8000e72:	b2e4      	uxtb	r4, r4
 8000e74:	2c87      	cmp	r4, #135	; 0x87
 8000e76:	d9f3      	bls.n	8000e60 <VL53L1X_SensorInit+0x18>
	status = VL53L1X_StartRanging(dev);
 8000e78:	9802      	ldr	r0, [sp, #8]
 8000e7a:	9903      	ldr	r1, [sp, #12]
 8000e7c:	9a04      	ldr	r2, [sp, #16]
 8000e7e:	9b05      	ldr	r3, [sp, #20]
 8000e80:	f7ff ffa0 	bl	8000dc4 <VL53L1X_StartRanging>
	while(tmp==0){
 8000e84:	e008      	b.n	8000e98 <VL53L1X_SensorInit+0x50>
			status = VL53L1X_CheckForDataReady(dev, &tmp);
 8000e86:	231f      	movs	r3, #31
 8000e88:	446b      	add	r3, sp
 8000e8a:	9300      	str	r3, [sp, #0]
 8000e8c:	9802      	ldr	r0, [sp, #8]
 8000e8e:	9903      	ldr	r1, [sp, #12]
 8000e90:	9a04      	ldr	r2, [sp, #16]
 8000e92:	9b05      	ldr	r3, [sp, #20]
 8000e94:	f7ff ffb0 	bl	8000df8 <VL53L1X_CheckForDataReady>
	while(tmp==0){
 8000e98:	231f      	movs	r3, #31
 8000e9a:	446b      	add	r3, sp
 8000e9c:	781b      	ldrb	r3, [r3, #0]
 8000e9e:	2b00      	cmp	r3, #0
 8000ea0:	d0f1      	beq.n	8000e86 <VL53L1X_SensorInit+0x3e>
	tmp  = 0;
 8000ea2:	231f      	movs	r3, #31
 8000ea4:	446b      	add	r3, sp
 8000ea6:	2200      	movs	r2, #0
 8000ea8:	701a      	strb	r2, [r3, #0]
	status = VL53L1X_ClearInterrupt(dev);
 8000eaa:	9802      	ldr	r0, [sp, #8]
 8000eac:	9903      	ldr	r1, [sp, #12]
 8000eae:	9a04      	ldr	r2, [sp, #16]
 8000eb0:	9b05      	ldr	r3, [sp, #20]
 8000eb2:	f7ff ff61 	bl	8000d78 <VL53L1X_ClearInterrupt>
	status = VL53L1X_StopRanging(dev);
 8000eb6:	9802      	ldr	r0, [sp, #8]
 8000eb8:	9903      	ldr	r1, [sp, #12]
 8000eba:	9a04      	ldr	r2, [sp, #16]
 8000ebc:	9b05      	ldr	r3, [sp, #20]
 8000ebe:	f7ff ff8e 	bl	8000dde <VL53L1X_StopRanging>
	status = VL53L1_WrByte(&dev, VL53L1_VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND, 0x09); /* two bounds VHV */
 8000ec2:	2209      	movs	r2, #9
 8000ec4:	2108      	movs	r1, #8
 8000ec6:	a802      	add	r0, sp, #8
 8000ec8:	f000 f8e8 	bl	800109c <VL53L1_WrByte>
	status = VL53L1_WrByte(&dev, 0x0B, 0); /* start VHV from the previous temperature */
 8000ecc:	2200      	movs	r2, #0
 8000ece:	210b      	movs	r1, #11
 8000ed0:	a802      	add	r0, sp, #8
 8000ed2:	f000 f8e3 	bl	800109c <VL53L1_WrByte>
}
 8000ed6:	b008      	add	sp, #32
 8000ed8:	bd10      	pop	{r4, pc}
 8000eda:	46c0      	nop			; (mov r8, r8)
 8000edc:	08005f0c 	.word	0x08005f0c

08000ee0 <VL53L1X_BootState>:
	*pIM= (uint16_t)(*pIM/(ClockPLL*1.065));
	return status;
}

VL53L1X_ERROR VL53L1X_BootState(VL53L1_Dev_t dev, uint8_t *state)
{
 8000ee0:	b500      	push	{lr}
 8000ee2:	b087      	sub	sp, #28
 8000ee4:	9000      	str	r0, [sp, #0]
 8000ee6:	9101      	str	r1, [sp, #4]
 8000ee8:	9202      	str	r2, [sp, #8]
 8000eea:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;
	uint8_t tmp = 0;
 8000eec:	2300      	movs	r3, #0
 8000eee:	466a      	mov	r2, sp
 8000ef0:	75d3      	strb	r3, [r2, #23]

	status = VL53L1_RdByte(&dev,VL53L1_FIRMWARE__SYSTEM_STATUS, &tmp);
 8000ef2:	3317      	adds	r3, #23
 8000ef4:	446b      	add	r3, sp
 8000ef6:	001a      	movs	r2, r3
 8000ef8:	21e5      	movs	r1, #229	; 0xe5
 8000efa:	4668      	mov	r0, sp
 8000efc:	f000 f8e0 	bl	80010c0 <VL53L1_RdByte>
	*state = tmp;
 8000f00:	466b      	mov	r3, sp
 8000f02:	7ddb      	ldrb	r3, [r3, #23]
 8000f04:	9a08      	ldr	r2, [sp, #32]
 8000f06:	7013      	strb	r3, [r2, #0]
	return status;
}
 8000f08:	b007      	add	sp, #28
 8000f0a:	bd00      	pop	{pc}

08000f0c <VL53L1X_GetDistance>:
	*sensorId = tmp;
	return status;
}

VL53L1X_ERROR VL53L1X_GetDistance(VL53L1_Dev_t dev, uint16_t *distance)
{
 8000f0c:	b510      	push	{r4, lr}
 8000f0e:	b086      	sub	sp, #24
 8000f10:	9000      	str	r0, [sp, #0]
 8000f12:	9101      	str	r1, [sp, #4]
 8000f14:	9202      	str	r2, [sp, #8]
 8000f16:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;
	uint16_t tmp;

	status = (VL53L1_RdWord(&dev,
 8000f18:	2416      	movs	r4, #22
 8000f1a:	446c      	add	r4, sp
 8000f1c:	0022      	movs	r2, r4
 8000f1e:	2196      	movs	r1, #150	; 0x96
 8000f20:	4668      	mov	r0, sp
 8000f22:	f000 f8e9 	bl	80010f8 <VL53L1_RdWord>
			VL53L1_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0, &tmp));
	*distance = tmp;
 8000f26:	8823      	ldrh	r3, [r4, #0]
 8000f28:	9a08      	ldr	r2, [sp, #32]
 8000f2a:	8013      	strh	r3, [r2, #0]
	return status;
}
 8000f2c:	b006      	add	sp, #24
 8000f2e:	bd10      	pop	{r4, pc}

08000f30 <VL53L1X_GetSignalRate>:
	*ambPerSp=(uint16_t) (2000.0 * AmbientRate / SpNb);
	return status;
}

VL53L1X_ERROR VL53L1X_GetSignalRate(VL53L1_Dev_t dev, uint16_t *signal)
{
 8000f30:	b510      	push	{r4, lr}
 8000f32:	b086      	sub	sp, #24
 8000f34:	9000      	str	r0, [sp, #0]
 8000f36:	9101      	str	r1, [sp, #4]
 8000f38:	9202      	str	r2, [sp, #8]
 8000f3a:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;
	uint16_t tmp;

	status = VL53L1_RdWord(&dev,
 8000f3c:	2416      	movs	r4, #22
 8000f3e:	446c      	add	r4, sp
 8000f40:	0022      	movs	r2, r4
 8000f42:	2198      	movs	r1, #152	; 0x98
 8000f44:	4668      	mov	r0, sp
 8000f46:	f000 f8d7 	bl	80010f8 <VL53L1_RdWord>
		VL53L1_RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0, &tmp);
	*signal = tmp*8;
 8000f4a:	8823      	ldrh	r3, [r4, #0]
 8000f4c:	00db      	lsls	r3, r3, #3
 8000f4e:	9a08      	ldr	r2, [sp, #32]
 8000f50:	8013      	strh	r3, [r2, #0]
	return status;
}
 8000f52:	b006      	add	sp, #24
 8000f54:	bd10      	pop	{r4, pc}

08000f56 <VL53L1X_GetAmbientRate>:
	*spNb = tmp >> 8;
	return status;
}

VL53L1X_ERROR VL53L1X_GetAmbientRate(VL53L1_Dev_t dev, uint16_t *ambRate)
{
 8000f56:	b510      	push	{r4, lr}
 8000f58:	b086      	sub	sp, #24
 8000f5a:	9000      	str	r0, [sp, #0]
 8000f5c:	9101      	str	r1, [sp, #4]
 8000f5e:	9202      	str	r2, [sp, #8]
 8000f60:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;
	uint16_t tmp;

	status = VL53L1_RdWord(&dev, RESULT__AMBIENT_COUNT_RATE_MCPS_SD, &tmp);
 8000f62:	2416      	movs	r4, #22
 8000f64:	446c      	add	r4, sp
 8000f66:	0022      	movs	r2, r4
 8000f68:	2190      	movs	r1, #144	; 0x90
 8000f6a:	4668      	mov	r0, sp
 8000f6c:	f000 f8c4 	bl	80010f8 <VL53L1_RdWord>
	*ambRate = tmp*8;
 8000f70:	8823      	ldrh	r3, [r4, #0]
 8000f72:	00db      	lsls	r3, r3, #3
 8000f74:	9a08      	ldr	r2, [sp, #32]
 8000f76:	8013      	strh	r3, [r2, #0]
	return status;
}
 8000f78:	b006      	add	sp, #24
 8000f7a:	bd10      	pop	{r4, pc}

08000f7c <VL53L1X_GetRangeStatus>:

VL53L1X_ERROR VL53L1X_GetRangeStatus(VL53L1_Dev_t dev, uint8_t *rangeStatus)
{
 8000f7c:	b500      	push	{lr}
 8000f7e:	b087      	sub	sp, #28
 8000f80:	9000      	str	r0, [sp, #0]
 8000f82:	9101      	str	r1, [sp, #4]
 8000f84:	9202      	str	r2, [sp, #8]
 8000f86:	9303      	str	r3, [sp, #12]
	VL53L1X_ERROR status = 0;
	uint8_t RgSt;

	status = VL53L1_RdByte(&dev, VL53L1_RESULT__RANGE_STATUS, &RgSt);
 8000f88:	2317      	movs	r3, #23
 8000f8a:	446b      	add	r3, sp
 8000f8c:	001a      	movs	r2, r3
 8000f8e:	2189      	movs	r1, #137	; 0x89
 8000f90:	4668      	mov	r0, sp
 8000f92:	f000 f895 	bl	80010c0 <VL53L1_RdByte>
	RgSt = RgSt&0x1F;
 8000f96:	466b      	mov	r3, sp
 8000f98:	7dda      	ldrb	r2, [r3, #23]
 8000f9a:	231f      	movs	r3, #31
 8000f9c:	4013      	ands	r3, r2
 8000f9e:	466a      	mov	r2, sp
 8000fa0:	75d3      	strb	r3, [r2, #23]
	switch (RgSt) {
 8000fa2:	3b03      	subs	r3, #3
 8000fa4:	b2da      	uxtb	r2, r3
 8000fa6:	2a14      	cmp	r2, #20
 8000fa8:	d84a      	bhi.n	8001040 <VL53L1X_GetRangeStatus+0xc4>
 8000faa:	0093      	lsls	r3, r2, #2
 8000fac:	4a27      	ldr	r2, [pc, #156]	; (800104c <VL53L1X_GetRangeStatus+0xd0>)
 8000fae:	58d3      	ldr	r3, [r2, r3]
 8000fb0:	469f      	mov	pc, r3
	case 9:
		RgSt = 0;
 8000fb2:	2317      	movs	r3, #23
 8000fb4:	446b      	add	r3, sp
 8000fb6:	2200      	movs	r2, #0
 8000fb8:	701a      	strb	r2, [r3, #0]
		break;
	default:
		RgSt = 255;
		break;
	}
	*rangeStatus = RgSt;
 8000fba:	2317      	movs	r3, #23
 8000fbc:	446b      	add	r3, sp
 8000fbe:	781b      	ldrb	r3, [r3, #0]
 8000fc0:	9a08      	ldr	r2, [sp, #32]
 8000fc2:	7013      	strb	r3, [r2, #0]
	return status;
}
 8000fc4:	b007      	add	sp, #28
 8000fc6:	bd00      	pop	{pc}
		RgSt = 1;
 8000fc8:	2317      	movs	r3, #23
 8000fca:	446b      	add	r3, sp
 8000fcc:	2201      	movs	r2, #1
 8000fce:	701a      	strb	r2, [r3, #0]
		break;
 8000fd0:	e7f3      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 2;
 8000fd2:	2317      	movs	r3, #23
 8000fd4:	446b      	add	r3, sp
 8000fd6:	2202      	movs	r2, #2
 8000fd8:	701a      	strb	r2, [r3, #0]
		break;
 8000fda:	e7ee      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 3;
 8000fdc:	2317      	movs	r3, #23
 8000fde:	446b      	add	r3, sp
 8000fe0:	2203      	movs	r2, #3
 8000fe2:	701a      	strb	r2, [r3, #0]
		break;
 8000fe4:	e7e9      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 4;
 8000fe6:	2317      	movs	r3, #23
 8000fe8:	446b      	add	r3, sp
 8000fea:	2204      	movs	r2, #4
 8000fec:	701a      	strb	r2, [r3, #0]
		break;
 8000fee:	e7e4      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 5;
 8000ff0:	2317      	movs	r3, #23
 8000ff2:	446b      	add	r3, sp
 8000ff4:	2205      	movs	r2, #5
 8000ff6:	701a      	strb	r2, [r3, #0]
		break;
 8000ff8:	e7df      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 6;
 8000ffa:	2317      	movs	r3, #23
 8000ffc:	446b      	add	r3, sp
 8000ffe:	2206      	movs	r2, #6
 8001000:	701a      	strb	r2, [r3, #0]
		break;
 8001002:	e7da      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 7;
 8001004:	2317      	movs	r3, #23
 8001006:	446b      	add	r3, sp
 8001008:	2207      	movs	r2, #7
 800100a:	701a      	strb	r2, [r3, #0]
		break;
 800100c:	e7d5      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 9;
 800100e:	2317      	movs	r3, #23
 8001010:	446b      	add	r3, sp
 8001012:	2209      	movs	r2, #9
 8001014:	701a      	strb	r2, [r3, #0]
		break;
 8001016:	e7d0      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 10;
 8001018:	2317      	movs	r3, #23
 800101a:	446b      	add	r3, sp
 800101c:	220a      	movs	r2, #10
 800101e:	701a      	strb	r2, [r3, #0]
		break;
 8001020:	e7cb      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 11;
 8001022:	2317      	movs	r3, #23
 8001024:	446b      	add	r3, sp
 8001026:	220b      	movs	r2, #11
 8001028:	701a      	strb	r2, [r3, #0]
		break;
 800102a:	e7c6      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 12;
 800102c:	2317      	movs	r3, #23
 800102e:	446b      	add	r3, sp
 8001030:	220c      	movs	r2, #12
 8001032:	701a      	strb	r2, [r3, #0]
		break;
 8001034:	e7c1      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 13;
 8001036:	2317      	movs	r3, #23
 8001038:	446b      	add	r3, sp
 800103a:	220d      	movs	r2, #13
 800103c:	701a      	strb	r2, [r3, #0]
		break;
 800103e:	e7bc      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
		RgSt = 255;
 8001040:	2317      	movs	r3, #23
 8001042:	446b      	add	r3, sp
 8001044:	22ff      	movs	r2, #255	; 0xff
 8001046:	701a      	strb	r2, [r3, #0]
		break;
 8001048:	e7b7      	b.n	8000fba <VL53L1X_GetRangeStatus+0x3e>
 800104a:	46c0      	nop			; (mov r8, r8)
 800104c:	08005eb8 	.word	0x08005eb8

08001050 <_I2CWrite>:


static uint8_t _I2CBuffer[256]; // only use locally

int _I2CWrite(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count);
int _I2CWrite(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count) {
 8001050:	b510      	push	{r4, lr}
    int status;
//    int i2c_time_out = I2C_TIME_OUT_BASE+ count* I2C_TIME_OUT_BYTE;

//    status = HAL_I2C_Master_Transmit(Dev->I2cHandle, Dev->I2cDevAddr, pdata, count, i2c_time_out);
    Dev->pSD->pWriteByte = pdata;
 8001052:	6803      	ldr	r3, [r0, #0]
 8001054:	60d9      	str	r1, [r3, #12]
    Dev->pSD->WriteByteCount = count;
 8001056:	6803      	ldr	r3, [r0, #0]
 8001058:	821a      	strh	r2, [r3, #16]
    Dev->pSD->ReadByteCount = 0;
 800105a:	2300      	movs	r3, #0
 800105c:	6802      	ldr	r2, [r0, #0]
 800105e:	8313      	strh	r3, [r2, #24]
    status =  I2C_MasterIO_AccessSlave(Dev->pSD); // I2C_SlaveDevice_t // I2C Generic transaction Write+Read cycle
 8001060:	6800      	ldr	r0, [r0, #0]
 8001062:	f000 fcc5 	bl	80019f0 <I2C_MasterIO_AccessSlave>
 8001066:	1e04      	subs	r4, r0, #0
    if (status) {
 8001068:	d101      	bne.n	800106e <_I2CWrite+0x1e>
      NOPs(1);
    }
    return status;
}
 800106a:	0020      	movs	r0, r4
 800106c:	bd10      	pop	{r4, pc}
      NOPs(1);
 800106e:	2001      	movs	r0, #1
 8001070:	f002 f90c 	bl	800328c <NOPs>
    return status;
 8001074:	e7f9      	b.n	800106a <_I2CWrite+0x1a>

08001076 <_I2CRead>:

int _I2CRead(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count);
int _I2CRead(VL53L1_DEV Dev, uint8_t *pdata, uint32_t count) {
 8001076:	b510      	push	{r4, lr}
    int status;
//    int i2c_time_out = I2C_TIME_OUT_BASE+ count* I2C_TIME_OUT_BYTE;
    Dev->pSD->pReadByte = pdata;
 8001078:	6803      	ldr	r3, [r0, #0]
 800107a:	6159      	str	r1, [r3, #20]
    Dev->pSD->ReadByteCount = count;
 800107c:	6803      	ldr	r3, [r0, #0]
 800107e:	831a      	strh	r2, [r3, #24]
    Dev->pSD->WriteByteCount = 0;
 8001080:	2300      	movs	r3, #0
 8001082:	6802      	ldr	r2, [r0, #0]
 8001084:	8213      	strh	r3, [r2, #16]
    status =  I2C_MasterIO_AccessSlave(Dev->pSD); // I2C_SlaveDevice_t // I2C Generic transaction Write+Read cycle
 8001086:	6800      	ldr	r0, [r0, #0]
 8001088:	f000 fcb2 	bl	80019f0 <I2C_MasterIO_AccessSlave>
 800108c:	1e04      	subs	r4, r0, #0
    if (status) {
 800108e:	d101      	bne.n	8001094 <_I2CRead+0x1e>
      NOPs(1);
    }
    return status;
}
 8001090:	0020      	movs	r0, r4
 8001092:	bd10      	pop	{r4, pc}
      NOPs(1);
 8001094:	2001      	movs	r0, #1
 8001096:	f002 f8f9 	bl	800328c <NOPs>
    return status;
 800109a:	e7f9      	b.n	8001090 <_I2CRead+0x1a>

0800109c <VL53L1_WrByte>:

//==============

int8_t VL53L1_WrByte(VL53L1_DEV Dev, uint16_t index, uint8_t data) {
 800109c:	b510      	push	{r4, lr}
 800109e:	000b      	movs	r3, r1
    int8_t Status = 0;
    int32_t status_int;

    _I2CBuffer[0] = index>>8;
 80010a0:	4906      	ldr	r1, [pc, #24]	; (80010bc <VL53L1_WrByte+0x20>)
 80010a2:	0a1c      	lsrs	r4, r3, #8
 80010a4:	700c      	strb	r4, [r1, #0]
    _I2CBuffer[1] = index&0xFF;
 80010a6:	704b      	strb	r3, [r1, #1]
    _I2CBuffer[2] = data;
 80010a8:	708a      	strb	r2, [r1, #2]

    status_int = _I2CWrite(Dev, _I2CBuffer, 3);
 80010aa:	2203      	movs	r2, #3
 80010ac:	f7ff ffd0 	bl	8001050 <_I2CWrite>
    if (status_int != 0) {
 80010b0:	2800      	cmp	r0, #0
 80010b2:	d001      	beq.n	80010b8 <VL53L1_WrByte+0x1c>
        Status = status_int;
 80010b4:	b240      	sxtb	r0, r0
    }

    return Status;
}
 80010b6:	bd10      	pop	{r4, pc}
    int8_t Status = 0;
 80010b8:	2000      	movs	r0, #0
 80010ba:	e7fc      	b.n	80010b6 <VL53L1_WrByte+0x1a>
 80010bc:	20000254 	.word	0x20000254

080010c0 <VL53L1_RdByte>:
    }

    return Status;
}

int8_t VL53L1_RdByte(VL53L1_DEV Dev, uint16_t index, uint8_t *data) {
 80010c0:	b570      	push	{r4, r5, r6, lr}
 80010c2:	0005      	movs	r5, r0
 80010c4:	000b      	movs	r3, r1
 80010c6:	0014      	movs	r4, r2
    int8_t Status = 0;
    int32_t status_int;

	_I2CBuffer[0] = index>>8;
 80010c8:	490a      	ldr	r1, [pc, #40]	; (80010f4 <VL53L1_RdByte+0x34>)
 80010ca:	0a1a      	lsrs	r2, r3, #8
 80010cc:	700a      	strb	r2, [r1, #0]
	_I2CBuffer[1] = index&0xFF;
 80010ce:	704b      	strb	r3, [r1, #1]

    status_int = _I2CWrite(Dev, _I2CBuffer, 2);
 80010d0:	2202      	movs	r2, #2
 80010d2:	f7ff ffbd 	bl	8001050 <_I2CWrite>
    if( status_int ){
 80010d6:	2800      	cmp	r0, #0
 80010d8:	d001      	beq.n	80010de <VL53L1_RdByte+0x1e>
        Status = status_int;
 80010da:	b240      	sxtb	r0, r0
        Status = status_int;
    }
done:
    return Status;

}
 80010dc:	bd70      	pop	{r4, r5, r6, pc}
    status_int = _I2CRead(Dev, data, 1);
 80010de:	2201      	movs	r2, #1
 80010e0:	0021      	movs	r1, r4
 80010e2:	0028      	movs	r0, r5
 80010e4:	f7ff ffc7 	bl	8001076 <_I2CRead>
    if (status_int != 0) {
 80010e8:	2800      	cmp	r0, #0
 80010ea:	d001      	beq.n	80010f0 <VL53L1_RdByte+0x30>
        Status = status_int;
 80010ec:	b240      	sxtb	r0, r0
 80010ee:	e7f5      	b.n	80010dc <VL53L1_RdByte+0x1c>
    int8_t Status = 0;
 80010f0:	2000      	movs	r0, #0
 80010f2:	e7f3      	b.n	80010dc <VL53L1_RdByte+0x1c>
 80010f4:	20000254 	.word	0x20000254

080010f8 <VL53L1_RdWord>:

int8_t VL53L1_RdWord(VL53L1_DEV Dev, uint16_t index, uint16_t *data) {
 80010f8:	b570      	push	{r4, r5, r6, lr}
 80010fa:	0005      	movs	r5, r0
 80010fc:	000b      	movs	r3, r1
 80010fe:	0014      	movs	r4, r2
    int8_t Status = 0;
    int32_t status_int;

    _I2CBuffer[0] = index>>8;
 8001100:	490d      	ldr	r1, [pc, #52]	; (8001138 <VL53L1_RdWord+0x40>)
 8001102:	0a1a      	lsrs	r2, r3, #8
 8001104:	700a      	strb	r2, [r1, #0]
	_I2CBuffer[1] = index&0xFF;
 8001106:	704b      	strb	r3, [r1, #1]

    status_int = _I2CWrite(Dev, _I2CBuffer, 2);
 8001108:	2202      	movs	r2, #2
 800110a:	f7ff ffa1 	bl	8001050 <_I2CWrite>

    if( status_int ){
 800110e:	2800      	cmp	r0, #0
 8001110:	d001      	beq.n	8001116 <VL53L1_RdWord+0x1e>
        Status = status_int;
 8001112:	b240      	sxtb	r0, r0
    *data = ((uint16_t)_I2CBuffer[0]<<8) + (uint16_t)_I2CBuffer[1];
done:

    return Status;

}
 8001114:	bd70      	pop	{r4, r5, r6, pc}
    status_int = _I2CRead(Dev, _I2CBuffer, 2);
 8001116:	2202      	movs	r2, #2
 8001118:	4907      	ldr	r1, [pc, #28]	; (8001138 <VL53L1_RdWord+0x40>)
 800111a:	0028      	movs	r0, r5
 800111c:	f7ff ffab 	bl	8001076 <_I2CRead>
    if (status_int != 0) {
 8001120:	2800      	cmp	r0, #0
 8001122:	d107      	bne.n	8001134 <VL53L1_RdWord+0x3c>
    *data = ((uint16_t)_I2CBuffer[0]<<8) + (uint16_t)_I2CBuffer[1];
 8001124:	4a04      	ldr	r2, [pc, #16]	; (8001138 <VL53L1_RdWord+0x40>)
 8001126:	7813      	ldrb	r3, [r2, #0]
 8001128:	021b      	lsls	r3, r3, #8
 800112a:	7852      	ldrb	r2, [r2, #1]
 800112c:	189b      	adds	r3, r3, r2
 800112e:	8023      	strh	r3, [r4, #0]
    int8_t Status = 0;
 8001130:	2000      	movs	r0, #0
 8001132:	e7ef      	b.n	8001114 <VL53L1_RdWord+0x1c>
        Status = status_int;
 8001134:	b240      	sxtb	r0, r0
        goto done;
 8001136:	e7ed      	b.n	8001114 <VL53L1_RdWord+0x1c>
 8001138:	20000254 	.word	0x20000254

0800113c <BTEL_Enable>:

void TestSringToFrac(void);
void BTEL_TestPrintf(void);

void BTEL_Enable(void) {
  BTEL.Enabled = 1;
 800113c:	4b01      	ldr	r3, [pc, #4]	; (8001144 <BTEL_Enable+0x8>)
 800113e:	2201      	movs	r2, #1
 8001140:	701a      	strb	r2, [r3, #0]
}
 8001142:	4770      	bx	lr
 8001144:	20000354 	.word	0x20000354

08001148 <BTEL_ResetIncoming>:
}

void BTEL_ResetIncoming(void);
void BTEL_ResetIncoming(void) {
  
  BTEL.in_ndx = 0; // waiting for *
 8001148:	4b04      	ldr	r3, [pc, #16]	; (800115c <BTEL_ResetIncoming+0x14>)
 800114a:	2284      	movs	r2, #132	; 0x84
 800114c:	0092      	lsls	r2, r2, #2
 800114e:	2100      	movs	r1, #0
 8001150:	5299      	strh	r1, [r3, r2]
//    BTEL.out_ndx = 0; // waiting for filling
  BTEL.in_start = 0; // start receive multibyte when non zero
 8001152:	3204      	adds	r2, #4
 8001154:	5499      	strb	r1, [r3, r2]
  BTEL.in_stop = 0; // completed when second * has been received
 8001156:	4a02      	ldr	r2, [pc, #8]	; (8001160 <BTEL_ResetIncoming+0x18>)
 8001158:	5499      	strb	r1, [r3, r2]
  
}
 800115a:	4770      	bx	lr
 800115c:	20000354 	.word	0x20000354
 8001160:	00000215 	.word	0x00000215

08001164 <BTEL_Init>:

void BTEL_Init(void) {
 8001164:	b510      	push	{r4, lr}

 // setup at serial com port SPIP_SIF.C file   BTEL.Enabled = 1; // by default, deactivate BTEL (no JS nor micropython installed)
  BTEL.TimeSlice = -1; // could be disabled if negative
 8001166:	4c05      	ldr	r4, [pc, #20]	; (800117c <BTEL_Init+0x18>)
 8001168:	2301      	movs	r3, #1
 800116a:	425b      	negs	r3, r3
 800116c:	60e3      	str	r3, [r4, #12]
  
  BTEL_ResetIncoming();
 800116e:	f7ff ffeb 	bl	8001148 <BTEL_ResetIncoming>
  
  BTEL.PanelSelector = 0;
 8001172:	2300      	movs	r3, #0
 8001174:	70e3      	strb	r3, [r4, #3]
  BTEL.PanelSelectorMax = 0; // no add-on board detected for now
 8001176:	7123      	strb	r3, [r4, #4]
  BTEL.DeviceSelector = 0;//MAX_SLAVE; // master
 8001178:	7063      	strb	r3, [r4, #1]
  //BTEL.Delayed_PanelCountdown_100ms = 300; // if nothing works, after 30 seconds, a panel redraw will be done
//    return;
  // let's test our incoming string to value
   //TestSringToFrac();
   //BTEL_TestPrintf();
}
 800117a:	bd10      	pop	{r4, pc}
 800117c:	20000354 	.word	0x20000354

08001180 <BTEL_Incoming>:
void BTEL_Polling(void) {
  
  BTEL_Incoming();
}

void BTEL_Incoming(void) { // any chars coming from the phone's app?
 8001180:	b510      	push	{r4, lr}
  
  char c;
  
  if(BTEL.Enabled==0) return;
 8001182:	4b21      	ldr	r3, [pc, #132]	; (8001208 <BTEL_Incoming+0x88>)
 8001184:	781b      	ldrb	r3, [r3, #0]
 8001186:	2b00      	cmp	r3, #0
 8001188:	d112      	bne.n	80011b0 <BTEL_Incoming+0x30>
    // everybody got the chance to intercept the command... mono or multisource
    BTEL_ResetIncoming();
    
  }; // continue emptying the FIFO
  
}
 800118a:	bd10      	pop	{r4, pc}
      TrapError(); // overflow!
 800118c:	e7fe      	b.n	800118c <BTEL_Incoming+0xc>
      BTEL.in_start = 1;
 800118e:	2385      	movs	r3, #133	; 0x85
 8001190:	009b      	lsls	r3, r3, #2
 8001192:	3101      	adds	r1, #1
 8001194:	54e1      	strb	r1, [r4, r3]
      continue; // don't store the first '*' ^^^^
 8001196:	e00b      	b.n	80011b0 <BTEL_Incoming+0x30>
        BTEL.in_ndx++; // store the char
 8001198:	3301      	adds	r3, #1
 800119a:	491b      	ldr	r1, [pc, #108]	; (8001208 <BTEL_Incoming+0x88>)
 800119c:	2284      	movs	r2, #132	; 0x84
 800119e:	0092      	lsls	r2, r2, #2
 80011a0:	528b      	strh	r3, [r1, r2]
        continue; // intermediate
 80011a2:	e005      	b.n	80011b0 <BTEL_Incoming+0x30>
    LeftPaneProcess();
 80011a4:	f002 f82a 	bl	80031fc <LeftPaneProcess>
    RightPaneProcess();
 80011a8:	f001 ff98 	bl	80030dc <RightPaneProcess>
    BTEL_ResetIncoming();
 80011ac:	f7ff ffcc 	bl	8001148 <BTEL_ResetIncoming>
  while(u8fifo_to_SPIP[BT_STL_SERIAL].bCount) { // some characters to process
 80011b0:	4b16      	ldr	r3, [pc, #88]	; (800120c <BTEL_Incoming+0x8c>)
 80011b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80011b4:	2b00      	cmp	r3, #0
 80011b6:	d0e8      	beq.n	800118a <BTEL_Incoming+0xa>
    c = (uint8_t) Clipu8fifo_Down(&u8fifo_to_SPIP[BT_STL_SERIAL]);
 80011b8:	4815      	ldr	r0, [pc, #84]	; (8001210 <BTEL_Incoming+0x90>)
 80011ba:	f002 f914 	bl	80033e6 <Clipu8fifo_Down>
 80011be:	b2c0      	uxtb	r0, r0
    BTEL.incoming[BTEL.in_ndx] = c;
 80011c0:	4b11      	ldr	r3, [pc, #68]	; (8001208 <BTEL_Incoming+0x88>)
 80011c2:	2284      	movs	r2, #132	; 0x84
 80011c4:	0092      	lsls	r2, r2, #2
 80011c6:	5e9a      	ldrsh	r2, [r3, r2]
 80011c8:	189b      	adds	r3, r3, r2
 80011ca:	7418      	strb	r0, [r3, #16]
    if(BTEL.in_ndx>=(sizeof(BTEL.incoming)-2))
 80011cc:	b293      	uxth	r3, r2
 80011ce:	21ff      	movs	r1, #255	; 0xff
 80011d0:	0049      	lsls	r1, r1, #1
 80011d2:	428b      	cmp	r3, r1
 80011d4:	d2da      	bcs.n	800118c <BTEL_Incoming+0xc>
    if((BTEL.in_start==0)&&(c=='*')) { // we captured a start '*'
 80011d6:	4c0c      	ldr	r4, [pc, #48]	; (8001208 <BTEL_Incoming+0x88>)
 80011d8:	2185      	movs	r1, #133	; 0x85
 80011da:	0089      	lsls	r1, r1, #2
 80011dc:	5c61      	ldrb	r1, [r4, r1]
 80011de:	2900      	cmp	r1, #0
 80011e0:	d101      	bne.n	80011e6 <BTEL_Incoming+0x66>
 80011e2:	282a      	cmp	r0, #42	; 0x2a
 80011e4:	d0d3      	beq.n	800118e <BTEL_Incoming+0xe>
    if(BTEL.in_start) { // if multichar reception
 80011e6:	2900      	cmp	r1, #0
 80011e8:	d0dc      	beq.n	80011a4 <BTEL_Incoming+0x24>
      if(c!='*') {
 80011ea:	282a      	cmp	r0, #42	; 0x2a
 80011ec:	d1d4      	bne.n	8001198 <BTEL_Incoming+0x18>
      BTEL.incoming[BTEL.in_ndx++] = 0; // Null terminated string formatting
 80011ee:	4906      	ldr	r1, [pc, #24]	; (8001208 <BTEL_Incoming+0x88>)
 80011f0:	3301      	adds	r3, #1
 80011f2:	2084      	movs	r0, #132	; 0x84
 80011f4:	0080      	lsls	r0, r0, #2
 80011f6:	520b      	strh	r3, [r1, r0]
 80011f8:	188a      	adds	r2, r1, r2
 80011fa:	2300      	movs	r3, #0
 80011fc:	7413      	strb	r3, [r2, #16]
      BTEL.in_stop = 1; // full frame received
 80011fe:	4b05      	ldr	r3, [pc, #20]	; (8001214 <BTEL_Incoming+0x94>)
 8001200:	2201      	movs	r2, #1
 8001202:	54ca      	strb	r2, [r1, r3]
 8001204:	e7ce      	b.n	80011a4 <BTEL_Incoming+0x24>
 8001206:	46c0      	nop			; (mov r8, r8)
 8001208:	20000354 	.word	0x20000354
 800120c:	20002148 	.word	0x20002148
 8001210:	20002180 	.word	0x20002180
 8001214:	00000215 	.word	0x00000215

08001218 <BTEL_Polling>:
void BTEL_Polling(void) {
 8001218:	b510      	push	{r4, lr}
  BTEL_Incoming();
 800121a:	f7ff ffb1 	bl	8001180 <BTEL_Incoming>
}
 800121e:	bd10      	pop	{r4, pc}

08001220 <StringToFrac>:
void BTEL_50msec(void) {
}



int32_t StringToFrac(char s[], int32_t* pVal) { // tested ok
 8001220:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001222:	46c6      	mov	lr, r8
 8001224:	b500      	push	{lr}
 8001226:	0006      	movs	r6, r0
 8001228:	468c      	mov	ip, r1
  
  res = 0;
  sign = 0;
  startpos = -1;
  dotpos = -1;
  frac = 0;
 800122a:	2000      	movs	r0, #0
  startpos = -1;
 800122c:	2501      	movs	r5, #1
 800122e:	426d      	negs	r5, r5
  res = 0;
 8001230:	2300      	movs	r3, #0
 8001232:	4698      	mov	r8, r3
  dotpos = -1;
 8001234:	002f      	movs	r7, r5
  sign = 0;
 8001236:	2100      	movs	r1, #0
  for(pos = 0; (c=s[pos])!=0; pos++) { // browse the string until 256 char or null char
 8001238:	2200      	movs	r2, #0
 800123a:	e02a      	b.n	8001292 <StringToFrac+0x72>
    
    if(pos>=256) return -1;
    
    switch(c) {
 800123c:	2400      	movs	r4, #0
 800123e:	e023      	b.n	8001288 <StringToFrac+0x68>
 8001240:	001c      	movs	r4, r3
 8001242:	3c30      	subs	r4, #48	; 0x30
 8001244:	b2e4      	uxtb	r4, r4
 8001246:	2c09      	cmp	r4, #9
 8001248:	d81d      	bhi.n	8001286 <StringToFrac+0x66>
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
 	digit = c - '0';
 800124a:	3b30      	subs	r3, #48	; 0x30
	res = (10*res) + digit;
 800124c:	4644      	mov	r4, r8
 800124e:	00a4      	lsls	r4, r4, #2
 8001250:	4444      	add	r4, r8
 8001252:	0064      	lsls	r4, r4, #1
 8001254:	46a0      	mov	r8, r4
 8001256:	4498      	add	r8, r3
        if(startpos < 0) {
 8001258:	2d00      	cmp	r5, #0
 800125a:	db08      	blt.n	800126e <StringToFrac+0x4e>
          startpos = pos;
          if(sign==0)
            sign = +1;
        }
        if(dotpos>=0)
 800125c:	2f00      	cmp	r7, #0
 800125e:	db17      	blt.n	8001290 <StringToFrac+0x70>
          frac++; // a digit past comma
 8001260:	3001      	adds	r0, #1
        continue;
 8001262:	e015      	b.n	8001290 <StringToFrac+0x70>
      if(startpos >= 0) return -1; // error
 8001264:	2d00      	cmp	r5, #0
 8001266:	da36      	bge.n	80012d6 <StringToFrac+0xb6>
      startpos = pos;
 8001268:	0015      	movs	r5, r2
      sign = +1;
 800126a:	2101      	movs	r1, #1
 800126c:	e010      	b.n	8001290 <StringToFrac+0x70>
          if(sign==0)
 800126e:	2900      	cmp	r1, #0
 8001270:	d001      	beq.n	8001276 <StringToFrac+0x56>
          startpos = pos;
 8001272:	0015      	movs	r5, r2
 8001274:	e7f2      	b.n	800125c <StringToFrac+0x3c>
 8001276:	0015      	movs	r5, r2
            sign = +1;
 8001278:	2101      	movs	r1, #1
 800127a:	e7ef      	b.n	800125c <StringToFrac+0x3c>
    case '.':
      if(dotpos>=0) TrapError(); //return -1
 800127c:	2f00      	cmp	r7, #0
 800127e:	da01      	bge.n	8001284 <StringToFrac+0x64>
      dotpos = pos;
 8001280:	0017      	movs	r7, r2
 8001282:	e001      	b.n	8001288 <StringToFrac+0x68>
      if(dotpos>=0) TrapError(); //return -1
 8001284:	e7fe      	b.n	8001284 <StringToFrac+0x64>
    switch(c) {
 8001286:	2400      	movs	r4, #0
    default:
      c = 0;
      break;
    }
    
    if(startpos < 0) continue; // conversion hasn't started yet
 8001288:	2d00      	cmp	r5, #0
 800128a:	db01      	blt.n	8001290 <StringToFrac+0x70>
    if(c == 0) // conversion started and invalid char found: stop convert
 800128c:	2c00      	cmp	r4, #0
 800128e:	d012      	beq.n	80012b6 <StringToFrac+0x96>
  for(pos = 0; (c=s[pos])!=0; pos++) { // browse the string until 256 char or null char
 8001290:	3201      	adds	r2, #1
 8001292:	5cb3      	ldrb	r3, [r6, r2]
 8001294:	1e1c      	subs	r4, r3, #0
 8001296:	d00e      	beq.n	80012b6 <StringToFrac+0x96>
    if(pos>=256) return -1;
 8001298:	2aff      	cmp	r2, #255	; 0xff
 800129a:	dc16      	bgt.n	80012ca <StringToFrac+0xaa>
    switch(c) {
 800129c:	2b2e      	cmp	r3, #46	; 0x2e
 800129e:	d0ed      	beq.n	800127c <StringToFrac+0x5c>
 80012a0:	d8ce      	bhi.n	8001240 <StringToFrac+0x20>
 80012a2:	2b2b      	cmp	r3, #43	; 0x2b
 80012a4:	d0de      	beq.n	8001264 <StringToFrac+0x44>
 80012a6:	2b2d      	cmp	r3, #45	; 0x2d
 80012a8:	d1c8      	bne.n	800123c <StringToFrac+0x1c>
      if(startpos >= 0) return -1; // error
 80012aa:	2d00      	cmp	r5, #0
 80012ac:	da10      	bge.n	80012d0 <StringToFrac+0xb0>
      startpos = pos;
 80012ae:	0015      	movs	r5, r2
      sign = -1;
 80012b0:	2101      	movs	r1, #1
 80012b2:	4249      	negs	r1, r1
 80012b4:	e7ec      	b.n	8001290 <StringToFrac+0x70>
      break; // stop on-going conversion
  }
  
  if(startpos<0) // failed conversion
 80012b6:	2d00      	cmp	r5, #0
 80012b8:	db10      	blt.n	80012dc <StringToFrac+0xbc>
    return -1;
  
  // integer sign and dot
  res *= sign;
 80012ba:	4643      	mov	r3, r8
 80012bc:	434b      	muls	r3, r1
 80012be:	0019      	movs	r1, r3
  *pVal = res;
 80012c0:	4663      	mov	r3, ip
 80012c2:	6019      	str	r1, [r3, #0]

  return frac; // no error
    
}
 80012c4:	bc80      	pop	{r7}
 80012c6:	46b8      	mov	r8, r7
 80012c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if(pos>=256) return -1;
 80012ca:	2001      	movs	r0, #1
 80012cc:	4240      	negs	r0, r0
 80012ce:	e7f9      	b.n	80012c4 <StringToFrac+0xa4>
      if(startpos >= 0) return -1; // error
 80012d0:	2001      	movs	r0, #1
 80012d2:	4240      	negs	r0, r0
 80012d4:	e7f6      	b.n	80012c4 <StringToFrac+0xa4>
      if(startpos >= 0) return -1; // error
 80012d6:	2001      	movs	r0, #1
 80012d8:	4240      	negs	r0, r0
 80012da:	e7f3      	b.n	80012c4 <StringToFrac+0xa4>
    return -1;
 80012dc:	2001      	movs	r0, #1
 80012de:	4240      	negs	r0, r0
 80012e0:	e7f0      	b.n	80012c4 <StringToFrac+0xa4>

080012e2 <BTEL_putint_to_RAM>:
NOPs(1);
}
  
void BTEL_putint_to_RAM(u8fifo_t* pL, uint32_t i);
void BTEL_putint_to_RAM(u8fifo_t* pL, uint32_t i)
{
 80012e2:	b510      	push	{r4, lr}
 80012e4:	0004      	movs	r4, r0
 80012e6:	0008      	movs	r0, r1
	i= '0' + (i%10);	// get only the digit '0' + (byte modulo 10)
 80012e8:	210a      	movs	r1, #10
 80012ea:	f7fe ff93 	bl	8000214 <__aeabi_uidivmod>
 80012ee:	3130      	adds	r1, #48	; 0x30
	AddTou8fifo(pL, i);
 80012f0:	0020      	movs	r0, r4
 80012f2:	f002 f890 	bl	8003416 <AddTou8fifo>
}/* end putint() */
 80012f6:	bd10      	pop	{r4, pc}

080012f8 <BTEL_Printf>:



void BTEL_Printf(u8fifo_t* pL, const char *str,...)
{
 80012f8:	b40e      	push	{r1, r2, r3}
 80012fa:	b5f0      	push	{r4, r5, r6, r7, lr}
 80012fc:	46c6      	mov	lr, r8
 80012fe:	b500      	push	{lr}
 8001300:	b083      	sub	sp, #12
 8001302:	0005      	movs	r5, r0
 8001304:	9c09      	ldr	r4, [sp, #36]	; 0x24
  uint32_t arg, arg1;
  int k;	
  uint32_t pow;
  va_list ap;
// u8  count_char =0;
  if(BTEL.Enabled==0) return;
 8001306:	4bb6      	ldr	r3, [pc, #728]	; (80015e0 <BTEL_Printf+0x2e8>)
 8001308:	781b      	ldrb	r3, [r3, #0]
 800130a:	2b00      	cmp	r3, #0
 800130c:	d106      	bne.n	800131c <BTEL_Printf+0x24>
   /* Write the USB serial buffer if USB is used */
//   Virtual_Com_Write_Buffer(&serial_usb_buffer_in[0], count_char);

   va_end(ap); 
	
}/* end SERIAL_Printf() */
 800130e:	b003      	add	sp, #12
 8001310:	bc80      	pop	{r7}
 8001312:	46b8      	mov	r8, r7
 8001314:	bcf0      	pop	{r4, r5, r6, r7}
 8001316:	bc08      	pop	{r3}
 8001318:	b003      	add	sp, #12
 800131a:	4718      	bx	r3
  va_start(ap, str);
 800131c:	ab0a      	add	r3, sp, #40	; 0x28
 800131e:	9301      	str	r3, [sp, #4]
  while (*str) 
 8001320:	e027      	b.n	8001372 <BTEL_Printf+0x7a>
      AddTou8fifo(pL, *str);
 8001322:	0028      	movs	r0, r5
 8001324:	f002 f877 	bl	8003416 <AddTou8fifo>
 8001328:	0026      	movs	r6, r4
 800132a:	e021      	b.n	8001370 <BTEL_Printf+0x78>
      AddTou8fifo(pL, *str);
 800132c:	0028      	movs	r0, r5
 800132e:	f002 f872 	bl	8003416 <AddTou8fifo>
 8001332:	0026      	movs	r6, r4
 8001334:	e01c      	b.n	8001370 <BTEL_Printf+0x78>
      str++;
 8001336:	1c66      	adds	r6, r4, #1
      if (*str == 'n')
 8001338:	7863      	ldrb	r3, [r4, #1]
 800133a:	2b6e      	cmp	r3, #110	; 0x6e
 800133c:	d00a      	beq.n	8001354 <BTEL_Printf+0x5c>
      if(*str == 't')
 800133e:	2b74      	cmp	r3, #116	; 0x74
 8001340:	d00d      	beq.n	800135e <BTEL_Printf+0x66>
        AddTou8fifo(pL, 92); // backslash (\)
 8001342:	215c      	movs	r1, #92	; 0x5c
 8001344:	0028      	movs	r0, r5
 8001346:	f002 f866 	bl	8003416 <AddTou8fifo>
        AddTou8fifo(pL, *str);
 800134a:	7861      	ldrb	r1, [r4, #1]
 800134c:	0028      	movs	r0, r5
 800134e:	f002 f862 	bl	8003416 <AddTou8fifo>
 8001352:	e00d      	b.n	8001370 <BTEL_Printf+0x78>
        AddTou8fifo(pL, 0x0A);
 8001354:	3952      	subs	r1, #82	; 0x52
 8001356:	0028      	movs	r0, r5
 8001358:	f002 f85d 	bl	8003416 <AddTou8fifo>
 800135c:	e008      	b.n	8001370 <BTEL_Printf+0x78>
        AddTou8fifo(pL, 0x0D); // tochange
 800135e:	210d      	movs	r1, #13
 8001360:	0028      	movs	r0, r5
 8001362:	f002 f858 	bl	8003416 <AddTou8fifo>
 8001366:	e003      	b.n	8001370 <BTEL_Printf+0x78>
        AddTou8fifo(pL, *str);           
 8001368:	0028      	movs	r0, r5
 800136a:	f002 f854 	bl	8003416 <AddTou8fifo>
 800136e:	0026      	movs	r6, r4
    str++;   
 8001370:	1c74      	adds	r4, r6, #1
  while (*str) 
 8001372:	7821      	ldrb	r1, [r4, #0]
 8001374:	2900      	cmp	r1, #0
 8001376:	d0ca      	beq.n	800130e <BTEL_Printf+0x16>
    if(*str==0x0A)
 8001378:	290a      	cmp	r1, #10
 800137a:	d0d2      	beq.n	8001322 <BTEL_Printf+0x2a>
    if(*str==0x09)
 800137c:	2909      	cmp	r1, #9
 800137e:	d0d5      	beq.n	800132c <BTEL_Printf+0x34>
    if (*str == 92)    // backslash (\)
 8001380:	295c      	cmp	r1, #92	; 0x5c
 8001382:	d0d8      	beq.n	8001336 <BTEL_Printf+0x3e>
     if (*str != '%')
 8001384:	2925      	cmp	r1, #37	; 0x25
 8001386:	d1ef      	bne.n	8001368 <BTEL_Printf+0x70>
        str++;  
 8001388:	1c66      	adds	r6, r4, #1
        switch (*str)
 800138a:	7863      	ldrb	r3, [r4, #1]
 800138c:	2b25      	cmp	r3, #37	; 0x25
 800138e:	d00c      	beq.n	80013aa <BTEL_Printf+0xb2>
 8001390:	d3ee      	bcc.n	8001370 <BTEL_Printf+0x78>
 8001392:	2b78      	cmp	r3, #120	; 0x78
 8001394:	d8ec      	bhi.n	8001370 <BTEL_Printf+0x78>
 8001396:	2b32      	cmp	r3, #50	; 0x32
 8001398:	d3ea      	bcc.n	8001370 <BTEL_Printf+0x78>
 800139a:	3b32      	subs	r3, #50	; 0x32
 800139c:	b2da      	uxtb	r2, r3
 800139e:	2a46      	cmp	r2, #70	; 0x46
 80013a0:	d8e6      	bhi.n	8001370 <BTEL_Printf+0x78>
 80013a2:	0093      	lsls	r3, r2, #2
 80013a4:	4a8f      	ldr	r2, [pc, #572]	; (80015e4 <BTEL_Printf+0x2ec>)
 80013a6:	58d3      	ldr	r3, [r2, r3]
 80013a8:	469f      	mov	pc, r3
                  AddTou8fifo(pL, '%');
 80013aa:	2125      	movs	r1, #37	; 0x25
 80013ac:	0028      	movs	r0, r5
 80013ae:	f002 f832 	bl	8003416 <AddTou8fifo>
                  break; // '%%' = '%' !
 80013b2:	e7dd      	b.n	8001370 <BTEL_Printf+0x78>
              arg = va_arg(ap, uint32_t);
 80013b4:	9b01      	ldr	r3, [sp, #4]
 80013b6:	1d1a      	adds	r2, r3, #4
 80013b8:	9201      	str	r2, [sp, #4]
 80013ba:	681f      	ldr	r7, [r3, #0]
              if (arg & 0x80000000) /* negative */
 80013bc:	2f00      	cmp	r7, #0
 80013be:	db18      	blt.n	80013f2 <BTEL_Printf+0xfa>
{
 80013c0:	2301      	movs	r3, #1
              while ((uint32_t)(arg/(pow*10)))
 80013c2:	001c      	movs	r4, r3
 80013c4:	009a      	lsls	r2, r3, #2
 80013c6:	18d3      	adds	r3, r2, r3
 80013c8:	005b      	lsls	r3, r3, #1
 80013ca:	42bb      	cmp	r3, r7
 80013cc:	d9f9      	bls.n	80013c2 <BTEL_Printf+0xca>
                 BTEL_putint_to_RAM(pL, arg/pow);
 80013ce:	0021      	movs	r1, r4
 80013d0:	0038      	movs	r0, r7
 80013d2:	f7fe fe99 	bl	8000108 <__udivsi3>
 80013d6:	0001      	movs	r1, r0
 80013d8:	0028      	movs	r0, r5
 80013da:	f7ff ff82 	bl	80012e2 <BTEL_putint_to_RAM>
                 pow/=10;
 80013de:	46a0      	mov	r8, r4
 80013e0:	210a      	movs	r1, #10
 80013e2:	0020      	movs	r0, r4
 80013e4:	f7fe fe90 	bl	8000108 <__udivsi3>
 80013e8:	0004      	movs	r4, r0
              } while (pow >= 1);  
 80013ea:	4643      	mov	r3, r8
 80013ec:	2b09      	cmp	r3, #9
 80013ee:	d8ee      	bhi.n	80013ce <BTEL_Printf+0xd6>
 80013f0:	e7be      	b.n	8001370 <BTEL_Printf+0x78>
                 AddTou8fifo(pL, '-');
 80013f2:	212d      	movs	r1, #45	; 0x2d
 80013f4:	0028      	movs	r0, r5
 80013f6:	f002 f80e 	bl	8003416 <AddTou8fifo>
                 arg = (uint32_t) (- ((int32_t) arg));
 80013fa:	427f      	negs	r7, r7
 80013fc:	e7e0      	b.n	80013c0 <BTEL_Printf+0xc8>
              arg = va_arg(ap, uint32_t);
 80013fe:	9b01      	ldr	r3, [sp, #4]
 8001400:	1d1a      	adds	r2, r3, #4
 8001402:	9201      	str	r2, [sp, #4]
 8001404:	681f      	ldr	r7, [r3, #0]
              if (arg & 0x80000000) /* negative */
 8001406:	2f00      	cmp	r7, #0
 8001408:	db0a      	blt.n	8001420 <BTEL_Printf+0x128>
{
 800140a:	2301      	movs	r3, #1
               while ((uint32_t)(arg/(pow*10)))
 800140c:	001c      	movs	r4, r3
 800140e:	009a      	lsls	r2, r3, #2
 8001410:	18d3      	adds	r3, r2, r3
 8001412:	005b      	lsls	r3, r3, #1
 8001414:	42bb      	cmp	r3, r7
 8001416:	d9f9      	bls.n	800140c <BTEL_Printf+0x114>
              pow = max2(10,pow);
 8001418:	2c0a      	cmp	r4, #10
 800141a:	d20e      	bcs.n	800143a <BTEL_Printf+0x142>
 800141c:	240a      	movs	r4, #10
 800141e:	e00c      	b.n	800143a <BTEL_Printf+0x142>
                 AddTou8fifo(pL, '-');
 8001420:	212d      	movs	r1, #45	; 0x2d
 8001422:	0028      	movs	r0, r5
 8001424:	f001 fff7 	bl	8003416 <AddTou8fifo>
                 arg = (uint32_t) (- ((int32_t) arg));
 8001428:	427f      	negs	r7, r7
 800142a:	e7ee      	b.n	800140a <BTEL_Printf+0x112>
                 pow/=10;
 800142c:	210a      	movs	r1, #10
 800142e:	0020      	movs	r0, r4
 8001430:	f7fe fe6a 	bl	8000108 <__udivsi3>
              } while (pow >= 1);  
 8001434:	2c09      	cmp	r4, #9
 8001436:	d99b      	bls.n	8001370 <BTEL_Printf+0x78>
                 pow/=10;
 8001438:	0004      	movs	r4, r0
                 BTEL_putint_to_RAM(pL, arg/pow);
 800143a:	0021      	movs	r1, r4
 800143c:	0038      	movs	r0, r7
 800143e:	f7fe fe63 	bl	8000108 <__udivsi3>
 8001442:	0001      	movs	r1, r0
 8001444:	0028      	movs	r0, r5
 8001446:	f7ff ff4c 	bl	80012e2 <BTEL_putint_to_RAM>
                 if(pow==10)
 800144a:	2c0a      	cmp	r4, #10
 800144c:	d1ee      	bne.n	800142c <BTEL_Printf+0x134>
                   AddTou8fifo(pL, '.');
 800144e:	212e      	movs	r1, #46	; 0x2e
 8001450:	0028      	movs	r0, r5
 8001452:	f001 ffe0 	bl	8003416 <AddTou8fifo>
 8001456:	e7e9      	b.n	800142c <BTEL_Printf+0x134>
              arg = va_arg(ap, uint32_t);
 8001458:	9b01      	ldr	r3, [sp, #4]
 800145a:	1d1a      	adds	r2, r3, #4
 800145c:	9201      	str	r2, [sp, #4]
 800145e:	681f      	ldr	r7, [r3, #0]
              if (arg & 0x80000000) /* negative */
 8001460:	2f00      	cmp	r7, #0
 8001462:	db0a      	blt.n	800147a <BTEL_Printf+0x182>
                 pow/=10;
 8001464:	2301      	movs	r3, #1
              while ((uint32_t)(arg/(pow*10)))
 8001466:	001c      	movs	r4, r3
 8001468:	009a      	lsls	r2, r3, #2
 800146a:	18d3      	adds	r3, r2, r3
 800146c:	005b      	lsls	r3, r3, #1
 800146e:	42bb      	cmp	r3, r7
 8001470:	d9f9      	bls.n	8001466 <BTEL_Printf+0x16e>
              pow = max2(100,pow);
 8001472:	2c64      	cmp	r4, #100	; 0x64
 8001474:	d20f      	bcs.n	8001496 <BTEL_Printf+0x19e>
 8001476:	2464      	movs	r4, #100	; 0x64
 8001478:	e00d      	b.n	8001496 <BTEL_Printf+0x19e>
                AddTou8fifo(pL, '-');
 800147a:	212d      	movs	r1, #45	; 0x2d
 800147c:	0028      	movs	r0, r5
 800147e:	f001 ffca 	bl	8003416 <AddTou8fifo>
                arg = (uint32_t) (- ((int32_t) arg));
 8001482:	427f      	negs	r7, r7
 8001484:	e7ee      	b.n	8001464 <BTEL_Printf+0x16c>
                pow/=10;
 8001486:	210a      	movs	r1, #10
 8001488:	0020      	movs	r0, r4
 800148a:	f7fe fe3d 	bl	8000108 <__udivsi3>
              } while (pow >= 1);  
 800148e:	2c09      	cmp	r4, #9
 8001490:	d800      	bhi.n	8001494 <BTEL_Printf+0x19c>
 8001492:	e76d      	b.n	8001370 <BTEL_Printf+0x78>
                pow/=10;
 8001494:	0004      	movs	r4, r0
                BTEL_putint_to_RAM(pL, arg/pow);
 8001496:	0021      	movs	r1, r4
 8001498:	0038      	movs	r0, r7
 800149a:	f7fe fe35 	bl	8000108 <__udivsi3>
 800149e:	0001      	movs	r1, r0
 80014a0:	0028      	movs	r0, r5
 80014a2:	f7ff ff1e 	bl	80012e2 <BTEL_putint_to_RAM>
                if(pow==100)
 80014a6:	2c64      	cmp	r4, #100	; 0x64
 80014a8:	d1ed      	bne.n	8001486 <BTEL_Printf+0x18e>
                  AddTou8fifo(pL, '.');
 80014aa:	212e      	movs	r1, #46	; 0x2e
 80014ac:	0028      	movs	r0, r5
 80014ae:	f001 ffb2 	bl	8003416 <AddTou8fifo>
 80014b2:	e7e8      	b.n	8001486 <BTEL_Printf+0x18e>
               arg = va_arg(ap, uint32_t);
 80014b4:	9b01      	ldr	r3, [sp, #4]
 80014b6:	1d1a      	adds	r2, r3, #4
 80014b8:	9201      	str	r2, [sp, #4]
 80014ba:	681f      	ldr	r7, [r3, #0]
               if (arg & 0x80000000) /* negative */
 80014bc:	2f00      	cmp	r7, #0
 80014be:	db0c      	blt.n	80014da <BTEL_Printf+0x1e2>
                pow/=10;
 80014c0:	2301      	movs	r3, #1
               while ((uint32_t)(arg/(pow*10)))
 80014c2:	001c      	movs	r4, r3
 80014c4:	009a      	lsls	r2, r3, #2
 80014c6:	18d3      	adds	r3, r2, r3
 80014c8:	005b      	lsls	r3, r3, #1
 80014ca:	42bb      	cmp	r3, r7
 80014cc:	d9f9      	bls.n	80014c2 <BTEL_Printf+0x1ca>
               pow = max2(1000,pow);
 80014ce:	23fa      	movs	r3, #250	; 0xfa
 80014d0:	009b      	lsls	r3, r3, #2
 80014d2:	429c      	cmp	r4, r3
 80014d4:	d20f      	bcs.n	80014f6 <BTEL_Printf+0x1fe>
 80014d6:	001c      	movs	r4, r3
 80014d8:	e00d      	b.n	80014f6 <BTEL_Printf+0x1fe>
                  AddTou8fifo(pL, '-');
 80014da:	212d      	movs	r1, #45	; 0x2d
 80014dc:	0028      	movs	r0, r5
 80014de:	f001 ff9a 	bl	8003416 <AddTou8fifo>
                  arg = (uint32_t) (- ((int32_t) arg));
 80014e2:	427f      	negs	r7, r7
 80014e4:	e7ec      	b.n	80014c0 <BTEL_Printf+0x1c8>
                  pow/=10;
 80014e6:	210a      	movs	r1, #10
 80014e8:	0020      	movs	r0, r4
 80014ea:	f7fe fe0d 	bl	8000108 <__udivsi3>
               } while (pow >= 1);  
 80014ee:	2c09      	cmp	r4, #9
 80014f0:	d800      	bhi.n	80014f4 <BTEL_Printf+0x1fc>
 80014f2:	e73d      	b.n	8001370 <BTEL_Printf+0x78>
                  pow/=10;
 80014f4:	0004      	movs	r4, r0
                  BTEL_putint_to_RAM(pL, arg/pow);
 80014f6:	0021      	movs	r1, r4
 80014f8:	0038      	movs	r0, r7
 80014fa:	f7fe fe05 	bl	8000108 <__udivsi3>
 80014fe:	0001      	movs	r1, r0
 8001500:	0028      	movs	r0, r5
 8001502:	f7ff feee 	bl	80012e2 <BTEL_putint_to_RAM>
                  if(pow==1000)
 8001506:	23fa      	movs	r3, #250	; 0xfa
 8001508:	009b      	lsls	r3, r3, #2
 800150a:	429c      	cmp	r4, r3
 800150c:	d1eb      	bne.n	80014e6 <BTEL_Printf+0x1ee>
                    AddTou8fifo(pL, '.');
 800150e:	212e      	movs	r1, #46	; 0x2e
 8001510:	0028      	movs	r0, r5
 8001512:	f001 ff80 	bl	8003416 <AddTou8fifo>
 8001516:	e7e6      	b.n	80014e6 <BTEL_Printf+0x1ee>
              arg = va_arg(ap, uint32_t);				 
 8001518:	9b01      	ldr	r3, [sp, #4]
 800151a:	1d1a      	adds	r2, r3, #4
 800151c:	9201      	str	r2, [sp, #4]
 800151e:	6819      	ldr	r1, [r3, #0]
              AddTou8fifo(pL, arg);
 8001520:	0028      	movs	r0, r5
 8001522:	f001 ff78 	bl	8003416 <AddTou8fifo>
           break;
 8001526:	e723      	b.n	8001370 <BTEL_Printf+0x78>
              arg = va_arg(ap, uint32_t);
 8001528:	9b01      	ldr	r3, [sp, #4]
 800152a:	1d1a      	adds	r2, r3, #4
 800152c:	9201      	str	r2, [sp, #4]
 800152e:	681c      	ldr	r4, [r3, #0]
              arg1 = ((arg >> 4) & 0x0000000F);
 8001530:	0923      	lsrs	r3, r4, #4
 8001532:	210f      	movs	r1, #15
 8001534:	4019      	ands	r1, r3
              if (arg1 < 10)
 8001536:	2909      	cmp	r1, #9
 8001538:	d80a      	bhi.n	8001550 <BTEL_Printf+0x258>
                BTEL_putint_to_RAM(pL, arg1);
 800153a:	0028      	movs	r0, r5
 800153c:	f7ff fed1 	bl	80012e2 <BTEL_putint_to_RAM>
              arg1 = (arg & 0x0000000F);
 8001540:	210f      	movs	r1, #15
 8001542:	4021      	ands	r1, r4
              if (arg1 < 10)
 8001544:	2909      	cmp	r1, #9
 8001546:	d808      	bhi.n	800155a <BTEL_Printf+0x262>
                BTEL_putint_to_RAM(pL, arg1);
 8001548:	0028      	movs	r0, r5
 800154a:	f7ff feca 	bl	80012e2 <BTEL_putint_to_RAM>
 800154e:	e70f      	b.n	8001370 <BTEL_Printf+0x78>
                AddTou8fifo(pL, arg1 - 10 + 65 );
 8001550:	3137      	adds	r1, #55	; 0x37
 8001552:	0028      	movs	r0, r5
 8001554:	f001 ff5f 	bl	8003416 <AddTou8fifo>
 8001558:	e7f2      	b.n	8001540 <BTEL_Printf+0x248>
                AddTou8fifo(pL, arg1 - 10 + 65 );
 800155a:	3137      	adds	r1, #55	; 0x37
 800155c:	0028      	movs	r0, r5
 800155e:	f001 ff5a 	bl	8003416 <AddTou8fifo>
 8001562:	e705      	b.n	8001370 <BTEL_Printf+0x78>
              str++;
 8001564:	1ca6      	adds	r6, r4, #2
              if ((*str == 'x') || (*str == 'X'))
 8001566:	78a3      	ldrb	r3, [r4, #2]
 8001568:	2b78      	cmp	r3, #120	; 0x78
 800156a:	d002      	beq.n	8001572 <BTEL_Printf+0x27a>
 800156c:	2b58      	cmp	r3, #88	; 0x58
 800156e:	d000      	beq.n	8001572 <BTEL_Printf+0x27a>
 8001570:	e6fe      	b.n	8001370 <BTEL_Printf+0x78>
                arg = va_arg(ap, uint32_t);					 
 8001572:	9b01      	ldr	r3, [sp, #4]
 8001574:	1d1a      	adds	r2, r3, #4
 8001576:	9201      	str	r2, [sp, #4]
 8001578:	681f      	ldr	r7, [r3, #0]
		for (k=12; k>=0 ;k-=4)
 800157a:	240c      	movs	r4, #12
 800157c:	e004      	b.n	8001588 <BTEL_Printf+0x290>
                      AddTou8fifo(pL, arg1 - 10 + 65 );
 800157e:	3137      	adds	r1, #55	; 0x37
 8001580:	0028      	movs	r0, r5
 8001582:	f001 ff48 	bl	8003416 <AddTou8fifo>
		for (k=12; k>=0 ;k-=4)
 8001586:	3c04      	subs	r4, #4
 8001588:	2c00      	cmp	r4, #0
 800158a:	da00      	bge.n	800158e <BTEL_Printf+0x296>
 800158c:	e6f0      	b.n	8001370 <BTEL_Printf+0x78>
                  arg1 = ((arg >> k) & 0x0000000F);
 800158e:	003b      	movs	r3, r7
 8001590:	40e3      	lsrs	r3, r4
 8001592:	210f      	movs	r1, #15
 8001594:	4019      	ands	r1, r3
                  if (arg1 < 10)
 8001596:	2909      	cmp	r1, #9
 8001598:	d8f1      	bhi.n	800157e <BTEL_Printf+0x286>
                      BTEL_putint_to_RAM(pL, arg1);
 800159a:	0028      	movs	r0, r5
 800159c:	f7ff fea1 	bl	80012e2 <BTEL_putint_to_RAM>
 80015a0:	e7f1      	b.n	8001586 <BTEL_Printf+0x28e>
              str++;
 80015a2:	1ca6      	adds	r6, r4, #2
              if ((*str == 'x') || (*str == 'X'))
 80015a4:	78a3      	ldrb	r3, [r4, #2]
 80015a6:	2b78      	cmp	r3, #120	; 0x78
 80015a8:	d002      	beq.n	80015b0 <BTEL_Printf+0x2b8>
 80015aa:	2b58      	cmp	r3, #88	; 0x58
 80015ac:	d000      	beq.n	80015b0 <BTEL_Printf+0x2b8>
 80015ae:	e6df      	b.n	8001370 <BTEL_Printf+0x78>
                arg = va_arg(ap, uint32_t); // u32 original
 80015b0:	9b01      	ldr	r3, [sp, #4]
 80015b2:	1d1a      	adds	r2, r3, #4
 80015b4:	9201      	str	r2, [sp, #4]
 80015b6:	681f      	ldr	r7, [r3, #0]
                for (k=28; k>=0 ;k-=4)
 80015b8:	241c      	movs	r4, #28
 80015ba:	e004      	b.n	80015c6 <BTEL_Printf+0x2ce>
			AddTou8fifo(pL, arg1 - 10 + 65 );
 80015bc:	3137      	adds	r1, #55	; 0x37
 80015be:	0028      	movs	r0, r5
 80015c0:	f001 ff29 	bl	8003416 <AddTou8fifo>
                for (k=28; k>=0 ;k-=4)
 80015c4:	3c04      	subs	r4, #4
 80015c6:	2c00      	cmp	r4, #0
 80015c8:	da00      	bge.n	80015cc <BTEL_Printf+0x2d4>
 80015ca:	e6d1      	b.n	8001370 <BTEL_Printf+0x78>
                  arg1 = ((arg >> k) & 0x0000000F);
 80015cc:	003b      	movs	r3, r7
 80015ce:	40e3      	lsrs	r3, r4
 80015d0:	210f      	movs	r1, #15
 80015d2:	4019      	ands	r1, r3
                  if (arg1 < 10)
 80015d4:	2909      	cmp	r1, #9
 80015d6:	d8f1      	bhi.n	80015bc <BTEL_Printf+0x2c4>
                    BTEL_putint_to_RAM(pL, arg1);
 80015d8:	0028      	movs	r0, r5
 80015da:	f7ff fe82 	bl	80012e2 <BTEL_putint_to_RAM>
 80015de:	e7f1      	b.n	80015c4 <BTEL_Printf+0x2cc>
 80015e0:	20000354 	.word	0x20000354
 80015e4:	08005f68 	.word	0x08005f68

080015e8 <BTEL_SelectDevice>:
}


void BTEL_SelectDevice(void) {
  
      BTEL.DeviceSelector = 0;
 80015e8:	4b01      	ldr	r3, [pc, #4]	; (80015f0 <BTEL_SelectDevice+0x8>)
 80015ea:	2200      	movs	r2, #0
 80015ec:	705a      	strb	r2, [r3, #1]
//  BTEL.PanelSelector = 0; // go to brisk panel selector
//  BTEL_SetPanel(); // draw pannel
}
 80015ee:	4770      	bx	lr
 80015f0:	20000354 	.word	0x20000354

080015f4 <TransmitPanel>:

// we will assume these are contiguous in memory to start simple
// start from * until * or 1500 chars transmitted

int32_t TransmitPanel(u8fifo_t* pL, char* pS) {
 80015f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80015f6:	0006      	movs	r6, r0
 80015f8:	000c      	movs	r4, r1
  
  int32_t count = 0;
 80015fa:	2500      	movs	r5, #0
  char c;
  
  // search for the first *
  do {
    c = *pS++;
 80015fc:	7821      	ldrb	r1, [r4, #0]
 80015fe:	3401      	adds	r4, #1
    count++;
 8001600:	3501      	adds	r5, #1
    if(count>1500) return 1;
 8001602:	4b0f      	ldr	r3, [pc, #60]	; (8001640 <TransmitPanel+0x4c>)
 8001604:	429d      	cmp	r5, r3
 8001606:	dc16      	bgt.n	8001636 <TransmitPanel+0x42>
  }while(c!='*');
 8001608:	292a      	cmp	r1, #42	; 0x2a
 800160a:	d1f7      	bne.n	80015fc <TransmitPanel+0x8>
  
  AddTou8fifo(pL, c);
 800160c:	0030      	movs	r0, r6
 800160e:	f001 ff02 	bl	8003416 <AddTou8fifo>
  
  // send until '*' or 1023 chars
  do {
    c = *pS++;
 8001612:	1c67      	adds	r7, r4, #1
 8001614:	7821      	ldrb	r1, [r4, #0]
    count++;
 8001616:	3501      	adds	r5, #1
    if(count>1500)
 8001618:	4b09      	ldr	r3, [pc, #36]	; (8001640 <TransmitPanel+0x4c>)
 800161a:	429d      	cmp	r5, r3
 800161c:	dc06      	bgt.n	800162c <TransmitPanel+0x38>
    {
      NOPs(1);
      return 1;
    };
    if(c==0) return 0;//continue;
 800161e:	2900      	cmp	r1, #0
 8001620:	d00b      	beq.n	800163a <TransmitPanel+0x46>
    AddTou8fifo(pL, c);
 8001622:	0030      	movs	r0, r6
 8001624:	f001 fef7 	bl	8003416 <AddTou8fifo>
    c = *pS++;
 8001628:	003c      	movs	r4, r7
 800162a:	e7f2      	b.n	8001612 <TransmitPanel+0x1e>
      NOPs(1);
 800162c:	2001      	movs	r0, #1
 800162e:	f001 fe2d 	bl	800328c <NOPs>
      return 1;
 8001632:	2001      	movs	r0, #1
  }while(1);//c!='*');
    
//  return 0;
}
 8001634:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(count>1500) return 1;
 8001636:	2001      	movs	r0, #1
 8001638:	e7fc      	b.n	8001634 <TransmitPanel+0x40>
    if(c==0) return 0;//continue;
 800163a:	2000      	movs	r0, #0
 800163c:	e7fa      	b.n	8001634 <TransmitPanel+0x40>
 800163e:	46c0      	nop			; (mov r8, r8)
 8001640:	000005dc 	.word	0x000005dc

08001644 <NopsWait>:
}
//==============================================
static int32_t NopsWait(uint32_t m) { // this affect the bit rate and clock period, better way would be to use Timer or DNG Cyclecounter when available. TODO Time Calibration would improve this implementation to achieve desired baud rate.
  // run a message, check the duration vs target, adjust the SW delay using binary search algo. Once known, could be hard coded later on.
  I2C_MasterIO_t* pM = (I2C_MasterIO_t*) m;
  uint32_t n = pM->ctWaitMethod * pM->WaitParam;
 8001644:	6a02      	ldr	r2, [r0, #32]
 8001646:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001648:	4353      	muls	r3, r2
  while(n--) asm("nop\n");
 800164a:	e001      	b.n	8001650 <NopsWait+0xc>
 800164c:	46c0      	nop			; (mov r8, r8)
 800164e:	0013      	movs	r3, r2
 8001650:	1e5a      	subs	r2, r3, #1
 8001652:	2b00      	cmp	r3, #0
 8001654:	d1fa      	bne.n	800164c <NopsWait+0x8>
  return 0;
}
 8001656:	2000      	movs	r0, #0
 8001658:	4770      	bx	lr

0800165a <WaitHere>:

static uint32_t WaitHere(I2C_MasterIO_t* pM, uint32_t delay) { // here as starter, the delay function is always blocking
 800165a:	b510      	push	{r4, lr}

  pM->ctWaitMethod = delay;
 800165c:	6201      	str	r1, [r0, #32]
  if(pM->fnWaitMethod) pM->fnWaitMethod((uint32_t)pM);
 800165e:	69c3      	ldr	r3, [r0, #28]
 8001660:	2b00      	cmp	r3, #0
 8001662:	d000      	beq.n	8001666 <WaitHere+0xc>
 8001664:	4798      	blx	r3
  return 0;
}
 8001666:	2000      	movs	r0, #0
 8001668:	bd10      	pop	{r4, pc}

0800166a <GenerateStop>:

  return bValue;
}


static int32_t GenerateStop (I2C_MasterIO_t* pM) {
 800166a:	b570      	push	{r4, r5, r6, lr}
 800166c:	0004      	movs	r4, r0
  
  IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;
 800166e:	0006      	movs	r6, r0
 8001670:	3614      	adds	r6, #20
 8001672:	0030      	movs	r0, r6
 8001674:	f004 f843 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);
 8001678:	2101      	movs	r1, #1
 800167a:	0020      	movs	r0, r4
 800167c:	f7ff ffed 	bl	800165a <WaitHere>
  IO_RawPadSetLow(&pM->RawPad_SDA);//bit_I2C_SDA_LOW;
 8001680:	0025      	movs	r5, r4
 8001682:	350c      	adds	r5, #12
 8001684:	0028      	movs	r0, r5
 8001686:	f004 f83a 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);							// Extra to make sure delay is ok
 800168a:	2101      	movs	r1, #1
 800168c:	0020      	movs	r0, r4
 800168e:	f7ff ffe4 	bl	800165a <WaitHere>
  
  IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;
 8001692:	0030      	movs	r0, r6
 8001694:	f004 f82c 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);
 8001698:	2101      	movs	r1, #1
 800169a:	0020      	movs	r0, r4
 800169c:	f7ff ffdd 	bl	800165a <WaitHere>

  IO_RawPadSetHigh(&pM->RawPad_SDA);//bit_I2C_SDA_HIGH;
 80016a0:	0028      	movs	r0, r5
 80016a2:	f004 f825 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);  
 80016a6:	2101      	movs	r1, #1
 80016a8:	0020      	movs	r0, r4
 80016aa:	f7ff ffd6 	bl	800165a <WaitHere>
  return 0;
}
 80016ae:	2000      	movs	r0, #0
 80016b0:	bd70      	pop	{r4, r5, r6, pc}

080016b2 <ErrorRecovery>:
{
 80016b2:	b510      	push	{r4, lr}
 80016b4:	0004      	movs	r4, r0
  GenerateStop(pM);
 80016b6:	f7ff ffd8 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016ba:	0020      	movs	r0, r4
 80016bc:	f7ff ffd5 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016c0:	0020      	movs	r0, r4
 80016c2:	f7ff ffd2 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016c6:	0020      	movs	r0, r4
 80016c8:	f7ff ffcf 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016cc:	0020      	movs	r0, r4
 80016ce:	f7ff ffcc 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016d2:	0020      	movs	r0, r4
 80016d4:	f7ff ffc9 	bl	800166a <GenerateStop>
  GenerateStop(pM);
 80016d8:	0020      	movs	r0, r4
 80016da:	f7ff ffc6 	bl	800166a <GenerateStop>
  GenerateStop(pM);	// flush the bus if it is stuck
 80016de:	0020      	movs	r0, r4
 80016e0:	f7ff ffc3 	bl	800166a <GenerateStop>
}
 80016e4:	2000      	movs	r0, #0
 80016e6:	bd10      	pop	{r4, pc}

080016e8 <ReceiveByte>:
{ 
 80016e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80016ea:	46ce      	mov	lr, r9
 80016ec:	4647      	mov	r7, r8
 80016ee:	b580      	push	{r7, lr}
 80016f0:	0006      	movs	r6, r0
 80016f2:	4688      	mov	r8, r1
  IO_RawPadSetHigh(&pM->RawPad_SDA);//dir_I2C_SDA_IN; // make SDA as input before reading pin level
 80016f4:	0007      	movs	r7, r0
 80016f6:	370c      	adds	r7, #12
 80016f8:	0038      	movs	r0, r7
 80016fa:	f003 fff9 	bl	80056f0 <IO_RawPadSetHigh>
  for (loop = 0; loop < 8; loop ++) 
 80016fe:	2500      	movs	r5, #0
  bValue = 0;
 8001700:	2400      	movs	r4, #0
  for (loop = 0; loop < 8; loop ++) 
 8001702:	e008      	b.n	8001716 <ReceiveByte+0x2e>
      IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;	// SCL = 0
 8001704:	4648      	mov	r0, r9
 8001706:	f003 fffa 	bl	80056fe <IO_RawPadSetLow>
      WaitHere(pM,1);//1028
 800170a:	2101      	movs	r1, #1
 800170c:	0030      	movs	r0, r6
 800170e:	f7ff ffa4 	bl	800165a <WaitHere>
  for (loop = 0; loop < 8; loop ++) 
 8001712:	3501      	adds	r5, #1
 8001714:	b2ed      	uxtb	r5, r5
 8001716:	2d07      	cmp	r5, #7
 8001718:	d817      	bhi.n	800174a <ReceiveByte+0x62>
      WaitHere(pM,1);// NOP; NOP;	// 1 us delay
 800171a:	2101      	movs	r1, #1
 800171c:	0030      	movs	r0, r6
 800171e:	f7ff ff9c 	bl	800165a <WaitHere>
      IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;	// SCL = 1
 8001722:	2314      	movs	r3, #20
 8001724:	4699      	mov	r9, r3
 8001726:	44b1      	add	r9, r6
 8001728:	4648      	mov	r0, r9
 800172a:	f003 ffe1 	bl	80056f0 <IO_RawPadSetHigh>
      WaitHere(pM,2);					
 800172e:	2102      	movs	r1, #2
 8001730:	0030      	movs	r0, r6
 8001732:	f7ff ff92 	bl	800165a <WaitHere>
      bValue <<= 1;
 8001736:	0064      	lsls	r4, r4, #1
 8001738:	b2e4      	uxtb	r4, r4
      if(IO_RawPadGet(&pM->RawPad_SDA)) bValue++;
 800173a:	0038      	movs	r0, r7
 800173c:	f003 ffe6 	bl	800570c <IO_RawPadGet>
 8001740:	2800      	cmp	r0, #0
 8001742:	d0df      	beq.n	8001704 <ReceiveByte+0x1c>
 8001744:	3401      	adds	r4, #1
 8001746:	b2e4      	uxtb	r4, r4
 8001748:	e7dc      	b.n	8001704 <ReceiveByte+0x1c>
  if(DoAck) {
 800174a:	4643      	mov	r3, r8
 800174c:	2b00      	cmp	r3, #0
 800174e:	d01b      	beq.n	8001788 <ReceiveByte+0xa0>
    IO_RawPadSetLow(&pM->RawPad_SDA);//bit_I2C_SDA_LOW;
 8001750:	0038      	movs	r0, r7
 8001752:	f003 ffd4 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);	// enlarge the pulse to see it on the scope
 8001756:	2101      	movs	r1, #1
 8001758:	0030      	movs	r0, r6
 800175a:	f7ff ff7e 	bl	800165a <WaitHere>
  IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;	// SCL = 1
 800175e:	0035      	movs	r5, r6
 8001760:	3514      	adds	r5, #20
 8001762:	0028      	movs	r0, r5
 8001764:	f003 ffc4 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);
 8001768:	2101      	movs	r1, #1
 800176a:	0030      	movs	r0, r6
 800176c:	f7ff ff75 	bl	800165a <WaitHere>
  IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;	// SCL = 0
 8001770:	0028      	movs	r0, r5
 8001772:	f003 ffc4 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);//	NOP;	add sept 17
 8001776:	2101      	movs	r1, #1
 8001778:	0030      	movs	r0, r6
 800177a:	f7ff ff6e 	bl	800165a <WaitHere>
}
 800177e:	0020      	movs	r0, r4
 8001780:	bcc0      	pop	{r6, r7}
 8001782:	46b9      	mov	r9, r7
 8001784:	46b0      	mov	r8, r6
 8001786:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    IO_RawPadSetHigh(&pM->RawPad_SDA);//bit_I2C_SDA_HIGH;
 8001788:	0038      	movs	r0, r7
 800178a:	f003 ffb1 	bl	80056f0 <IO_RawPadSetHigh>
 800178e:	e7e2      	b.n	8001756 <ReceiveByte+0x6e>

08001790 <TransmitByte>:
{
 8001790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001792:	0004      	movs	r4, r0
 8001794:	000d      	movs	r5, r1
  for (loop = 0; loop < 8; loop++) 
 8001796:	2600      	movs	r6, #0
 8001798:	e01b      	b.n	80017d2 <TransmitByte+0x42>
        IO_RawPadSetLow(&pM->RawPad_SDA);//bit_I2C_SDA_LOW;
 800179a:	0020      	movs	r0, r4
 800179c:	300c      	adds	r0, #12
 800179e:	f003 ffae 	bl	80056fe <IO_RawPadSetLow>
      WaitHere(pM,1);// Sept 17
 80017a2:	2101      	movs	r1, #1
 80017a4:	0020      	movs	r0, r4
 80017a6:	f7ff ff58 	bl	800165a <WaitHere>
      IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;
 80017aa:	0027      	movs	r7, r4
 80017ac:	3714      	adds	r7, #20
 80017ae:	0038      	movs	r0, r7
 80017b0:	f003 ff9e 	bl	80056f0 <IO_RawPadSetHigh>
      WaitHere(pM,1);//1028
 80017b4:	2101      	movs	r1, #1
 80017b6:	0020      	movs	r0, r4
 80017b8:	f7ff ff4f 	bl	800165a <WaitHere>
      bValue <<= 1;
 80017bc:	006d      	lsls	r5, r5, #1
 80017be:	b2ed      	uxtb	r5, r5
      IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;
 80017c0:	0038      	movs	r0, r7
 80017c2:	f003 ff9c 	bl	80056fe <IO_RawPadSetLow>
      WaitHere(pM,1);
 80017c6:	2101      	movs	r1, #1
 80017c8:	0020      	movs	r0, r4
 80017ca:	f7ff ff46 	bl	800165a <WaitHere>
  for (loop = 0; loop < 8; loop++) 
 80017ce:	3601      	adds	r6, #1
 80017d0:	b2f6      	uxtb	r6, r6
 80017d2:	2e07      	cmp	r6, #7
 80017d4:	d807      	bhi.n	80017e6 <TransmitByte+0x56>
      if (bValue & 0x80) {
 80017d6:	b26b      	sxtb	r3, r5
 80017d8:	2b00      	cmp	r3, #0
 80017da:	dade      	bge.n	800179a <TransmitByte+0xa>
        IO_RawPadSetHigh(&pM->RawPad_SDA);//bit_I2C_SDA_HIGH;
 80017dc:	0020      	movs	r0, r4
 80017de:	300c      	adds	r0, #12
 80017e0:	f003 ff86 	bl	80056f0 <IO_RawPadSetHigh>
 80017e4:	e7dd      	b.n	80017a2 <TransmitByte+0x12>
  IO_RawPadSetHigh(&pM->RawPad_SDA);//dir_I2C_SDA_IN;
 80017e6:	0026      	movs	r6, r4
 80017e8:	360c      	adds	r6, #12
 80017ea:	0030      	movs	r0, r6
 80017ec:	f003 ff80 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);
 80017f0:	2101      	movs	r1, #1
 80017f2:	0020      	movs	r0, r4
 80017f4:	f7ff ff31 	bl	800165a <WaitHere>
  IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;	// SCL = 1
 80017f8:	0025      	movs	r5, r4
 80017fa:	3514      	adds	r5, #20
 80017fc:	0028      	movs	r0, r5
 80017fe:	f003 ff77 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);					
 8001802:	2101      	movs	r1, #1
 8001804:	0020      	movs	r0, r4
 8001806:	f7ff ff28 	bl	800165a <WaitHere>
  IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;	// SCL = 1
 800180a:	0028      	movs	r0, r5
 800180c:	f003 ff70 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,2);//	NOP;					
 8001810:	2102      	movs	r1, #2
 8001812:	0020      	movs	r0, r4
 8001814:	f7ff ff21 	bl	800165a <WaitHere>
  pM->AckFail |= IO_RawPadGet(&pM->RawPad_SDA);	// Acknowledge bit
 8001818:	0030      	movs	r0, r6
 800181a:	f003 ff77 	bl	800570c <IO_RawPadGet>
 800181e:	7aa3      	ldrb	r3, [r4, #10]
 8001820:	4303      	orrs	r3, r0
 8001822:	b2db      	uxtb	r3, r3
 8001824:	72a3      	strb	r3, [r4, #10]
  if(pM->AckFail) 
 8001826:	2b00      	cmp	r3, #0
 8001828:	d108      	bne.n	800183c <TransmitByte+0xac>
  IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;	// SCL = 0
 800182a:	0028      	movs	r0, r5
 800182c:	f003 ff67 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);// Sept 17
 8001830:	2101      	movs	r1, #1
 8001832:	0020      	movs	r0, r4
 8001834:	f7ff ff11 	bl	800165a <WaitHere>
  return pM->AckFail;
 8001838:	7aa0      	ldrb	r0, [r4, #10]
}
 800183a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    NOPs(1); // breakpoint hook
 800183c:	2001      	movs	r0, #1
 800183e:	f001 fd25 	bl	800328c <NOPs>
 8001842:	e7f2      	b.n	800182a <TransmitByte+0x9a>

08001844 <GenerateStart>:
{
 8001844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001846:	0004      	movs	r4, r0
 8001848:	000d      	movs	r5, r1
  IO_RawPadSetHigh(&pM->RawPad_SDA);//dir_I2C_SDA_IN;	// to check if I2C is idle... or stuck
 800184a:	0006      	movs	r6, r0
 800184c:	360c      	adds	r6, #12
 800184e:	0030      	movs	r0, r6
 8001850:	f003 ff4e 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);
 8001854:	2101      	movs	r1, #1
 8001856:	0020      	movs	r0, r4
 8001858:	f7ff feff 	bl	800165a <WaitHere>
  if(IO_RawPadGet(&pM->RawPad_SDA)==0) {
 800185c:	0030      	movs	r0, r6
 800185e:	f003 ff55 	bl	800570c <IO_RawPadGet>
 8001862:	2800      	cmp	r0, #0
 8001864:	d01f      	beq.n	80018a6 <GenerateStart+0x62>
  if((SlaveAdr & 0x01) == 0) // if it is a write address, we start a transaction, hence we clear ackfail.
 8001866:	07eb      	lsls	r3, r5, #31
 8001868:	d401      	bmi.n	800186e <GenerateStart+0x2a>
    pM->AckFail = 0;
 800186a:	2300      	movs	r3, #0
 800186c:	72a3      	strb	r3, [r4, #10]
  IO_RawPadSetHigh(&pM->RawPad_SCL);//bit_I2C_SCL_HIGH;
 800186e:	0027      	movs	r7, r4
 8001870:	3714      	adds	r7, #20
 8001872:	0038      	movs	r0, r7
 8001874:	f003 ff3c 	bl	80056f0 <IO_RawPadSetHigh>
  WaitHere(pM,1);					
 8001878:	2101      	movs	r1, #1
 800187a:	0020      	movs	r0, r4
 800187c:	f7ff feed 	bl	800165a <WaitHere>
  IO_RawPadSetLow(&pM->RawPad_SDA);//bit_I2C_SDA_LOW;
 8001880:	0030      	movs	r0, r6
 8001882:	f003 ff3c 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);
 8001886:	2101      	movs	r1, #1
 8001888:	0020      	movs	r0, r4
 800188a:	f7ff fee6 	bl	800165a <WaitHere>
  IO_RawPadSetLow(&pM->RawPad_SCL);//bit_I2C_SCL_LOW;
 800188e:	0038      	movs	r0, r7
 8001890:	f003 ff35 	bl	80056fe <IO_RawPadSetLow>
  WaitHere(pM,1);
 8001894:	2101      	movs	r1, #1
 8001896:	0020      	movs	r0, r4
 8001898:	f7ff fedf 	bl	800165a <WaitHere>
  return TransmitByte (pM,SlaveAdr);				// Send the slave address
 800189c:	0029      	movs	r1, r5
 800189e:	0020      	movs	r0, r4
 80018a0:	f7ff ff76 	bl	8001790 <TransmitByte>
}
 80018a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ErrorRecovery(pM);
 80018a6:	0020      	movs	r0, r4
 80018a8:	f7ff ff03 	bl	80016b2 <ErrorRecovery>
    if(IO_RawPadGet(&pM->RawPad_SDA)==0) { // to debug with hot plug if glitch could code (try twice?)
 80018ac:	0030      	movs	r0, r6
 80018ae:	f003 ff2d 	bl	800570c <IO_RawPadGet>
 80018b2:	2800      	cmp	r0, #0
 80018b4:	d1d7      	bne.n	8001866 <GenerateStart+0x22>
      MinDelay_ms(10);//HAL_Delay(10);
 80018b6:	300a      	adds	r0, #10
 80018b8:	f001 fcf8 	bl	80032ac <MinDelay_ms>
      ErrorRecovery(pM); // can't recover (or try again with delay?)
 80018bc:	0020      	movs	r0, r4
 80018be:	f7ff fef8 	bl	80016b2 <ErrorRecovery>
 80018c2:	e7d0      	b.n	8001866 <GenerateStart+0x22>

080018c4 <I2C_MasterIO_Init>:
  if(pM==NULL)
 80018c4:	2800      	cmp	r0, #0
 80018c6:	d004      	beq.n	80018d2 <I2C_MasterIO_Init+0xe>
  if(pM->SCL>=DIE_PAD_MAX)
 80018c8:	2301      	movs	r3, #1
 80018ca:	56c3      	ldrsb	r3, [r0, r3]
 80018cc:	2b5f      	cmp	r3, #95	; 0x5f
 80018ce:	dd01      	ble.n	80018d4 <I2C_MasterIO_Init+0x10>
    while(1) {};
 80018d0:	e7fe      	b.n	80018d0 <I2C_MasterIO_Init+0xc>
    while(1) {};
 80018d2:	e7fe      	b.n	80018d2 <I2C_MasterIO_Init+0xe>
  if(pM->SDA>=DIE_PAD_MAX)
 80018d4:	2300      	movs	r3, #0
 80018d6:	56c3      	ldrsb	r3, [r0, r3]
 80018d8:	2b5f      	cmp	r3, #95	; 0x5f
 80018da:	dd00      	ble.n	80018de <I2C_MasterIO_Init+0x1a>
    while(1) {};
 80018dc:	e7fe      	b.n	80018dc <I2C_MasterIO_Init+0x18>
}
 80018de:	2000      	movs	r0, #0
 80018e0:	4770      	bx	lr

080018e2 <I2C_MasterIO_ConfigHW>:
int32_t I2C_MasterIO_ConfigHW( I2C_MasterIO_t* pM, PadName_t Pad_SDA, PadName_t Pad_SCL ) {
 80018e2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018e4:	46de      	mov	lr, fp
 80018e6:	4657      	mov	r7, sl
 80018e8:	464e      	mov	r6, r9
 80018ea:	4645      	mov	r5, r8
 80018ec:	b5e0      	push	{r5, r6, r7, lr}
 80018ee:	b083      	sub	sp, #12
 80018f0:	0005      	movs	r5, r0
 80018f2:	0008      	movs	r0, r1
 80018f4:	0016      	movs	r6, r2
  IO_Pad_t SDA = { Pad_SDA, {.Mode = IO_OUTPUT, .Pull = IO_PULLUP, .Drive = IO_OPENDRAIN, .Speed = IO_SPEED_01, .Odr = IO_ODR_HIGH} };
 80018f6:	ac01      	add	r4, sp, #4
 80018f8:	2300      	movs	r3, #0
 80018fa:	469b      	mov	fp, r3
 80018fc:	9301      	str	r3, [sp, #4]
 80018fe:	7021      	strb	r1, [r4, #0]
 8001900:	7862      	ldrb	r2, [r4, #1]
 8001902:	3307      	adds	r3, #7
 8001904:	4698      	mov	r8, r3
 8001906:	439a      	bics	r2, r3
 8001908:	2302      	movs	r3, #2
 800190a:	431a      	orrs	r2, r3
 800190c:	7062      	strb	r2, [r4, #1]
 800190e:	b2d2      	uxtb	r2, r2
 8001910:	2138      	movs	r1, #56	; 0x38
 8001912:	468a      	mov	sl, r1
 8001914:	438a      	bics	r2, r1
 8001916:	2710      	movs	r7, #16
 8001918:	433a      	orrs	r2, r7
 800191a:	7062      	strb	r2, [r4, #1]
 800191c:	b2d1      	uxtb	r1, r2
 800191e:	223f      	movs	r2, #63	; 0x3f
 8001920:	4691      	mov	r9, r2
 8001922:	4011      	ands	r1, r2
 8001924:	3abf      	subs	r2, #191	; 0xbf
 8001926:	4311      	orrs	r1, r2
 8001928:	7061      	strb	r1, [r4, #1]
 800192a:	78a1      	ldrb	r1, [r4, #2]
 800192c:	4642      	mov	r2, r8
 800192e:	4391      	bics	r1, r2
 8001930:	4319      	orrs	r1, r3
 8001932:	70a1      	strb	r1, [r4, #2]
 8001934:	b2c9      	uxtb	r1, r1
 8001936:	3211      	adds	r2, #17
 8001938:	4694      	mov	ip, r2
 800193a:	4391      	bics	r1, r2
 800193c:	4339      	orrs	r1, r7
 800193e:	70a1      	strb	r1, [r4, #2]
  IO_Pad_t SCL = { Pad_SCL, {.Mode = IO_OUTPUT, .Pull = IO_PULLUP, .Drive = IO_OPENDRAIN, .Speed = IO_SPEED_01, .Odr = IO_ODR_HIGH} };
 8001940:	465a      	mov	r2, fp
 8001942:	9200      	str	r2, [sp, #0]
 8001944:	466a      	mov	r2, sp
 8001946:	7016      	strb	r6, [r2, #0]
 8001948:	7851      	ldrb	r1, [r2, #1]
 800194a:	4642      	mov	r2, r8
 800194c:	4391      	bics	r1, r2
 800194e:	4319      	orrs	r1, r3
 8001950:	466a      	mov	r2, sp
 8001952:	7051      	strb	r1, [r2, #1]
 8001954:	b2c9      	uxtb	r1, r1
 8001956:	4652      	mov	r2, sl
 8001958:	4391      	bics	r1, r2
 800195a:	4339      	orrs	r1, r7
 800195c:	466a      	mov	r2, sp
 800195e:	7051      	strb	r1, [r2, #1]
 8001960:	b2c9      	uxtb	r1, r1
 8001962:	464a      	mov	r2, r9
 8001964:	4011      	ands	r1, r2
 8001966:	3abf      	subs	r2, #191	; 0xbf
 8001968:	430a      	orrs	r2, r1
 800196a:	4669      	mov	r1, sp
 800196c:	704a      	strb	r2, [r1, #1]
 800196e:	788a      	ldrb	r2, [r1, #2]
 8001970:	4641      	mov	r1, r8
 8001972:	438a      	bics	r2, r1
 8001974:	431a      	orrs	r2, r3
 8001976:	466b      	mov	r3, sp
 8001978:	709a      	strb	r2, [r3, #2]
 800197a:	b2d3      	uxtb	r3, r2
 800197c:	4662      	mov	r2, ip
 800197e:	4393      	bics	r3, r2
 8001980:	433b      	orrs	r3, r7
 8001982:	466a      	mov	r2, sp
 8001984:	7093      	strb	r3, [r2, #2]
  pM->SDA = Pad_SDA;
 8001986:	7028      	strb	r0, [r5, #0]
  pM->SCL = Pad_SCL;
 8001988:	706e      	strb	r6, [r5, #1]
  IO_AddPadToRawPortPads(Pad_SDA, &pM->RawPad_SDA );
 800198a:	0029      	movs	r1, r5
 800198c:	310c      	adds	r1, #12
 800198e:	f003 fd65 	bl	800545c <IO_AddPadToRawPortPads>
  IO_AddPadToRawPortPads(Pad_SCL, &pM->RawPad_SCL );
 8001992:	0029      	movs	r1, r5
 8001994:	3114      	adds	r1, #20
 8001996:	0030      	movs	r0, r6
 8001998:	f003 fd60 	bl	800545c <IO_AddPadToRawPortPads>
  IO_PadInit(&SDA); // configure the pins
 800199c:	0020      	movs	r0, r4
 800199e:	f003 fd7d 	bl	800549c <IO_PadInit>
  IO_PadInit(&SCL); // configure the pins
 80019a2:	4668      	mov	r0, sp
 80019a4:	f003 fd7a 	bl	800549c <IO_PadInit>
}
 80019a8:	2000      	movs	r0, #0
 80019aa:	b003      	add	sp, #12
 80019ac:	bcf0      	pop	{r4, r5, r6, r7}
 80019ae:	46bb      	mov	fp, r7
 80019b0:	46b2      	mov	sl, r6
 80019b2:	46a9      	mov	r9, r5
 80019b4:	46a0      	mov	r8, r4
 80019b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080019b8 <I2C_MasterIO_ConfigTimings>:
int32_t I2C_MasterIO_ConfigTimings(I2C_MasterIO_t* pM, uint32_t MinBps, uint32_t MaxBps, uint32_t ClockStretch_ms) { // to explain more
 80019b8:	b570      	push	{r4, r5, r6, lr}
 80019ba:	0004      	movs	r4, r0
 80019bc:	000d      	movs	r5, r1
  if(ClockStretch_ms) 
 80019be:	2b00      	cmp	r3, #0
 80019c0:	d000      	beq.n	80019c4 <I2C_MasterIO_ConfigTimings+0xc>
    while(1) {};
 80019c2:	e7fe      	b.n	80019c2 <I2C_MasterIO_ConfigTimings+0xa>
  pM->fnWaitMethod = NopsWait; // use nops SW loop especially for Cortex M0+, for others, you might use DBG Cycle counter which is more accurate.
 80019c4:	4b08      	ldr	r3, [pc, #32]	; (80019e8 <I2C_MasterIO_ConfigTimings+0x30>)
 80019c6:	61c3      	str	r3, [r0, #28]
  HalfClockPeriod_us = (SYS_CLK_HZ)/(MaxBps*SYS_CLK_MHZ /*48*/); // ADAPT_HERE :Here the core is assumed running at 48 MHz with 1 cycle per NOP. Crude formula. Maybe core type dependent.
 80019c8:	0051      	lsls	r1, r2, #1
 80019ca:	1889      	adds	r1, r1, r2
 80019cc:	0109      	lsls	r1, r1, #4
 80019ce:	4807      	ldr	r0, [pc, #28]	; (80019ec <I2C_MasterIO_ConfigTimings+0x34>)
 80019d0:	f7fe fb9a 	bl	8000108 <__udivsi3>
  pM->WaitParam = HalfClockPeriod_us;
 80019d4:	6260      	str	r0, [r4, #36]	; 0x24
  pM->bitrate_kHz = MinBps / 1000;
 80019d6:	21fa      	movs	r1, #250	; 0xfa
 80019d8:	0089      	lsls	r1, r1, #2
 80019da:	0028      	movs	r0, r5
 80019dc:	f7fe fb94 	bl	8000108 <__udivsi3>
 80019e0:	6060      	str	r0, [r4, #4]
}
 80019e2:	2000      	movs	r0, #0
 80019e4:	bd70      	pop	{r4, r5, r6, pc}
 80019e6:	46c0      	nop			; (mov r8, r8)
 80019e8:	08001645 	.word	0x08001645
 80019ec:	02dc6c00 	.word	0x02dc6c00

080019f0 <I2C_MasterIO_AccessSlave>:

//====---------------------------> 8>< <----------------===========================
// THE ONLY FUNCTION NEEDED FOR MOST SLAVE ACCESS, ONE API ONLY. Grep on it to see how it is used....
// simplified I2C Master write/read command, monoblock
int32_t I2C_MasterIO_AccessSlave(I2C_SlaveDevice_t* pD) { // Param1: Block adr, Param2: Block size byte, Param3: Ack when read or not
 80019f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019f2:	46c6      	mov	lr, r8
 80019f4:	b500      	push	{lr}
 80019f6:	4680      	mov	r8, r0
  
  I2C_MasterIO_t* pM = (I2C_MasterIO_t*) pD->M;
 80019f8:	6805      	ldr	r5, [r0, #0]
  uint8_t* pu8;
  uint16_t bCount;
  
  // if the TX adr is null, no bytes to transmit, disable MOSI, and transmit dummy things instead
  if((pD->SubAdrByteCount!=0)||(pD->WriteByteCount!=0)) { // skip if no sub address nor any byte to write // 09/05/2019
 80019fa:	7943      	ldrb	r3, [r0, #5]
 80019fc:	2b00      	cmp	r3, #0
 80019fe:	d102      	bne.n	8001a06 <I2C_MasterIO_AccessSlave+0x16>
 8001a00:	8a03      	ldrh	r3, [r0, #16]
 8001a02:	2b00      	cmp	r3, #0
 8001a04:	d016      	beq.n	8001a34 <I2C_MasterIO_AccessSlave+0x44>
    
    pD->SlaveAdrWriteNack = GenerateStart (pM, pD->SlaveAdr & 0xFE); // AckFail = 0 done inside
 8001a06:	4643      	mov	r3, r8
 8001a08:	7919      	ldrb	r1, [r3, #4]
 8001a0a:	2301      	movs	r3, #1
 8001a0c:	4399      	bics	r1, r3
 8001a0e:	0028      	movs	r0, r5
 8001a10:	f7ff ff18 	bl	8001844 <GenerateStart>
 8001a14:	4643      	mov	r3, r8
 8001a16:	7698      	strb	r0, [r3, #26]

    // transmit prefix  
    pu8 = (uint8_t*) pD->SubAdrBytes;
 8001a18:	1d9a      	adds	r2, r3, #6
    bCount = (uint16_t) pD->SubAdrByteCount;
 8001a1a:	795b      	ldrb	r3, [r3, #5]
    
    if((pu8)&&(bCount)) {
 8001a1c:	4641      	mov	r1, r8
 8001a1e:	3106      	adds	r1, #6
 8001a20:	d001      	beq.n	8001a26 <I2C_MasterIO_AccessSlave+0x36>
 8001a22:	2b00      	cmp	r3, #0
 8001a24:	d125      	bne.n	8001a72 <I2C_MasterIO_AccessSlave+0x82>
         pM->AckFail |= TransmitByte (pM, *pu8++);
      }
    }

    // transmit
    pu8 = (uint8_t*) pD->pWriteByte;
 8001a26:	4643      	mov	r3, r8
 8001a28:	68da      	ldr	r2, [r3, #12]
    bCount = (uint16_t) pD->WriteByteCount;
 8001a2a:	8a1b      	ldrh	r3, [r3, #16]
    
    if((pu8)&&(bCount)) // if there is something to send
 8001a2c:	2a00      	cmp	r2, #0
 8001a2e:	d001      	beq.n	8001a34 <I2C_MasterIO_AccessSlave+0x44>
 8001a30:	2b00      	cmp	r3, #0
 8001a32:	d130      	bne.n	8001a96 <I2C_MasterIO_AccessSlave+0xa6>
      while((pM->AckFail==0)&& (bCount--)) { // for all bytes... if ack fail, skip the transmit part
         pM->AckFail |= TransmitByte (pM, *pu8++);
      }
  }
  // receive
  pu8 = (uint8_t*) pD->pReadByte;
 8001a34:	4643      	mov	r3, r8
 8001a36:	695e      	ldr	r6, [r3, #20]
  bCount = (uint16_t) pD->ReadByteCount;
 8001a38:	8b1f      	ldrh	r7, [r3, #24]
  
  // if no error and something to read
  if((pM->AckFail==0)&&(pu8)&&(bCount))
 8001a3a:	7aab      	ldrb	r3, [r5, #10]
 8001a3c:	2b00      	cmp	r3, #0
 8001a3e:	d139      	bne.n	8001ab4 <I2C_MasterIO_AccessSlave+0xc4>
 8001a40:	2e00      	cmp	r6, #0
 8001a42:	d037      	beq.n	8001ab4 <I2C_MasterIO_AccessSlave+0xc4>
 8001a44:	2f00      	cmp	r7, #0
 8001a46:	d035      	beq.n	8001ab4 <I2C_MasterIO_AccessSlave+0xc4>
    pD->SlaveAdrReadNack = GenerateStart(pM, pD->SlaveAdr | 0x01); // do the restart
 8001a48:	4643      	mov	r3, r8
 8001a4a:	7919      	ldrb	r1, [r3, #4]
 8001a4c:	2301      	movs	r3, #1
 8001a4e:	4319      	orrs	r1, r3
 8001a50:	b2c9      	uxtb	r1, r1
 8001a52:	0028      	movs	r0, r5
 8001a54:	f7ff fef6 	bl	8001844 <GenerateStart>
 8001a58:	4643      	mov	r3, r8
 8001a5a:	76d8      	strb	r0, [r3, #27]
 8001a5c:	e02a      	b.n	8001ab4 <I2C_MasterIO_AccessSlave+0xc4>
         pM->AckFail |= TransmitByte (pM, *pu8++);
 8001a5e:	1c56      	adds	r6, r2, #1
 8001a60:	7811      	ldrb	r1, [r2, #0]
 8001a62:	0028      	movs	r0, r5
 8001a64:	f7ff fe94 	bl	8001790 <TransmitByte>
 8001a68:	7aab      	ldrb	r3, [r5, #10]
 8001a6a:	4303      	orrs	r3, r0
 8001a6c:	72ab      	strb	r3, [r5, #10]
      while((pM->AckFail==0)&& (bCount--)) { // for all bytes... if ack fail, skip the transmit part
 8001a6e:	0023      	movs	r3, r4
         pM->AckFail |= TransmitByte (pM, *pu8++);
 8001a70:	0032      	movs	r2, r6
      while((pM->AckFail==0)&& (bCount--)) { // for all bytes... if ack fail, skip the transmit part
 8001a72:	7aa9      	ldrb	r1, [r5, #10]
 8001a74:	2900      	cmp	r1, #0
 8001a76:	d1d6      	bne.n	8001a26 <I2C_MasterIO_AccessSlave+0x36>
 8001a78:	1e5c      	subs	r4, r3, #1
 8001a7a:	b2a4      	uxth	r4, r4
 8001a7c:	2b00      	cmp	r3, #0
 8001a7e:	d1ee      	bne.n	8001a5e <I2C_MasterIO_AccessSlave+0x6e>
 8001a80:	e7d1      	b.n	8001a26 <I2C_MasterIO_AccessSlave+0x36>
         pM->AckFail |= TransmitByte (pM, *pu8++);
 8001a82:	1c56      	adds	r6, r2, #1
 8001a84:	7811      	ldrb	r1, [r2, #0]
 8001a86:	0028      	movs	r0, r5
 8001a88:	f7ff fe82 	bl	8001790 <TransmitByte>
 8001a8c:	7aab      	ldrb	r3, [r5, #10]
 8001a8e:	4303      	orrs	r3, r0
 8001a90:	72ab      	strb	r3, [r5, #10]
      while((pM->AckFail==0)&& (bCount--)) { // for all bytes... if ack fail, skip the transmit part
 8001a92:	0023      	movs	r3, r4
         pM->AckFail |= TransmitByte (pM, *pu8++);
 8001a94:	0032      	movs	r2, r6
      while((pM->AckFail==0)&& (bCount--)) { // for all bytes... if ack fail, skip the transmit part
 8001a96:	7aa9      	ldrb	r1, [r5, #10]
 8001a98:	2900      	cmp	r1, #0
 8001a9a:	d1cb      	bne.n	8001a34 <I2C_MasterIO_AccessSlave+0x44>
 8001a9c:	1e5c      	subs	r4, r3, #1
 8001a9e:	b2a4      	uxth	r4, r4
 8001aa0:	2b00      	cmp	r3, #0
 8001aa2:	d1ee      	bne.n	8001a82 <I2C_MasterIO_AccessSlave+0x92>
 8001aa4:	e7c6      	b.n	8001a34 <I2C_MasterIO_AccessSlave+0x44>
  
  while((pM->AckFail==0)&&(pu8)&&(bCount--)) {
    *pu8++ = (uint8_t) ReceiveByte (pM,bCount);
 8001aa6:	0021      	movs	r1, r4
 8001aa8:	0028      	movs	r0, r5
 8001aaa:	f7ff fe1d 	bl	80016e8 <ReceiveByte>
 8001aae:	7030      	strb	r0, [r6, #0]
  while((pM->AckFail==0)&&(pu8)&&(bCount--)) {
 8001ab0:	0027      	movs	r7, r4
    *pu8++ = (uint8_t) ReceiveByte (pM,bCount);
 8001ab2:	3601      	adds	r6, #1
  while((pM->AckFail==0)&&(pu8)&&(bCount--)) {
 8001ab4:	7aab      	ldrb	r3, [r5, #10]
 8001ab6:	2b00      	cmp	r3, #0
 8001ab8:	d105      	bne.n	8001ac6 <I2C_MasterIO_AccessSlave+0xd6>
 8001aba:	2e00      	cmp	r6, #0
 8001abc:	d003      	beq.n	8001ac6 <I2C_MasterIO_AccessSlave+0xd6>
 8001abe:	1e7c      	subs	r4, r7, #1
 8001ac0:	b2a4      	uxth	r4, r4
 8001ac2:	2f00      	cmp	r7, #0
 8001ac4:	d1ef      	bne.n	8001aa6 <I2C_MasterIO_AccessSlave+0xb6>
  }

  GenerateStop(pM);
 8001ac6:	0028      	movs	r0, r5
 8001ac8:	f7ff fdcf 	bl	800166a <GenerateStop>
  
  if(pM->AckFail || pD->SlaveAdrReadNack || pD->SlaveAdrWriteNack)
 8001acc:	7aab      	ldrb	r3, [r5, #10]
 8001ace:	2b00      	cmp	r3, #0
 8001ad0:	d107      	bne.n	8001ae2 <I2C_MasterIO_AccessSlave+0xf2>
 8001ad2:	4643      	mov	r3, r8
 8001ad4:	8b5b      	ldrh	r3, [r3, #26]
 8001ad6:	2b00      	cmp	r3, #0
 8001ad8:	d106      	bne.n	8001ae8 <I2C_MasterIO_AccessSlave+0xf8>
    return -1; // error
  
  return 0; // no interrupt call back setup here
 8001ada:	2000      	movs	r0, #0
}
 8001adc:	bc80      	pop	{r7}
 8001ade:	46b8      	mov	r8, r7
 8001ae0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1; // error
 8001ae2:	2001      	movs	r0, #1
 8001ae4:	4240      	negs	r0, r0
 8001ae6:	e7f9      	b.n	8001adc <I2C_MasterIO_AccessSlave+0xec>
 8001ae8:	2001      	movs	r0, #1
 8001aea:	4240      	negs	r0, r0
 8001aec:	e7f6      	b.n	8001adc <I2C_MasterIO_AccessSlave+0xec>

08001aee <I2C_MasterIO_IsSlavePresentByAddress>:


//==== higher level abstraction functions

uint8_t I2C_MasterIO_IsSlavePresentByAddress(I2C_MasterIO_t* pM, uint8_t SlaveAdr) {
 8001aee:	b570      	push	{r4, r5, r6, lr}
 8001af0:	0004      	movs	r4, r0

  uint8_t SlavePresent;  
  
  if(GenerateStart (pM, SlaveAdr & 0xFE)==0)
 8001af2:	2301      	movs	r3, #1
 8001af4:	4399      	bics	r1, r3
 8001af6:	f7ff fea5 	bl	8001844 <GenerateStart>
 8001afa:	2800      	cmp	r0, #0
 8001afc:	d105      	bne.n	8001b0a <I2C_MasterIO_IsSlavePresentByAddress+0x1c>
    SlavePresent = 1;
 8001afe:	2501      	movs	r5, #1
  else
    SlavePresent = 0;
  
  GenerateStop(pM);
 8001b00:	0020      	movs	r0, r4
 8001b02:	f7ff fdb2 	bl	800166a <GenerateStop>
  
  return SlavePresent;  
}
 8001b06:	0028      	movs	r0, r5
 8001b08:	bd70      	pop	{r4, r5, r6, pc}
    SlavePresent = 0;
 8001b0a:	2500      	movs	r5, #0
 8001b0c:	e7f8      	b.n	8001b00 <I2C_MasterIO_IsSlavePresentByAddress+0x12>

08001b0e <I2C_MasterIO_IsSlavePresent>:

uint8_t I2C_MasterIO_IsSlavePresent(I2C_SlaveDevice_t* pD) {
 8001b0e:	b510      	push	{r4, lr}
  
  return I2C_MasterIO_IsSlavePresentByAddress(pD->M, pD->SlaveAdr);
 8001b10:	7901      	ldrb	r1, [r0, #4]
 8001b12:	6800      	ldr	r0, [r0, #0]
 8001b14:	f7ff ffeb 	bl	8001aee <I2C_MasterIO_IsSlavePresentByAddress>
}
 8001b18:	bd10      	pop	{r4, pc}

08001b1a <I2C_MasterIO_FindNextSlaveByAddress>:

uint8_t I2C_MasterIO_FindNextSlaveByAddress(I2C_MasterIO_t* pM, uint8_t StartAdr) {
 8001b1a:	b570      	push	{r4, r5, r6, lr}
 8001b1c:	0005      	movs	r5, r0

  uint8_t SlaveAdr;
  SlaveAdr = (StartAdr & 0xFE) + 2; // start sweeping from next address, when you find one, store the address and continue with it. You can start with 0 which is general call unused address)
 8001b1e:	2301      	movs	r3, #1
 8001b20:	4399      	bics	r1, r3
 8001b22:	000c      	movs	r4, r1
 8001b24:	3402      	adds	r4, #2
 8001b26:	b2e4      	uxtb	r4, r4
  
  for( ; SlaveAdr < 0xF0; SlaveAdr+=2)
 8001b28:	e001      	b.n	8001b2e <I2C_MasterIO_FindNextSlaveByAddress+0x14>
 8001b2a:	3402      	adds	r4, #2
 8001b2c:	b2e4      	uxtb	r4, r4
 8001b2e:	2cef      	cmp	r4, #239	; 0xef
 8001b30:	d806      	bhi.n	8001b40 <I2C_MasterIO_FindNextSlaveByAddress+0x26>
    if(I2C_MasterIO_IsSlavePresentByAddress(pM, SlaveAdr))
 8001b32:	0021      	movs	r1, r4
 8001b34:	0028      	movs	r0, r5
 8001b36:	f7ff ffda 	bl	8001aee <I2C_MasterIO_IsSlavePresentByAddress>
 8001b3a:	2800      	cmp	r0, #0
 8001b3c:	d0f5      	beq.n	8001b2a <I2C_MasterIO_FindNextSlaveByAddress+0x10>
 8001b3e:	e000      	b.n	8001b42 <I2C_MasterIO_FindNextSlaveByAddress+0x28>
      return SlaveAdr;
  
  return 0; // nothing found till the end of the sweep spectrum
 8001b40:	2400      	movs	r4, #0
}
 8001b42:	0020      	movs	r0, r4
 8001b44:	bd70      	pop	{r4, r5, r6, pc}
	...

08001b48 <Brisk_I2C_MasterIO_Init>:
uint8_t IsDevicePresent(I2C_SlaveDevice_t* pD) {
  
  return IsSlavePresent(pD->M, pD->SlaveAdr);
}
*/
void Brisk_I2C_MasterIO_Init(void) {
 8001b48:	b570      	push	{r4, r5, r6, lr}

  I2C_MasterIO_Init(&gI2C_STMod);
 8001b4a:	4c13      	ldr	r4, [pc, #76]	; (8001b98 <Brisk_I2C_MasterIO_Init+0x50>)
 8001b4c:	0020      	movs	r0, r4
 8001b4e:	f7ff feb9 	bl	80018c4 <I2C_MasterIO_Init>
  I2C_MasterIO_ConfigTimings(&gI2C_STMod, 100000, 400000, 0);  
 8001b52:	4e12      	ldr	r6, [pc, #72]	; (8001b9c <Brisk_I2C_MasterIO_Init+0x54>)
 8001b54:	4d12      	ldr	r5, [pc, #72]	; (8001ba0 <Brisk_I2C_MasterIO_Init+0x58>)
 8001b56:	2300      	movs	r3, #0
 8001b58:	0032      	movs	r2, r6
 8001b5a:	0029      	movs	r1, r5
 8001b5c:	0020      	movs	r0, r4
 8001b5e:	f7ff ff2b 	bl	80019b8 <I2C_MasterIO_ConfigTimings>
  I2C_MasterIO_ConfigHW(&gI2C_STMod, PB_11, PB_10);
 8001b62:	221a      	movs	r2, #26
 8001b64:	211b      	movs	r1, #27
 8001b66:	0020      	movs	r0, r4
 8001b68:	f7ff febb 	bl	80018e2 <I2C_MasterIO_ConfigHW>
  I2C_MasterIO_Enable(&gI2C_STMod);
  
  ErrorRecovery(&gI2C_STMod);
 8001b6c:	0020      	movs	r0, r4
 8001b6e:	f7ff fda0 	bl	80016b2 <ErrorRecovery>
// Test on Nucleo board
  I2C_MasterIO_Init(&gI2C_Arduino);
 8001b72:	4c0c      	ldr	r4, [pc, #48]	; (8001ba4 <Brisk_I2C_MasterIO_Init+0x5c>)
 8001b74:	0020      	movs	r0, r4
 8001b76:	f7ff fea5 	bl	80018c4 <I2C_MasterIO_Init>
  I2C_MasterIO_ConfigTimings(&gI2C_Arduino, 100000, 400000, 0);
 8001b7a:	2300      	movs	r3, #0
 8001b7c:	0032      	movs	r2, r6
 8001b7e:	0029      	movs	r1, r5
 8001b80:	0020      	movs	r0, r4
 8001b82:	f7ff ff19 	bl	80019b8 <I2C_MasterIO_ConfigTimings>
  I2C_MasterIO_ConfigHW(&gI2C_Arduino, PB_9, PB_8);
 8001b86:	2218      	movs	r2, #24
 8001b88:	2119      	movs	r1, #25
 8001b8a:	0020      	movs	r0, r4
 8001b8c:	f7ff fea9 	bl	80018e2 <I2C_MasterIO_ConfigHW>
  I2C_MasterIO_Enable(&gI2C_Arduino);
  
  ErrorRecovery(&gI2C_Arduino);
 8001b90:	0020      	movs	r0, r4
 8001b92:	f7ff fd8e 	bl	80016b2 <ErrorRecovery>
  I2C_MasterIO_ConfigHW(&gI2C_STMod);
  I2C_MasterIO_Enable(&gI2C_STMod);
  
  ErrorRecovery(&gI2C_STMod);
*/
}
 8001b96:	bd70      	pop	{r4, r5, r6, pc}
 8001b98:	20000594 	.word	0x20000594
 8001b9c:	00061a80 	.word	0x00061a80
 8001ba0:	000186a0 	.word	0x000186a0
 8001ba4:	2000056c 	.word	0x2000056c

08001ba8 <GetTimestamp>:

    uint32_t res;
    int32_t cnt;
//    uint32_t tmp = __get_PRIMASK(); // save the interrupt status (could already be disabled)
//    __set_PRIMASK(tmp | 1);
    cnt = TIM3->CNT;
 8001ba8:	4b0b      	ldr	r3, [pc, #44]	; (8001bd8 <GetTimestamp+0x30>)
 8001baa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    if(cnt<0) { // bit 31 is set if pending overflow
 8001bac:	2b00      	cmp	r3, #0
 8001bae:	db08      	blt.n	8001bc2 <GetTimestamp+0x1a>
      res = ((gINT_Stats.tick_msb+1) <<16)|((uint16_t)cnt); 
    }else{
      res = ((gINT_Stats.tick_msb+0) <<16)|((uint16_t)cnt); 
 8001bb0:	490a      	ldr	r1, [pc, #40]	; (8001bdc <GetTimestamp+0x34>)
 8001bb2:	22b4      	movs	r2, #180	; 0xb4
 8001bb4:	0092      	lsls	r2, r2, #2
 8001bb6:	588a      	ldr	r2, [r1, r2]
 8001bb8:	0412      	lsls	r2, r2, #16
 8001bba:	041b      	lsls	r3, r3, #16
 8001bbc:	0c18      	lsrs	r0, r3, #16
 8001bbe:	4310      	orrs	r0, r2
    }
//    __set_PRIMASK(tmp); // restore the interrupt status
    return res;
}
 8001bc0:	4770      	bx	lr
      res = ((gINT_Stats.tick_msb+1) <<16)|((uint16_t)cnt); 
 8001bc2:	4906      	ldr	r1, [pc, #24]	; (8001bdc <GetTimestamp+0x34>)
 8001bc4:	22b4      	movs	r2, #180	; 0xb4
 8001bc6:	0092      	lsls	r2, r2, #2
 8001bc8:	5888      	ldr	r0, [r1, r2]
 8001bca:	3001      	adds	r0, #1
 8001bcc:	0402      	lsls	r2, r0, #16
 8001bce:	041b      	lsls	r3, r3, #16
 8001bd0:	0c18      	lsrs	r0, r3, #16
 8001bd2:	4310      	orrs	r0, r2
 8001bd4:	e7f4      	b.n	8001bc0 <GetTimestamp+0x18>
 8001bd6:	46c0      	nop			; (mov r8, r8)
 8001bd8:	40000400 	.word	0x40000400
 8001bdc:	2000061c 	.word	0x2000061c

08001be0 <INT_Stats_Init>:
  // now we assume here SYSTICK is already configured and we calibrate our stuff
  
  return 0;
}

int32_t INT_Stats_Init(INTs_Index_t ndx) {
 8001be0:	b530      	push	{r4, r5, lr}
                       
  if(ndx>=INT_COUNT)  while(1);
 8001be2:	2812      	cmp	r0, #18
 8001be4:	d900      	bls.n	8001be8 <INT_Stats_Init+0x8>
 8001be6:	e7fe      	b.n	8001be6 <INT_Stats_Init+0x6>
  INT_Stats_t* pis = &gINT_Stats.All_cy[ndx];
  
  pis->min_duration = 0x7FFFFFFF; // 
 8001be8:	4908      	ldr	r1, [pc, #32]	; (8001c0c <INT_Stats_Init+0x2c>)
 8001bea:	00c2      	lsls	r2, r0, #3
 8001bec:	1813      	adds	r3, r2, r0
 8001bee:	009b      	lsls	r3, r3, #2
 8001bf0:	18cb      	adds	r3, r1, r3
 8001bf2:	4d07      	ldr	r5, [pc, #28]	; (8001c10 <INT_Stats_Init+0x30>)
 8001bf4:	60dd      	str	r5, [r3, #12]
  pis->max_duration = 0x00000000; // 
 8001bf6:	2400      	movs	r4, #0
 8001bf8:	611c      	str	r4, [r3, #16]
  pis->min_period = 0x7FFFFFFF;
 8001bfa:	615d      	str	r5, [r3, #20]
  pis->max_period = 0x00000000;  
 8001bfc:	619c      	str	r4, [r3, #24]
  pis->nb_count = 0;
 8001bfe:	61dc      	str	r4, [r3, #28]
  pis->nb_countdown = -1; // interrupt overrun disabled
 8001c00:	001a      	movs	r2, r3
 8001c02:	2301      	movs	r3, #1
 8001c04:	425b      	negs	r3, r3
 8001c06:	8413      	strh	r3, [r2, #32]
//  pis->nb_too_late = 0;
//  pis->enabled = 0;
  return 0;
}
 8001c08:	2000      	movs	r0, #0
 8001c0a:	bd30      	pop	{r4, r5, pc}
 8001c0c:	2000061c 	.word	0x2000061c
 8001c10:	7fffffff 	.word	0x7fffffff

08001c14 <INTs_AllStats_Init>:
int32_t INTs_AllStats_Init(void) {
 8001c14:	b510      	push	{r4, lr}
  for(int32_t ndx = 0; ndx<INT_COUNT; ndx++) {
 8001c16:	2400      	movs	r4, #0
 8001c18:	e003      	b.n	8001c22 <INTs_AllStats_Init+0xe>
    INT_Stats_Init(ndx);
 8001c1a:	b2e0      	uxtb	r0, r4
 8001c1c:	f7ff ffe0 	bl	8001be0 <INT_Stats_Init>
  for(int32_t ndx = 0; ndx<INT_COUNT; ndx++) {
 8001c20:	3401      	adds	r4, #1
 8001c22:	2c12      	cmp	r4, #18
 8001c24:	ddf9      	ble.n	8001c1a <INTs_AllStats_Init+0x6>
  gINT_Stats.tick_msb = 0;
 8001c26:	4a03      	ldr	r2, [pc, #12]	; (8001c34 <INTs_AllStats_Init+0x20>)
 8001c28:	23b4      	movs	r3, #180	; 0xb4
 8001c2a:	009b      	lsls	r3, r3, #2
 8001c2c:	2100      	movs	r1, #0
 8001c2e:	50d1      	str	r1, [r2, r3]
}
 8001c30:	2000      	movs	r0, #0
 8001c32:	bd10      	pop	{r4, pc}
 8001c34:	2000061c 	.word	0x2000061c

08001c38 <INT_Enter>:

//uint32_t ts_enter, ts_leave;

void INT_Enter(INTs_Index_t ndx) {
 8001c38:	b570      	push	{r4, r5, r6, lr}
 8001c3a:	0004      	movs	r4, r0

  if(ndx>=INT_COUNT)  while(1);
 8001c3c:	2812      	cmp	r0, #18
 8001c3e:	d900      	bls.n	8001c42 <INT_Enter+0xa>
 8001c40:	e7fe      	b.n	8001c40 <INT_Enter+0x8>
  INT_Stats_t* pis = &gINT_Stats.All_cy[ndx];
  
//  pis->was_too_late = 0;
  pis->last_enter = pis->enter; //
 8001c42:	4e08      	ldr	r6, [pc, #32]	; (8001c64 <INT_Enter+0x2c>)
 8001c44:	00c5      	lsls	r5, r0, #3
 8001c46:	182b      	adds	r3, r5, r0
 8001c48:	009b      	lsls	r3, r3, #2
 8001c4a:	18f3      	adds	r3, r6, r3
 8001c4c:	685a      	ldr	r2, [r3, #4]
 8001c4e:	182b      	adds	r3, r5, r0
 8001c50:	009b      	lsls	r3, r3, #2
 8001c52:	519a      	str	r2, [r3, r6]
  pis->enter = GetTimestamp();
 8001c54:	f7ff ffa8 	bl	8001ba8 <GetTimestamp>
 8001c58:	192c      	adds	r4, r5, r4
 8001c5a:	00a4      	lsls	r4, r4, #2
 8001c5c:	1934      	adds	r4, r6, r4
 8001c5e:	6060      	str	r0, [r4, #4]
}
 8001c60:	bd70      	pop	{r4, r5, r6, pc}
 8001c62:	46c0      	nop			; (mov r8, r8)
 8001c64:	2000061c 	.word	0x2000061c

08001c68 <INT_Leave>:


//=== coder's function to insert in the INT_Handler

void INT_Leave(INTs_Index_t ndx) {
 8001c68:	b570      	push	{r4, r5, r6, lr}
 8001c6a:	0004      	movs	r4, r0

  if(ndx>=INT_COUNT)  while(1);
 8001c6c:	2812      	cmp	r0, #18
 8001c6e:	d900      	bls.n	8001c72 <INT_Leave+0xa>
 8001c70:	e7fe      	b.n	8001c70 <INT_Leave+0x8>
  INT_Stats_t* pis = &gINT_Stats.All_cy[ndx];
  
  pis->leave = GetTimestamp(); // net
 8001c72:	f7ff ff99 	bl	8001ba8 <GetTimestamp>
 8001c76:	4d2e      	ldr	r5, [pc, #184]	; (8001d30 <INT_Leave+0xc8>)
 8001c78:	00e2      	lsls	r2, r4, #3
 8001c7a:	1911      	adds	r1, r2, r4
 8001c7c:	0089      	lsls	r1, r1, #2
 8001c7e:	1869      	adds	r1, r5, r1
 8001c80:	6088      	str	r0, [r1, #8]
// most computation is done after interrupt latency critical timing
  int32_t period = pis->enter - pis->last_enter; // assume 32 bit value
 8001c82:	684b      	ldr	r3, [r1, #4]
 8001c84:	1912      	adds	r2, r2, r4
 8001c86:	0092      	lsls	r2, r2, #2
 8001c88:	5952      	ldr	r2, [r2, r5]
 8001c8a:	1a9a      	subs	r2, r3, r2
  if(period>=0) {
 8001c8c:	d417      	bmi.n	8001cbe <INT_Leave+0x56>
    pis->min_period = min2(period, pis->min_period);
 8001c8e:	00e1      	lsls	r1, r4, #3
 8001c90:	1909      	adds	r1, r1, r4
 8001c92:	0089      	lsls	r1, r1, #2
 8001c94:	1869      	adds	r1, r5, r1
 8001c96:	694e      	ldr	r6, [r1, #20]
 8001c98:	4296      	cmp	r6, r2
 8001c9a:	dd00      	ble.n	8001c9e <INT_Leave+0x36>
 8001c9c:	0016      	movs	r6, r2
 8001c9e:	00e1      	lsls	r1, r4, #3
 8001ca0:	1909      	adds	r1, r1, r4
 8001ca2:	0089      	lsls	r1, r1, #2
 8001ca4:	4d22      	ldr	r5, [pc, #136]	; (8001d30 <INT_Leave+0xc8>)
 8001ca6:	1869      	adds	r1, r5, r1
 8001ca8:	614e      	str	r6, [r1, #20]
    pis->max_period = max2(period, pis->max_period);
 8001caa:	698d      	ldr	r5, [r1, #24]
 8001cac:	4295      	cmp	r5, r2
 8001cae:	da00      	bge.n	8001cb2 <INT_Leave+0x4a>
 8001cb0:	0015      	movs	r5, r2
 8001cb2:	00e2      	lsls	r2, r4, #3
 8001cb4:	1912      	adds	r2, r2, r4
 8001cb6:	0092      	lsls	r2, r2, #2
 8001cb8:	491d      	ldr	r1, [pc, #116]	; (8001d30 <INT_Leave+0xc8>)
 8001cba:	188a      	adds	r2, r1, r2
 8001cbc:	6195      	str	r5, [r2, #24]
  }
// interrupt ended  
  
  int32_t duration = pis->leave - pis->enter;
 8001cbe:	1ac3      	subs	r3, r0, r3
  if(pis->nb_count<0x7FFFFFFF) {
 8001cc0:	00e2      	lsls	r2, r4, #3
 8001cc2:	1912      	adds	r2, r2, r4
 8001cc4:	0092      	lsls	r2, r2, #2
 8001cc6:	491a      	ldr	r1, [pc, #104]	; (8001d30 <INT_Leave+0xc8>)
 8001cc8:	188a      	adds	r2, r1, r2
 8001cca:	69d1      	ldr	r1, [r2, #28]
 8001ccc:	4a19      	ldr	r2, [pc, #100]	; (8001d34 <INT_Leave+0xcc>)
 8001cce:	4291      	cmp	r1, r2
 8001cd0:	d006      	beq.n	8001ce0 <INT_Leave+0x78>
    pis->nb_count++; // clamped
 8001cd2:	00e2      	lsls	r2, r4, #3
 8001cd4:	1912      	adds	r2, r2, r4
 8001cd6:	0092      	lsls	r2, r2, #2
 8001cd8:	4815      	ldr	r0, [pc, #84]	; (8001d30 <INT_Leave+0xc8>)
 8001cda:	1882      	adds	r2, r0, r2
 8001cdc:	3101      	adds	r1, #1
 8001cde:	61d1      	str	r1, [r2, #28]
  };
  
  if(duration<0) {
 8001ce0:	2b00      	cmp	r3, #0
 8001ce2:	db20      	blt.n	8001d26 <INT_Leave+0xbe>
    NOPs(1);
    return;
  }
  // here we process if interrupt was too late (and might reenter in this interrupt 100% of Core time!)
    pis->min_duration = min2(pis->min_duration, duration);
 8001ce4:	00e2      	lsls	r2, r4, #3
 8001ce6:	1912      	adds	r2, r2, r4
 8001ce8:	0092      	lsls	r2, r2, #2
 8001cea:	4911      	ldr	r1, [pc, #68]	; (8001d30 <INT_Leave+0xc8>)
 8001cec:	188a      	adds	r2, r1, r2
 8001cee:	68d0      	ldr	r0, [r2, #12]
 8001cf0:	4298      	cmp	r0, r3
 8001cf2:	dd00      	ble.n	8001cf6 <INT_Leave+0x8e>
 8001cf4:	0018      	movs	r0, r3
 8001cf6:	00e2      	lsls	r2, r4, #3
 8001cf8:	1912      	adds	r2, r2, r4
 8001cfa:	0092      	lsls	r2, r2, #2
 8001cfc:	490c      	ldr	r1, [pc, #48]	; (8001d30 <INT_Leave+0xc8>)
 8001cfe:	188a      	adds	r2, r1, r2
 8001d00:	60d0      	str	r0, [r2, #12]
    if(pis->nb_count>5) // we avoid the first values
 8001d02:	69d2      	ldr	r2, [r2, #28]
 8001d04:	2a05      	cmp	r2, #5
 8001d06:	dd0d      	ble.n	8001d24 <INT_Leave+0xbc>
      pis->max_duration = max2(pis->max_duration, duration);
 8001d08:	00e2      	lsls	r2, r4, #3
 8001d0a:	1912      	adds	r2, r2, r4
 8001d0c:	0092      	lsls	r2, r2, #2
 8001d0e:	188a      	adds	r2, r1, r2
 8001d10:	6912      	ldr	r2, [r2, #16]
 8001d12:	429a      	cmp	r2, r3
 8001d14:	da00      	bge.n	8001d18 <INT_Leave+0xb0>
 8001d16:	001a      	movs	r2, r3
 8001d18:	00e3      	lsls	r3, r4, #3
 8001d1a:	191c      	adds	r4, r3, r4
 8001d1c:	00a4      	lsls	r4, r4, #2
 8001d1e:	4b04      	ldr	r3, [pc, #16]	; (8001d30 <INT_Leave+0xc8>)
 8001d20:	191c      	adds	r4, r3, r4
 8001d22:	6122      	str	r2, [r4, #16]
    
}
 8001d24:	bd70      	pop	{r4, r5, r6, pc}
    NOPs(1);
 8001d26:	2001      	movs	r0, #1
 8001d28:	f001 fab0 	bl	800328c <NOPs>
    return;
 8001d2c:	e7fa      	b.n	8001d24 <INT_Leave+0xbc>
 8001d2e:	46c0      	nop			; (mov r8, r8)
 8001d30:	2000061c 	.word	0x2000061c
 8001d34:	7fffffff 	.word	0x7fffffff

08001d38 <IRQ_OVR_Set>:

void IRQ_OVR_Set(INTs_Index_t ndx, int32_t count);
int32_t IRQ_OVR_Get(INTs_Index_t ndx);
int32_t IRQ_OVR_Fired(INTs_Index_t ndx);

void IRQ_OVR_Set(INTs_Index_t ndx, int32_t count) {
 8001d38:	b570      	push	{r4, r5, r6, lr}
  
  int32_t previous_count = gINT_Stats.All_cy[ndx].nb_countdown;
 8001d3a:	4c0a      	ldr	r4, [pc, #40]	; (8001d64 <IRQ_OVR_Set+0x2c>)
 8001d3c:	00c3      	lsls	r3, r0, #3
 8001d3e:	181a      	adds	r2, r3, r0
 8001d40:	0092      	lsls	r2, r2, #2
 8001d42:	18a2      	adds	r2, r4, r2
 8001d44:	2520      	movs	r5, #32
 8001d46:	5f52      	ldrsh	r2, [r2, r5]
  gINT_Stats.All_cy[ndx].nb_countdown = count;
 8001d48:	181b      	adds	r3, r3, r0
 8001d4a:	009b      	lsls	r3, r3, #2
 8001d4c:	18e3      	adds	r3, r4, r3
 8001d4e:	8419      	strh	r1, [r3, #32]
  if((previous_count==0)&&(count>0)) { // reactivate the interrupt
 8001d50:	2a00      	cmp	r2, #0
 8001d52:	d101      	bne.n	8001d58 <IRQ_OVR_Set+0x20>
 8001d54:	2900      	cmp	r1, #0
 8001d56:	dc00      	bgt.n	8001d5a <IRQ_OVR_Set+0x22>
    NOPs(1);
  };
  
}
 8001d58:	bd70      	pop	{r4, r5, r6, pc}
    NOPs(1);
 8001d5a:	2001      	movs	r0, #1
 8001d5c:	f001 fa96 	bl	800328c <NOPs>
}
 8001d60:	e7fa      	b.n	8001d58 <IRQ_OVR_Set+0x20>
 8001d62:	46c0      	nop			; (mov r8, r8)
 8001d64:	2000061c 	.word	0x2000061c

08001d68 <IRQ_OVR_Get>:

int32_t IRQ_OVR_Get(INTs_Index_t ndx) {
 8001d68:	0003      	movs	r3, r0
  
  return gINT_Stats.All_cy[ndx].nb_countdown;
 8001d6a:	00c0      	lsls	r0, r0, #3
 8001d6c:	18c0      	adds	r0, r0, r3
 8001d6e:	0080      	lsls	r0, r0, #2
 8001d70:	4b02      	ldr	r3, [pc, #8]	; (8001d7c <IRQ_OVR_Get+0x14>)
 8001d72:	1818      	adds	r0, r3, r0
 8001d74:	2320      	movs	r3, #32
 8001d76:	5ec0      	ldrsh	r0, [r0, r3]
}
 8001d78:	4770      	bx	lr
 8001d7a:	46c0      	nop			; (mov r8, r8)
 8001d7c:	2000061c 	.word	0x2000061c

08001d80 <IRQ_OVR_Fired>:

int32_t IRQ_OVR_Fired(INTs_Index_t ndx) {
 8001d80:	b510      	push	{r4, lr}
 8001d82:	0003      	movs	r3, r0
  
  int32_t count = gINT_Stats.All_cy[ndx].nb_countdown;
 8001d84:	00c2      	lsls	r2, r0, #3
 8001d86:	1812      	adds	r2, r2, r0
 8001d88:	0092      	lsls	r2, r2, #2
 8001d8a:	490d      	ldr	r1, [pc, #52]	; (8001dc0 <IRQ_OVR_Fired+0x40>)
 8001d8c:	188a      	adds	r2, r1, r2
 8001d8e:	2120      	movs	r1, #32
 8001d90:	5e52      	ldrsh	r2, [r2, r1]
 8001d92:	1e10      	subs	r0, r2, #0
  
  if(count==0)
 8001d94:	d00b      	beq.n	8001dae <IRQ_OVR_Fired+0x2e>
    return 0;
  else
    if(count<0) {
 8001d96:	2a00      	cmp	r2, #0
 8001d98:	db0a      	blt.n	8001db0 <IRQ_OVR_Fired+0x30>
      NOPs(1);
      return 0;
    }
  else {
    // count >0
    count--;
 8001d9a:	3a01      	subs	r2, #1
    gINT_Stats.All_cy[ndx].nb_countdown = count;
 8001d9c:	00d8      	lsls	r0, r3, #3
 8001d9e:	18c3      	adds	r3, r0, r3
 8001da0:	009b      	lsls	r3, r3, #2
 8001da2:	4807      	ldr	r0, [pc, #28]	; (8001dc0 <IRQ_OVR_Fired+0x40>)
 8001da4:	18c3      	adds	r3, r0, r3
 8001da6:	841a      	strh	r2, [r3, #32]
    if(count==0) {
 8001da8:	2a00      	cmp	r2, #0
 8001daa:	d006      	beq.n	8001dba <IRQ_OVR_Fired+0x3a>
      // interrupt disable
      return 1; // time to disable the interrupt!
    }
  }
  return 0;
 8001dac:	2000      	movs	r0, #0
}
 8001dae:	bd10      	pop	{r4, pc}
      NOPs(1);
 8001db0:	2001      	movs	r0, #1
 8001db2:	f001 fa6b 	bl	800328c <NOPs>
      return 0;
 8001db6:	2000      	movs	r0, #0
 8001db8:	e7f9      	b.n	8001dae <IRQ_OVR_Fired+0x2e>
      return 1; // time to disable the interrupt!
 8001dba:	2001      	movs	r0, #1
 8001dbc:	e7f7      	b.n	8001dae <IRQ_OVR_Fired+0x2e>
 8001dbe:	46c0      	nop			; (mov r8, r8)
 8001dc0:	2000061c 	.word	0x2000061c

08001dc4 <IRQ_OVR_DemoEXTI_MainLoop_100msec>:

//============ demonstration with simple EXTI interrupt this is the protection, main loop grants credits, interrupt consumes and self disable

void IRQ_OVR_DemoEXTI_MainLoop_100msec(void) {
 8001dc4:	b510      	push	{r4, lr}

  if(IRQ_OVR_Get(EXTI0_1_INT)==0) {
 8001dc6:	2004      	movs	r0, #4
 8001dc8:	f7ff ffce 	bl	8001d68 <IRQ_OVR_Get>
 8001dcc:	2800      	cmp	r0, #0
 8001dce:	d000      	beq.n	8001dd2 <IRQ_OVR_DemoEXTI_MainLoop_100msec+0xe>
    IRQ_OVR_Set(EXTI0_1_INT, 10); // allow 10 interrupt events until next comeback here
    HAL_NVIC_EnableIRQ(EXTI0_1_IRQn); // reenable the interrupt
  }
}
 8001dd0:	bd10      	pop	{r4, pc}
    IRQ_OVR_Set(EXTI0_1_INT, 10); // allow 10 interrupt events until next comeback here
 8001dd2:	210a      	movs	r1, #10
 8001dd4:	3004      	adds	r0, #4
 8001dd6:	f7ff ffaf 	bl	8001d38 <IRQ_OVR_Set>
    HAL_NVIC_EnableIRQ(EXTI0_1_IRQn); // reenable the interrupt
 8001dda:	2005      	movs	r0, #5
 8001ddc:	f002 f936 	bl	800404c <HAL_NVIC_EnableIRQ>
}
 8001de0:	e7f6      	b.n	8001dd0 <IRQ_OVR_DemoEXTI_MainLoop_100msec+0xc>

08001de2 <EXTI0_1_IRQHandler>:

void EXTI0_1_IRQHandler(void)
{
 8001de2:	b510      	push	{r4, lr}
  INT_Enter(EXTI0_1_INT);
 8001de4:	2004      	movs	r0, #4
 8001de6:	f7ff ff27 	bl	8001c38 <INT_Enter>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0);
 8001dea:	2001      	movs	r0, #1
 8001dec:	f002 fa4c 	bl	8004288 <HAL_GPIO_EXTI_IRQHandler>
  if(IRQ_OVR_Fired(EXTI0_1_INT))
 8001df0:	2004      	movs	r0, #4
 8001df2:	f7ff ffc5 	bl	8001d80 <IRQ_OVR_Fired>
 8001df6:	2800      	cmp	r0, #0
 8001df8:	d103      	bne.n	8001e02 <EXTI0_1_IRQHandler+0x20>
    HAL_NVIC_DisableIRQ(EXTI0_1_IRQn); // disable the interrupt
  INT_Leave(EXTI0_1_INT);
 8001dfa:	2004      	movs	r0, #4
 8001dfc:	f7ff ff34 	bl	8001c68 <INT_Leave>
}
 8001e00:	bd10      	pop	{r4, pc}
    HAL_NVIC_DisableIRQ(EXTI0_1_IRQn); // disable the interrupt
 8001e02:	2005      	movs	r0, #5
 8001e04:	f002 f92e 	bl	8004064 <HAL_NVIC_DisableIRQ>
 8001e08:	e7f7      	b.n	8001dfa <EXTI0_1_IRQHandler+0x18>

08001e0a <IRQ_OVR_ProtectionEnable>:
  ConfigureClockTrimming();
  
  
}

void IRQ_OVR_ProtectionEnable(void) {
 8001e0a:	b510      	push	{r4, lr}
  
  IRQ_OVR_Set(EXTI0_1_INT, 10);
 8001e0c:	210a      	movs	r1, #10
 8001e0e:	2004      	movs	r0, #4
 8001e10:	f7ff ff92 	bl	8001d38 <IRQ_OVR_Set>
}
 8001e14:	bd10      	pop	{r4, pc}

08001e16 <IRQ_OVR_ProtectionDisable>:

void IRQ_OVR_ProtectionDisable(void) {
 8001e16:	b510      	push	{r4, lr}

  IRQ_OVR_Set(EXTI0_1_INT, -1);  
 8001e18:	2101      	movs	r1, #1
 8001e1a:	4249      	negs	r1, r1
 8001e1c:	2004      	movs	r0, #4
 8001e1e:	f7ff ff8b 	bl	8001d38 <IRQ_OVR_Set>
  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);  
 8001e22:	2005      	movs	r0, #5
 8001e24:	f002 f912 	bl	800404c <HAL_NVIC_EnableIRQ>
}
 8001e28:	bd10      	pop	{r4, pc}

08001e2a <IRQ_OVR_DemoLeave>:

void IRQ_OVR_DemoLeave(void) {
 8001e2a:	b500      	push	{lr}
 8001e2c:	b083      	sub	sp, #12
  
  HAL_NVIC_DisableIRQ(EXTI0_1_IRQn);
 8001e2e:	2005      	movs	r0, #5
 8001e30:	f002 f918 	bl	8004064 <HAL_NVIC_DisableIRQ>
  GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStructure.Pull = GPIO_NOPULL;
  GPIO_InitStructure.Pin = GPIO_PIN_2;
  GPIO_InitStructure.Alternate = 3; // MCO2
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);*/
  IO_Pad_t Pad = { PB_2, { .Mode = IO_INPUT, .Pull = IO_NOPULL, .Speed = IO_SPEED_03, .Signal = MCO2 } };
 8001e34:	a801      	add	r0, sp, #4
 8001e36:	2300      	movs	r3, #0
 8001e38:	9301      	str	r3, [sp, #4]
 8001e3a:	3312      	adds	r3, #18
 8001e3c:	7003      	strb	r3, [r0, #0]
 8001e3e:	7843      	ldrb	r3, [r0, #1]
 8001e40:	2207      	movs	r2, #7
 8001e42:	4393      	bics	r3, r2
 8001e44:	2101      	movs	r1, #1
 8001e46:	430b      	orrs	r3, r1
 8001e48:	7043      	strb	r3, [r0, #1]
 8001e4a:	b2db      	uxtb	r3, r3
 8001e4c:	2138      	movs	r1, #56	; 0x38
 8001e4e:	438b      	bics	r3, r1
 8001e50:	2108      	movs	r1, #8
 8001e52:	430b      	orrs	r3, r1
 8001e54:	7043      	strb	r3, [r0, #1]
 8001e56:	7883      	ldrb	r3, [r0, #2]
 8001e58:	4393      	bics	r3, r2
 8001e5a:	2204      	movs	r2, #4
 8001e5c:	4313      	orrs	r3, r2
 8001e5e:	7083      	strb	r3, [r0, #2]
 8001e60:	234a      	movs	r3, #74	; 0x4a
 8001e62:	70c3      	strb	r3, [r0, #3]
  IO_PadInit(&Pad);
 8001e64:	f003 fb1a 	bl	800549c <IO_PadInit>
  
}
 8001e68:	b003      	add	sp, #12
 8001e6a:	bd00      	pop	{pc}

08001e6c <ConfigureClockTrimming>:
TIM_HandleTypeDef    TRIM_TimHandle;

void HSI48_UserTrim(void);
volatile uint8_t runtrim = 0;

void ConfigureClockTrimming(void) {
 8001e6c:	b510      	push	{r4, lr}
 8001e6e:	b086      	sub	sp, #24
  GPIO_InitStructure.Pull = GPIO_NOPULL;
  GPIO_InitStructure.Pin = GPIO_PIN_14;
  GPIO_InitStructure.Alternate = 11; // 
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure); // PC14 = OSCIN32
*/
  IO_Pad_t Pad = { PC_14, { .Mode = IO_SIGNAL, .Drive = IO_PUSHPULL, .Pull = IO_NOPULL, .Speed = IO_SPEED_03, .Signal = TIM3_CH2/*11*/ } };
 8001e70:	a805      	add	r0, sp, #20
 8001e72:	2400      	movs	r4, #0
 8001e74:	9405      	str	r4, [sp, #20]
 8001e76:	232e      	movs	r3, #46	; 0x2e
 8001e78:	7003      	strb	r3, [r0, #0]
 8001e7a:	7843      	ldrb	r3, [r0, #1]
 8001e7c:	2207      	movs	r2, #7
 8001e7e:	4393      	bics	r3, r2
 8001e80:	2103      	movs	r1, #3
 8001e82:	430b      	orrs	r3, r1
 8001e84:	7043      	strb	r3, [r0, #1]
 8001e86:	b2db      	uxtb	r3, r3
 8001e88:	2138      	movs	r1, #56	; 0x38
 8001e8a:	438b      	bics	r3, r1
 8001e8c:	2108      	movs	r1, #8
 8001e8e:	430b      	orrs	r3, r1
 8001e90:	7043      	strb	r3, [r0, #1]
 8001e92:	b2d9      	uxtb	r1, r3
 8001e94:	233f      	movs	r3, #63	; 0x3f
 8001e96:	400b      	ands	r3, r1
 8001e98:	2140      	movs	r1, #64	; 0x40
 8001e9a:	430b      	orrs	r3, r1
 8001e9c:	7043      	strb	r3, [r0, #1]
 8001e9e:	7883      	ldrb	r3, [r0, #2]
 8001ea0:	4393      	bics	r3, r2
 8001ea2:	2204      	movs	r2, #4
 8001ea4:	4313      	orrs	r3, r2
 8001ea6:	7083      	strb	r3, [r0, #2]
 8001ea8:	2323      	movs	r3, #35	; 0x23
 8001eaa:	70c3      	strb	r3, [r0, #3]
  IO_PadInit(&Pad);
 8001eac:	f003 faf6 	bl	800549c <IO_PadInit>
  __HAL_RCC_TIM3_CLK_ENABLE();
 8001eb0:	4a23      	ldr	r2, [pc, #140]	; (8001f40 <ConfigureClockTrimming+0xd4>)
 8001eb2:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 8001eb4:	2302      	movs	r3, #2
 8001eb6:	4319      	orrs	r1, r3
 8001eb8:	63d1      	str	r1, [r2, #60]	; 0x3c
 8001eba:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8001ebc:	4013      	ands	r3, r2
 8001ebe:	9300      	str	r3, [sp, #0]
 8001ec0:	9b00      	ldr	r3, [sp, #0]
//  __HAL_RCC_TIM17_CLK_ENABLE();
  
/* Timer Output Compare Configuration Structure declaration */
 
  TRIM_TimHandle.Instance = TIM3;
 8001ec2:	4820      	ldr	r0, [pc, #128]	; (8001f44 <ConfigureClockTrimming+0xd8>)
 8001ec4:	4b20      	ldr	r3, [pc, #128]	; (8001f48 <ConfigureClockTrimming+0xdc>)
 8001ec6:	6003      	str	r3, [r0, #0]
  TRIM_TimHandle.Init.Prescaler         = 0; // cycle speed BASE_TIMER_CLOCK_MHZ-1; // SYSCLK = 48 MHz, timer will run at 1MHz
 8001ec8:	6044      	str	r4, [r0, #4]
  TRIM_TimHandle.Init.Period            = 0xFFFF;//999; // counter period is 1000 steps
 8001eca:	4b20      	ldr	r3, [pc, #128]	; (8001f4c <ConfigureClockTrimming+0xe0>)
 8001ecc:	60c3      	str	r3, [r0, #12]
  TRIM_TimHandle.Init.ClockDivision     = TIM_CLOCKDIVISION_DIV1;
 8001ece:	6104      	str	r4, [r0, #16]
  TRIM_TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
 8001ed0:	6084      	str	r4, [r0, #8]
  TRIM_TimHandle.Init.RepetitionCounter = 0;
 8001ed2:	6144      	str	r4, [r0, #20]
  if (HAL_TIM_IC_Init(&TRIM_TimHandle) != HAL_OK)
 8001ed4:	f002 fe62 	bl	8004b9c <HAL_TIM_IC_Init>
 8001ed8:	2800      	cmp	r0, #0
 8001eda:	d000      	beq.n	8001ede <ConfigureClockTrimming+0x72>
    // HAL_StatusTypeDef HAL_TIM_Base_Start_IT(&TRIM_TimHandle);
  { // Initialization Error 
    TrapError();
 8001edc:	e7fe      	b.n	8001edc <ConfigureClockTrimming+0x70>
  }

  TIM_IC_InitTypeDef sTRIMConfig = {
 8001ede:	2300      	movs	r3, #0
 8001ee0:	9301      	str	r3, [sp, #4]
 8001ee2:	2201      	movs	r2, #1
 8001ee4:	9202      	str	r2, [sp, #8]
 8001ee6:	9303      	str	r3, [sp, #12]
 8001ee8:	9304      	str	r3, [sp, #16]
  .ICSelection = TIM_ICSELECTION_DIRECTTI,
  .ICPrescaler =  TIM_ICPSC_DIV1,
  .ICFilter = 0,
  };
    
  if( HAL_TIM_IC_ConfigChannel(&TRIM_TimHandle, &sTRIMConfig, TIM_CHANNEL_2) != HAL_OK)  {    
 8001eea:	3203      	adds	r2, #3
 8001eec:	a901      	add	r1, sp, #4
 8001eee:	4815      	ldr	r0, [pc, #84]	; (8001f44 <ConfigureClockTrimming+0xd8>)
 8001ef0:	f002 ff8c 	bl	8004e0c <HAL_TIM_IC_ConfigChannel>
 8001ef4:	2800      	cmp	r0, #0
 8001ef6:	d000      	beq.n	8001efa <ConfigureClockTrimming+0x8e>
    TrapError();
 8001ef8:	e7fe      	b.n	8001ef8 <ConfigureClockTrimming+0x8c>
  }
  
  //HAL_TIM_Base_Start_IT() ??
  
  if (HAL_TIM_IC_Start_IT (&TRIM_TimHandle, TIM_CHANNEL_2)!= HAL_OK)    {     
 8001efa:	2104      	movs	r1, #4
 8001efc:	4811      	ldr	r0, [pc, #68]	; (8001f44 <ConfigureClockTrimming+0xd8>)
 8001efe:	f003 f88f 	bl	8005020 <HAL_TIM_IC_Start_IT>
 8001f02:	2800      	cmp	r0, #0
 8001f04:	d000      	beq.n	8001f08 <ConfigureClockTrimming+0x9c>
    TrapError();
 8001f06:	e7fe      	b.n	8001f06 <ConfigureClockTrimming+0x9a>
  }

  HAL_NVIC_DisableIRQ(TIM3_IRQn);  
 8001f08:	2010      	movs	r0, #16
 8001f0a:	f002 f8ab 	bl	8004064 <HAL_NVIC_DisableIRQ>

    /* Enable the TIM Update interrupt */ // this is to make 32 bit counter in core cycles (48MHz here)
  __HAL_TIM_ENABLE_IT(&TRIM_TimHandle, TIM_IT_UPDATE);
 8001f0e:	4b0d      	ldr	r3, [pc, #52]	; (8001f44 <ConfigureClockTrimming+0xd8>)
 8001f10:	681b      	ldr	r3, [r3, #0]
 8001f12:	68da      	ldr	r2, [r3, #12]
 8001f14:	2101      	movs	r1, #1
 8001f16:	430a      	orrs	r2, r1
 8001f18:	60da      	str	r2, [r3, #12]
  __HAL_TIM_UIFREMAP_ENABLE(&TRIM_TimHandle); // this helps making 32 bit emulated counters
 8001f1a:	6819      	ldr	r1, [r3, #0]
 8001f1c:	2280      	movs	r2, #128	; 0x80
 8001f1e:	0112      	lsls	r2, r2, #4
 8001f20:	430a      	orrs	r2, r1
 8001f22:	601a      	str	r2, [r3, #0]
  HAL_NVIC_SetPriority(TIM3_IRQn, 1, 0);
 8001f24:	2200      	movs	r2, #0
 8001f26:	2101      	movs	r1, #1
 8001f28:	2010      	movs	r0, #16
 8001f2a:	f002 f85f 	bl	8003fec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM3_IRQn);    
 8001f2e:	2010      	movs	r0, #16
 8001f30:	f002 f88c 	bl	800404c <HAL_NVIC_EnableIRQ>
  
//  HAL_NVIC_DisableIRQ(EXTI0_1_IRQn);    
//  HAL_NVIC_DisableIRQ(SysTick_IRQn);    
  //while(1);
  
  HAL_Delay(100);
 8001f34:	2064      	movs	r0, #100	; 0x64
 8001f36:	f001 fbfb 	bl	8003730 <HAL_Delay>
//  while(runtrim--)
//    HSI48_UserTrim(); // run trimming (32kHz external clock must be present!
  
}
 8001f3a:	b006      	add	sp, #24
 8001f3c:	bd10      	pop	{r4, pc}
 8001f3e:	46c0      	nop			; (mov r8, r8)
 8001f40:	40021000 	.word	0x40021000
 8001f44:	200005cc 	.word	0x200005cc
 8001f48:	40000400 	.word	0x40000400
 8001f4c:	0000ffff 	.word	0x0000ffff

08001f50 <IRQ_OVR_DemoEnter>:
void IRQ_OVR_DemoEnter(void) {
 8001f50:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f52:	46c6      	mov	lr, r8
 8001f54:	b500      	push	{lr}
 8001f56:	b082      	sub	sp, #8
  IRQ_OVR_ProtectionDisable();
 8001f58:	f7ff ff5d 	bl	8001e16 <IRQ_OVR_ProtectionDisable>
  HAL_NVIC_SetPriority(EXTI0_1_IRQn, 3, 0);
 8001f5c:	2200      	movs	r2, #0
 8001f5e:	2103      	movs	r1, #3
 8001f60:	2005      	movs	r0, #5
 8001f62:	f002 f843 	bl	8003fec <HAL_NVIC_SetPriority>
  IO_Pad_t IO_Pad = { PA_0, { .Mode = IO_INPUT, .Pull = IO_PULLUP, .Speed = IO_SPEED_03 } };
 8001f66:	ac01      	add	r4, sp, #4
 8001f68:	2700      	movs	r7, #0
 8001f6a:	9701      	str	r7, [sp, #4]
 8001f6c:	7863      	ldrb	r3, [r4, #1]
 8001f6e:	2607      	movs	r6, #7
 8001f70:	43b3      	bics	r3, r6
 8001f72:	2201      	movs	r2, #1
 8001f74:	4313      	orrs	r3, r2
 8001f76:	7063      	strb	r3, [r4, #1]
 8001f78:	b2db      	uxtb	r3, r3
 8001f7a:	2538      	movs	r5, #56	; 0x38
 8001f7c:	43ab      	bics	r3, r5
 8001f7e:	2210      	movs	r2, #16
 8001f80:	4313      	orrs	r3, r2
 8001f82:	7063      	strb	r3, [r4, #1]
 8001f84:	78a3      	ldrb	r3, [r4, #2]
 8001f86:	43b3      	bics	r3, r6
 8001f88:	2204      	movs	r2, #4
 8001f8a:	4313      	orrs	r3, r2
 8001f8c:	70a3      	strb	r3, [r4, #2]
  IO_PadInit(&IO_Pad);
 8001f8e:	0020      	movs	r0, r4
 8001f90:	f003 fa84 	bl	800549c <IO_PadInit>
  EXTI_Config_t EXTI_Config = { .Edge = EXTI_RISING_EDGE, .Trigger = EXTI_CHANNEL_TRIGGER_INTERRUPT };
 8001f94:	4b1d      	ldr	r3, [pc, #116]	; (800200c <IRQ_OVR_DemoEnter+0xbc>)
 8001f96:	781b      	ldrb	r3, [r3, #0]
 8001f98:	4698      	mov	r8, r3
  IO_PadInit(&IO_Pad);//+  
 8001f9a:	0020      	movs	r0, r4
 8001f9c:	f003 fa7e 	bl	800549c <IO_PadInit>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001fa0:	b672      	cpsid	i
  IO_EXTI_Config( IO_Pad.PadName, EXTI_Config );
 8001fa2:	2000      	movs	r0, #0
 8001fa4:	5620      	ldrsb	r0, [r4, r0]
 8001fa6:	4641      	mov	r1, r8
 8001fa8:	f003 fbbe 	bl	8005728 <IO_EXTI_Config>
  HAL_NVIC_DisableIRQ(EXTI0_1_IRQn); // disable the interrupt, it's activated later by user push button!
 8001fac:	2005      	movs	r0, #5
 8001fae:	f002 f859 	bl	8004064 <HAL_NVIC_DisableIRQ>
  IO_Pad_t Pad = { PB_2, { .Mode = IO_SIGNAL, .Drive = IO_PUSHPULL, .Pull = IO_NOPULL, .Signal = MCO2 }};
 8001fb2:	9700      	str	r7, [sp, #0]
 8001fb4:	2312      	movs	r3, #18
 8001fb6:	466a      	mov	r2, sp
 8001fb8:	7013      	strb	r3, [r2, #0]
 8001fba:	7853      	ldrb	r3, [r2, #1]
 8001fbc:	43b3      	bics	r3, r6
 8001fbe:	2203      	movs	r2, #3
 8001fc0:	4313      	orrs	r3, r2
 8001fc2:	466a      	mov	r2, sp
 8001fc4:	7053      	strb	r3, [r2, #1]
 8001fc6:	7853      	ldrb	r3, [r2, #1]
 8001fc8:	43ab      	bics	r3, r5
 8001fca:	2208      	movs	r2, #8
 8001fcc:	4313      	orrs	r3, r2
 8001fce:	466a      	mov	r2, sp
 8001fd0:	7053      	strb	r3, [r2, #1]
 8001fd2:	7852      	ldrb	r2, [r2, #1]
 8001fd4:	233f      	movs	r3, #63	; 0x3f
 8001fd6:	4013      	ands	r3, r2
 8001fd8:	2240      	movs	r2, #64	; 0x40
 8001fda:	4313      	orrs	r3, r2
 8001fdc:	466a      	mov	r2, sp
 8001fde:	7053      	strb	r3, [r2, #1]
 8001fe0:	234a      	movs	r3, #74	; 0x4a
 8001fe2:	70d3      	strb	r3, [r2, #3]
  IO_PadInit(&Pad);
 8001fe4:	4668      	mov	r0, sp
 8001fe6:	f003 fa59 	bl	800549c <IO_PadInit>
  RCC->CFGR |= (3<<20) | (3<<16); // activate MCO on HSI48 with prescaler of 8
 8001fea:	4a09      	ldr	r2, [pc, #36]	; (8002010 <IRQ_OVR_DemoEnter+0xc0>)
 8001fec:	6891      	ldr	r1, [r2, #8]
 8001fee:	23cc      	movs	r3, #204	; 0xcc
 8001ff0:	039b      	lsls	r3, r3, #14
 8001ff2:	430b      	orrs	r3, r1
 8001ff4:	6093      	str	r3, [r2, #8]
  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
 8001ff6:	2005      	movs	r0, #5
 8001ff8:	f002 f828 	bl	800404c <HAL_NVIC_EnableIRQ>
  __ASM volatile ("cpsie i" : : : "memory");
 8001ffc:	b662      	cpsie	i
  ConfigureClockTrimming();
 8001ffe:	f7ff ff35 	bl	8001e6c <ConfigureClockTrimming>
}
 8002002:	b002      	add	sp, #8
 8002004:	bc80      	pop	{r7}
 8002006:	46b8      	mov	r8, r7
 8002008:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800200a:	46c0      	nop			; (mov r8, r8)
 800200c:	08005858 	.word	0x08005858
 8002010:	40021000 	.word	0x40021000

08002014 <TIM3_IRQHandler>:

uint32_t good,bad, total;

void TIM3_IRQHandler(void);
void TIM3_IRQHandler(void) {
 8002014:	b570      	push	{r4, r5, r6, lr}

  
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(&TRIM_TimHandle, TIM_FLAG_UPDATE) != RESET)
 8002016:	4b2f      	ldr	r3, [pc, #188]	; (80020d4 <TIM3_IRQHandler+0xc0>)
 8002018:	681b      	ldr	r3, [r3, #0]
 800201a:	691a      	ldr	r2, [r3, #16]
 800201c:	07d2      	lsls	r2, r2, #31
 800201e:	d502      	bpl.n	8002026 <TIM3_IRQHandler+0x12>
  {
    if(__HAL_TIM_GET_IT_SOURCE(&TRIM_TimHandle, TIM_IT_UPDATE) != RESET)
 8002020:	68da      	ldr	r2, [r3, #12]
 8002022:	07d2      	lsls	r2, r2, #31
 8002024:	d43f      	bmi.n	80020a6 <TIM3_IRQHandler+0x92>
      __set_PRIMASK(tmp);
      return;
    }
  }
  
  INT_Enter(TIM3_INT); // if you place if after the UPDATE, you only measure the 32kHz
 8002026:	200b      	movs	r0, #11
 8002028:	f7ff fe06 	bl	8001c38 <INT_Enter>
  // if we arrive here it's for the input captures
  TIM3_IC_Before = TIM3_IC_Now;
 800202c:	4c2a      	ldr	r4, [pc, #168]	; (80020d8 <TIM3_IRQHandler+0xc4>)
 800202e:	4d2b      	ldr	r5, [pc, #172]	; (80020dc <TIM3_IRQHandler+0xc8>)
 8002030:	682b      	ldr	r3, [r5, #0]
 8002032:	6023      	str	r3, [r4, #0]
  TIM3_IC_Now = HAL_TIM_ReadCapturedValue(&TRIM_TimHandle, TIM_CHANNEL_2);//TIM3->CCR2;
 8002034:	2104      	movs	r1, #4
 8002036:	4827      	ldr	r0, [pc, #156]	; (80020d4 <TIM3_IRQHandler+0xc0>)
 8002038:	f002 fd24 	bl	8004a84 <HAL_TIM_ReadCapturedValue>
 800203c:	6028      	str	r0, [r5, #0]
//  if(TIM3_Period_Min>TIM3_Period_Max)
//    return; // this is the first valid entry, no relative calc can be done, wait for next come back...
  TIM3_Period = (uint16_t)((uint16_t) TIM3_IC_Now - (uint16_t) TIM3_IC_Before);
 800203e:	b280      	uxth	r0, r0
 8002040:	8823      	ldrh	r3, [r4, #0]
 8002042:	1ac0      	subs	r0, r0, r3
 8002044:	b280      	uxth	r0, r0
 8002046:	4b26      	ldr	r3, [pc, #152]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 8002048:	6018      	str	r0, [r3, #0]
  TIM3_Period_Max = max2(TIM3_Period, TIM3_Period_Max);
 800204a:	681a      	ldr	r2, [r3, #0]
 800204c:	4b25      	ldr	r3, [pc, #148]	; (80020e4 <TIM3_IRQHandler+0xd0>)
 800204e:	681b      	ldr	r3, [r3, #0]
 8002050:	429a      	cmp	r2, r3
 8002052:	d901      	bls.n	8002058 <TIM3_IRQHandler+0x44>
 8002054:	4b22      	ldr	r3, [pc, #136]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 8002056:	681b      	ldr	r3, [r3, #0]
 8002058:	4a22      	ldr	r2, [pc, #136]	; (80020e4 <TIM3_IRQHandler+0xd0>)
 800205a:	6013      	str	r3, [r2, #0]
  TIM3_Period_Min = min2(TIM3_Period, TIM3_Period_Min);
 800205c:	4b20      	ldr	r3, [pc, #128]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 800205e:	681a      	ldr	r2, [r3, #0]
 8002060:	4b21      	ldr	r3, [pc, #132]	; (80020e8 <TIM3_IRQHandler+0xd4>)
 8002062:	681b      	ldr	r3, [r3, #0]
 8002064:	429a      	cmp	r2, r3
 8002066:	d201      	bcs.n	800206c <TIM3_IRQHandler+0x58>
 8002068:	4b1d      	ldr	r3, [pc, #116]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 800206a:	681b      	ldr	r3, [r3, #0]
 800206c:	4a1e      	ldr	r2, [pc, #120]	; (80020e8 <TIM3_IRQHandler+0xd4>)
 800206e:	6013      	str	r3, [r2, #0]
  if(   (TIM3_Period >1480)
 8002070:	4b1b      	ldr	r3, [pc, #108]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 8002072:	681a      	ldr	r2, [r3, #0]
 8002074:	23b9      	movs	r3, #185	; 0xb9
 8002076:	00db      	lsls	r3, r3, #3
 8002078:	429a      	cmp	r2, r3
 800207a:	d805      	bhi.n	8002088 <TIM3_IRQHandler+0x74>
     || (TIM3_Period <1449)  ) {
 800207c:	4b18      	ldr	r3, [pc, #96]	; (80020e0 <TIM3_IRQHandler+0xcc>)
 800207e:	681a      	ldr	r2, [r3, #0]
 8002080:	23b5      	movs	r3, #181	; 0xb5
 8002082:	00db      	lsls	r3, r3, #3
 8002084:	429a      	cmp	r2, r3
 8002086:	d820      	bhi.n	80020ca <TIM3_IRQHandler+0xb6>
    bad++;}
 8002088:	4a18      	ldr	r2, [pc, #96]	; (80020ec <TIM3_IRQHandler+0xd8>)
 800208a:	6813      	ldr	r3, [r2, #0]
 800208c:	3301      	adds	r3, #1
 800208e:	6013      	str	r3, [r2, #0]
  else{
    good++;
  };
    
  total = bad + good;
 8002090:	4b16      	ldr	r3, [pc, #88]	; (80020ec <TIM3_IRQHandler+0xd8>)
 8002092:	681b      	ldr	r3, [r3, #0]
 8002094:	4a16      	ldr	r2, [pc, #88]	; (80020f0 <TIM3_IRQHandler+0xdc>)
 8002096:	6812      	ldr	r2, [r2, #0]
 8002098:	189b      	adds	r3, r3, r2
 800209a:	4a16      	ldr	r2, [pc, #88]	; (80020f4 <TIM3_IRQHandler+0xe0>)
 800209c:	6013      	str	r3, [r2, #0]
  
  INT_Leave(TIM3_INT); 
 800209e:	200b      	movs	r0, #11
 80020a0:	f7ff fde2 	bl	8001c68 <INT_Leave>
}
 80020a4:	bd70      	pop	{r4, r5, r6, pc}
      __HAL_TIM_CLEAR_IT(&TRIM_TimHandle, TIM_IT_UPDATE);
 80020a6:	2202      	movs	r2, #2
 80020a8:	4252      	negs	r2, r2
 80020aa:	611a      	str	r2, [r3, #16]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80020ac:	f3ef 8210 	mrs	r2, PRIMASK
      __set_PRIMASK(tmp | 1);
 80020b0:	2301      	movs	r3, #1
 80020b2:	4313      	orrs	r3, r2
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80020b4:	f383 8810 	msr	PRIMASK, r3
      gINT_Stats.tick_msb++;
 80020b8:	480f      	ldr	r0, [pc, #60]	; (80020f8 <TIM3_IRQHandler+0xe4>)
 80020ba:	21b4      	movs	r1, #180	; 0xb4
 80020bc:	0089      	lsls	r1, r1, #2
 80020be:	5843      	ldr	r3, [r0, r1]
 80020c0:	3301      	adds	r3, #1
 80020c2:	5043      	str	r3, [r0, r1]
 80020c4:	f382 8810 	msr	PRIMASK, r2
      return;
 80020c8:	e7ec      	b.n	80020a4 <TIM3_IRQHandler+0x90>
    good++;
 80020ca:	4a09      	ldr	r2, [pc, #36]	; (80020f0 <TIM3_IRQHandler+0xdc>)
 80020cc:	6813      	ldr	r3, [r2, #0]
 80020ce:	3301      	adds	r3, #1
 80020d0:	6013      	str	r3, [r2, #0]
 80020d2:	e7dd      	b.n	8002090 <TIM3_IRQHandler+0x7c>
 80020d4:	200005cc 	.word	0x200005cc
 80020d8:	200005bc 	.word	0x200005bc
 80020dc:	200005c0 	.word	0x200005c0
 80020e0:	200005c4 	.word	0x200005c4
 80020e4:	200005c8 	.word	0x200005c8
 80020e8:	200000f4 	.word	0x200000f4
 80020ec:	20000618 	.word	0x20000618
 80020f0:	200008f0 	.word	0x200008f0
 80020f4:	200008f4 	.word	0x200008f4
 80020f8:	2000061c 	.word	0x2000061c

080020fc <BriskTimedLED_Disable>:
              
static uint8_t BriskLEDsDisabled = 0;
  
//=================================

void BriskTimedLED_Disable(void) { BriskLEDsDisabled=1;}
 80020fc:	4b01      	ldr	r3, [pc, #4]	; (8002104 <BriskTimedLED_Disable+0x8>)
 80020fe:	2201      	movs	r2, #1
 8002100:	701a      	strb	r2, [r3, #0]
 8002102:	4770      	bx	lr
 8002104:	200008f8 	.word	0x200008f8

08002108 <BriskTimedLED_Enable>:
void BriskTimedLED_Enable(void) { BriskLEDsDisabled=0;}
 8002108:	4b01      	ldr	r3, [pc, #4]	; (8002110 <BriskTimedLED_Enable+0x8>)
 800210a:	2200      	movs	r2, #0
 800210c:	701a      	strb	r2, [r3, #0]
 800210e:	4770      	bx	lr
 8002110:	200008f8 	.word	0x200008f8

08002114 <LEDsConfigureTimers>:
#if 1 // PWM LED Dimmig demo enabled
TIM_HandleTypeDef    LED_TimHandle;
/* Timer Output Compare Configuration Structure declaration */
TIM_OC_InitTypeDef sConfigLED;

void LEDsConfigureTimers(TIM_TypeDef* Timer) {
 8002114:	b510      	push	{r4, lr}

  LED_TimHandle.Instance = Timer;
 8002116:	4b08      	ldr	r3, [pc, #32]	; (8002138 <LEDsConfigureTimers+0x24>)
 8002118:	6018      	str	r0, [r3, #0]
  LED_TimHandle.Init.Prescaler         = BASE_TIMER_CLOCK_MHZ-1; // SYSCLK = 48 MHz, timer will run at 1MHz
 800211a:	222f      	movs	r2, #47	; 0x2f
 800211c:	605a      	str	r2, [r3, #4]
  LED_TimHandle.Init.Period            = 999; // counter period is 1000 steps
 800211e:	4a07      	ldr	r2, [pc, #28]	; (800213c <LEDsConfigureTimers+0x28>)
 8002120:	60da      	str	r2, [r3, #12]
  LED_TimHandle.Init.ClockDivision     = 0;
 8002122:	2200      	movs	r2, #0
 8002124:	611a      	str	r2, [r3, #16]
  LED_TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
 8002126:	609a      	str	r2, [r3, #8]
  LED_TimHandle.Init.RepetitionCounter = 0;
 8002128:	615a      	str	r2, [r3, #20]
  if (HAL_TIM_PWM_Init(&LED_TimHandle) != HAL_OK)
 800212a:	0018      	movs	r0, r3
 800212c:	f002 fd06 	bl	8004b3c <HAL_TIM_PWM_Init>
 8002130:	2800      	cmp	r0, #0
 8002132:	d000      	beq.n	8002136 <LEDsConfigureTimers+0x22>
  { /* Initialization Error */
    TrapError();
 8002134:	e7fe      	b.n	8002134 <LEDsConfigureTimers+0x20>
  }
}
 8002136:	bd10      	pop	{r4, pc}
 8002138:	200008fc 	.word	0x200008fc
 800213c:	000003e7 	.word	0x000003e7

08002140 <LEDsConfigureChannel>:

void LEDsConfigureChannel(TIM_TypeDef* Timer, uint32_t TIM_CHANNEL) {
 8002140:	b510      	push	{r4, lr}
 8002142:	0003      	movs	r3, r0
 8002144:	000c      	movs	r4, r1
  
  LED_TimHandle.Instance = Timer;
 8002146:	480e      	ldr	r0, [pc, #56]	; (8002180 <LEDsConfigureChannel+0x40>)
 8002148:	6003      	str	r3, [r0, #0]

  sConfigLED.OCMode       = TIM_OCMODE_PWM1;
 800214a:	490e      	ldr	r1, [pc, #56]	; (8002184 <LEDsConfigureChannel+0x44>)
 800214c:	2360      	movs	r3, #96	; 0x60
 800214e:	600b      	str	r3, [r1, #0]
  sConfigLED.OCPolarity   = TIM_OCPOLARITY_LOW;
 8002150:	3b5e      	subs	r3, #94	; 0x5e
 8002152:	608b      	str	r3, [r1, #8]
  sConfigLED.OCFastMode   = TIM_OCFAST_DISABLE;
 8002154:	2300      	movs	r3, #0
 8002156:	610b      	str	r3, [r1, #16]
  sConfigLED.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
 8002158:	60cb      	str	r3, [r1, #12]
  sConfigLED.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 800215a:	618b      	str	r3, [r1, #24]
  sConfigLED.OCIdleState  = TIM_OCIDLESTATE_RESET;
 800215c:	614b      	str	r3, [r1, #20]
  sConfigLED.Pulse = 1;  
 800215e:	3301      	adds	r3, #1
 8002160:	604b      	str	r3, [r1, #4]
  if (HAL_TIM_PWM_ConfigChannel(&LED_TimHandle, &sConfigLED, TIM_CHANNEL ) != HAL_OK)
 8002162:	0022      	movs	r2, r4
 8002164:	f002 fd8a 	bl	8004c7c <HAL_TIM_PWM_ConfigChannel>
 8002168:	2800      	cmp	r0, #0
 800216a:	d000      	beq.n	800216e <LEDsConfigureChannel+0x2e>
  {
    TrapError();
 800216c:	e7fe      	b.n	800216c <LEDsConfigureChannel+0x2c>
  }
  
  if (HAL_TIM_PWM_Start(&LED_TimHandle, TIM_CHANNEL) != HAL_OK)
 800216e:	0021      	movs	r1, r4
 8002170:	4803      	ldr	r0, [pc, #12]	; (8002180 <LEDsConfigureChannel+0x40>)
 8002172:	f002 febf 	bl	8004ef4 <HAL_TIM_PWM_Start>
 8002176:	2800      	cmp	r0, #0
 8002178:	d000      	beq.n	800217c <LEDsConfigureChannel+0x3c>
  { /* PWM Generation Error */
    TrapError();
 800217a:	e7fe      	b.n	800217a <LEDsConfigureChannel+0x3a>
  }
  
}
 800217c:	bd10      	pop	{r4, pc}
 800217e:	46c0      	nop			; (mov r8, r8)
 8002180:	200008fc 	.word	0x200008fc
 8002184:	20000948 	.word	0x20000948

08002188 <LEDsSetDutyCycle>:

void LEDsSetDutyCycle(LED_t* pLED, uint32_t duty) {
#if 1   // PWM dimming enabled
  uint32_t TIM_CHANNEL;
  
  if(pLED->TIM==0) TrapError();
 8002188:	6843      	ldr	r3, [r0, #4]
 800218a:	2b00      	cmp	r3, #0
 800218c:	d006      	beq.n	800219c <LEDsSetDutyCycle+0x14>
  

  LED_TimHandle.Instance = pLED->TIM;
 800218e:	4a04      	ldr	r2, [pc, #16]	; (80021a0 <LEDsSetDutyCycle+0x18>)
 8002190:	6013      	str	r3, [r2, #0]
  TIM_CHANNEL = pLED->TIM_CH;

  sConfigLED.Pulse = duty;
 8002192:	4b04      	ldr	r3, [pc, #16]	; (80021a4 <LEDsSetDutyCycle+0x1c>)
 8002194:	6059      	str	r1, [r3, #4]
    TrapError();
  }
#else // TO REWORK !
  // 4hours rework cost adaptation
  // monster hack which destroys the user LED code entirely: // not scalable, not portable, not efficient
  TIM1->CCR1 = duty; // for a single hardcoded LED....
 8002196:	4b04      	ldr	r3, [pc, #16]	; (80021a8 <LEDsSetDutyCycle+0x20>)
 8002198:	6359      	str	r1, [r3, #52]	; 0x34

#endif

  
#endif  
}
 800219a:	4770      	bx	lr
  if(pLED->TIM==0) TrapError();
 800219c:	e7fe      	b.n	800219c <LEDsSetDutyCycle+0x14>
 800219e:	46c0      	nop			; (mov r8, r8)
 80021a0:	200008fc 	.word	0x200008fc
 80021a4:	20000948 	.word	0x20000948
 80021a8:	40012c00 	.word	0x40012c00

080021ac <BriskDimLED>:
void BriskDimLED(uint8_t index, int8_t percentage) {// a negative value will turn the LED OFF (toggling the sign is used for blinking implementation)
 80021ac:	b570      	push	{r4, r5, r6, lr}
 80021ae:	0004      	movs	r4, r0
 80021b0:	000d      	movs	r5, r1
  pLED = &BriskLEDs[index]; // get handle to the pointed LED element
 80021b2:	0103      	lsls	r3, r0, #4
 80021b4:	4815      	ldr	r0, [pc, #84]	; (800220c <BriskDimLED+0x60>)
 80021b6:	18c0      	adds	r0, r0, r3
  if(pLED->TIM) { // if not null, is Timer PWM dimmable
 80021b8:	6843      	ldr	r3, [r0, #4]
 80021ba:	2b00      	cmp	r3, #0
 80021bc:	d013      	beq.n	80021e6 <BriskDimLED+0x3a>
    if(percentage>100) percentage = 100; // or TrapError, clip to max 100
 80021be:	2964      	cmp	r1, #100	; 0x64
 80021c0:	dc0f      	bgt.n	80021e2 <BriskDimLED+0x36>
    if(percentage<0) LEDsSetDutyCycle(pLED, PercentToDuty[0]); // 0 to 100 becomes 0 to 1000 as log, later use a lookup table
 80021c2:	2900      	cmp	r1, #0
 80021c4:	db09      	blt.n	80021da <BriskDimLED+0x2e>
      else LEDsSetDutyCycle(pLED, PercentToDuty[percentage]); // 0 to 100 becomes 0 to 1000 as log, later use a lookup table
 80021c6:	006b      	lsls	r3, r5, #1
 80021c8:	4a11      	ldr	r2, [pc, #68]	; (8002210 <BriskDimLED+0x64>)
 80021ca:	5a99      	ldrh	r1, [r3, r2]
 80021cc:	f7ff ffdc 	bl	8002188 <LEDsSetDutyCycle>
  pLED->Dim_perc = percentage; // save the used percentage dimming value
 80021d0:	0124      	lsls	r4, r4, #4
 80021d2:	480e      	ldr	r0, [pc, #56]	; (800220c <BriskDimLED+0x60>)
 80021d4:	1904      	adds	r4, r0, r4
 80021d6:	7325      	strb	r5, [r4, #12]
}
 80021d8:	bd70      	pop	{r4, r5, r6, pc}
    if(percentage<0) LEDsSetDutyCycle(pLED, PercentToDuty[0]); // 0 to 100 becomes 0 to 1000 as log, later use a lookup table
 80021da:	2100      	movs	r1, #0
 80021dc:	f7ff ffd4 	bl	8002188 <LEDsSetDutyCycle>
 80021e0:	e7f6      	b.n	80021d0 <BriskDimLED+0x24>
    if(percentage>100) percentage = 100; // or TrapError, clip to max 100
 80021e2:	2564      	movs	r5, #100	; 0x64
 80021e4:	e7ef      	b.n	80021c6 <BriskDimLED+0x1a>
    if(percentage<50){ // Turn LED OFF
 80021e6:	2931      	cmp	r1, #49	; 0x31
 80021e8:	dc07      	bgt.n	80021fa <BriskDimLED+0x4e>
      IO_PadSetHigh(pLED->pPad->PadName);
 80021ea:	0123      	lsls	r3, r4, #4
 80021ec:	4a07      	ldr	r2, [pc, #28]	; (800220c <BriskDimLED+0x60>)
 80021ee:	589b      	ldr	r3, [r3, r2]
 80021f0:	2000      	movs	r0, #0
 80021f2:	5618      	ldrsb	r0, [r3, r0]
 80021f4:	f003 fa60 	bl	80056b8 <IO_PadSetHigh>
 80021f8:	e7ea      	b.n	80021d0 <BriskDimLED+0x24>
      IO_PadSetLow(pLED->pPad->PadName);
 80021fa:	0123      	lsls	r3, r4, #4
 80021fc:	4a03      	ldr	r2, [pc, #12]	; (800220c <BriskDimLED+0x60>)
 80021fe:	589b      	ldr	r3, [r3, r2]
 8002200:	2000      	movs	r0, #0
 8002202:	5618      	ldrsb	r0, [r3, r0]
 8002204:	f003 fa66 	bl	80056d4 <IO_PadSetLow>
 8002208:	e7e2      	b.n	80021d0 <BriskDimLED+0x24>
 800220a:	46c0      	nop			; (mov r8, r8)
 800220c:	200000f8 	.word	0x200000f8
 8002210:	08006088 	.word	0x08006088

08002214 <BriskTimedLED_10msecTick>:
    { &BriskLEDs[0], 0, 0, 0,  0, 0,   },
    { &BriskLEDs[1], 0, 0, 0,  0, 0,   },
  };


void BriskTimedLED_10msecTick(void) { // should be called from main loop. not timing critical.
 8002214:	b510      	push	{r4, lr}
  
  uint8_t index;
  TimedLED_t* pTimedLED;
  
  // coming here every 10msec 
  for(index=1;index<LED_COUNT;index++) {
 8002216:	2401      	movs	r4, #1
 8002218:	e03b      	b.n	8002292 <BriskTimedLED_10msecTick+0x7e>
    
    pTimedLED = &BriskTimedLEDs[index];
 800221a:	0022      	movs	r2, r4
    if(pTimedLED->Blink_Countdown_x10ms==0) continue; // if countdown is zero, do nothing
 800221c:	0063      	lsls	r3, r4, #1
 800221e:	191b      	adds	r3, r3, r4
 8002220:	0099      	lsls	r1, r3, #2
 8002222:	4b23      	ldr	r3, [pc, #140]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 8002224:	185b      	adds	r3, r3, r1
 8002226:	891b      	ldrh	r3, [r3, #8]
 8002228:	2b00      	cmp	r3, #0
 800222a:	d030      	beq.n	800228e <BriskTimedLED_10msecTick+0x7a>
    // countdown is non zero. decrement it.
    pTimedLED->Blink_Countdown_x10ms--;
 800222c:	3b01      	subs	r3, #1
 800222e:	b29b      	uxth	r3, r3
 8002230:	0061      	lsls	r1, r4, #1
 8002232:	1909      	adds	r1, r1, r4
 8002234:	0088      	lsls	r0, r1, #2
 8002236:	491e      	ldr	r1, [pc, #120]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 8002238:	1809      	adds	r1, r1, r0
 800223a:	810b      	strh	r3, [r1, #8]
    if(pTimedLED->Blink_Countdown_x10ms==0) { // cycle completed
 800223c:	2b00      	cmp	r3, #0
 800223e:	d119      	bne.n	8002274 <BriskTimedLED_10msecTick+0x60>
      if(pTimedLED->Blink_Countdown==0) continue; // no more blink pulse needed
 8002240:	4b1b      	ldr	r3, [pc, #108]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 8002242:	181b      	adds	r3, r3, r0
 8002244:	7a9b      	ldrb	r3, [r3, #10]
 8002246:	2b00      	cmp	r3, #0
 8002248:	d021      	beq.n	800228e <BriskTimedLED_10msecTick+0x7a>
      // blink pulse needed
      if(pTimedLED->Blink_Countdown!=BRISK_LED_BLINK_FOREVER) pTimedLED->Blink_Countdown--; // if not infinite blinking, countdown, another pulse to run
 800224a:	2bff      	cmp	r3, #255	; 0xff
 800224c:	d003      	beq.n	8002256 <BriskTimedLED_10msecTick+0x42>
 800224e:	4918      	ldr	r1, [pc, #96]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 8002250:	1809      	adds	r1, r1, r0
 8002252:	3b01      	subs	r3, #1
 8002254:	728b      	strb	r3, [r1, #10]
      if(pTimedLED->Blink_Countdown) pTimedLED->Blink_Countdown_x10ms = pTimedLED->Blink_Period_x10ms;
 8002256:	0053      	lsls	r3, r2, #1
 8002258:	189b      	adds	r3, r3, r2
 800225a:	0099      	lsls	r1, r3, #2
 800225c:	4b14      	ldr	r3, [pc, #80]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 800225e:	185b      	adds	r3, r3, r1
 8002260:	7a9b      	ldrb	r3, [r3, #10]
 8002262:	2b00      	cmp	r3, #0
 8002264:	d006      	beq.n	8002274 <BriskTimedLED_10msecTick+0x60>
 8002266:	0051      	lsls	r1, r2, #1
 8002268:	1889      	adds	r1, r1, r2
 800226a:	0088      	lsls	r0, r1, #2
 800226c:	4b10      	ldr	r3, [pc, #64]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 800226e:	181b      	adds	r3, r3, r0
 8002270:	8899      	ldrh	r1, [r3, #4]
 8002272:	8119      	strh	r1, [r3, #8]
    };
    
    // update the LED on/off dimming (refresh every 10 msec in case of dynamic/ISR change or ESD glitch)
    if(pTimedLED->Blink_Countdown_x10ms<=pTimedLED->Blink_OffTime_x10ms) { // Set LED OFF
 8002274:	0051      	lsls	r1, r2, #1
 8002276:	1889      	adds	r1, r1, r2
 8002278:	0088      	lsls	r0, r1, #2
 800227a:	4b0d      	ldr	r3, [pc, #52]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 800227c:	181b      	adds	r3, r3, r0
 800227e:	8919      	ldrh	r1, [r3, #8]
 8002280:	88db      	ldrh	r3, [r3, #6]
 8002282:	4299      	cmp	r1, r3
 8002284:	d808      	bhi.n	8002298 <BriskTimedLED_10msecTick+0x84>
      BriskDimLED(index, 0);
 8002286:	2100      	movs	r1, #0
 8002288:	0020      	movs	r0, r4
 800228a:	f7ff ff8f 	bl	80021ac <BriskDimLED>
  for(index=1;index<LED_COUNT;index++) {
 800228e:	3401      	adds	r4, #1
 8002290:	b2e4      	uxtb	r4, r4
 8002292:	2c01      	cmp	r4, #1
 8002294:	d9c1      	bls.n	800221a <BriskTimedLED_10msecTick+0x6>
      BriskDimLED(index, pTimedLED->Dim_perc);
    };
    
  }; // for
  
}
 8002296:	bd10      	pop	{r4, pc}
      BriskDimLED(index, pTimedLED->Dim_perc);
 8002298:	0053      	lsls	r3, r2, #1
 800229a:	189a      	adds	r2, r3, r2
 800229c:	0091      	lsls	r1, r2, #2
 800229e:	4b04      	ldr	r3, [pc, #16]	; (80022b0 <BriskTimedLED_10msecTick+0x9c>)
 80022a0:	185b      	adds	r3, r3, r1
 80022a2:	210b      	movs	r1, #11
 80022a4:	5659      	ldrsb	r1, [r3, r1]
 80022a6:	0020      	movs	r0, r4
 80022a8:	f7ff ff80 	bl	80021ac <BriskDimLED>
 80022ac:	e7ef      	b.n	800228e <BriskTimedLED_10msecTick+0x7a>
 80022ae:	46c0      	nop			; (mov r8, r8)
 80022b0:	20000118 	.word	0x20000118

080022b4 <BriskDimTimedLED>:

// now here is the function to set the parameters including timings
void BriskDimTimedLED(uint8_t index, int8_t percentage) { // static, blinking disabled
 80022b4:	b570      	push	{r4, r5, r6, lr}
  
  if(BriskLEDsDisabled==1) return;
 80022b6:	4b09      	ldr	r3, [pc, #36]	; (80022dc <BriskDimTimedLED+0x28>)
 80022b8:	781b      	ldrb	r3, [r3, #0]
 80022ba:	2b01      	cmp	r3, #1
 80022bc:	d00c      	beq.n	80022d8 <BriskDimTimedLED+0x24>
    
  TimedLED_t* pTimedLED = &BriskTimedLEDs[index];
  if(percentage>100) TrapError();
 80022be:	2964      	cmp	r1, #100	; 0x64
 80022c0:	dd00      	ble.n	80022c4 <BriskDimTimedLED+0x10>
 80022c2:	e7fe      	b.n	80022c2 <BriskDimTimedLED+0xe>
  pTimedLED->Blink_Countdown_x10ms = 0; // disable all blinking
 80022c4:	4c06      	ldr	r4, [pc, #24]	; (80022e0 <BriskDimTimedLED+0x2c>)
 80022c6:	0043      	lsls	r3, r0, #1
 80022c8:	181a      	adds	r2, r3, r0
 80022ca:	0092      	lsls	r2, r2, #2
 80022cc:	18a2      	adds	r2, r4, r2
 80022ce:	2500      	movs	r5, #0
 80022d0:	8115      	strh	r5, [r2, #8]
  pTimedLED->Dim_perc = percentage;
 80022d2:	72d1      	strb	r1, [r2, #11]
  BriskDimLED(index, percentage);
 80022d4:	f7ff ff6a 	bl	80021ac <BriskDimLED>
}
 80022d8:	bd70      	pop	{r4, r5, r6, pc}
 80022da:	46c0      	nop			; (mov r8, r8)
 80022dc:	200008f8 	.word	0x200008f8
 80022e0:	20000118 	.word	0x20000118

080022e4 <BriskBlinkTimedLED>:

// use this function AFTER setting the dimming. Subject to change.
void BriskBlinkTimedLED(uint8_t index, uint16_t Blink_Period_ms, uint16_t Blink_OffTime_ms, uint8_t Blink_Countdown ) {
 80022e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80022e6:	46ce      	mov	lr, r9
 80022e8:	b500      	push	{lr}
 80022ea:	b082      	sub	sp, #8
 80022ec:	0006      	movs	r6, r0
 80022ee:	000c      	movs	r4, r1
 80022f0:	0010      	movs	r0, r2
 80022f2:	9301      	str	r3, [sp, #4]
  
  TimedLED_t* pTimedLED = &BriskTimedLEDs[index];
  if(BriskLEDsDisabled==1) return;
 80022f4:	490e      	ldr	r1, [pc, #56]	; (8002330 <BriskBlinkTimedLED+0x4c>)
 80022f6:	7809      	ldrb	r1, [r1, #0]
 80022f8:	2901      	cmp	r1, #1
 80022fa:	d014      	beq.n	8002326 <BriskBlinkTimedLED+0x42>
  
  if(Blink_OffTime_ms>Blink_Period_ms) TrapError();
 80022fc:	42a2      	cmp	r2, r4
 80022fe:	d900      	bls.n	8002302 <BriskBlinkTimedLED+0x1e>
 8002300:	e7fe      	b.n	8002300 <BriskBlinkTimedLED+0x1c>
  
  pTimedLED->Blink_OffTime_x10ms = (Blink_OffTime_ms)/10;
 8002302:	4d0c      	ldr	r5, [pc, #48]	; (8002334 <BriskBlinkTimedLED+0x50>)
 8002304:	0073      	lsls	r3, r6, #1
 8002306:	199f      	adds	r7, r3, r6
 8002308:	00bf      	lsls	r7, r7, #2
 800230a:	19ef      	adds	r7, r5, r7
 800230c:	210a      	movs	r1, #10
 800230e:	f7fd fefb 	bl	8000108 <__udivsi3>
 8002312:	80f8      	strh	r0, [r7, #6]
  pTimedLED->Blink_Countdown = Blink_Countdown;
 8002314:	9b01      	ldr	r3, [sp, #4]
 8002316:	72bb      	strb	r3, [r7, #10]
  //pTimedLED->Dim_perc = pTimedLED->pLED->Dim_perc; // we backup the chosen dimming
  pTimedLED->Blink_Period_x10ms = (Blink_Period_ms)/10;
 8002318:	210a      	movs	r1, #10
 800231a:	0020      	movs	r0, r4
 800231c:	f7fd fef4 	bl	8000108 <__udivsi3>
 8002320:	b280      	uxth	r0, r0
 8002322:	80b8      	strh	r0, [r7, #4]
  pTimedLED->Blink_Countdown_x10ms = pTimedLED->Blink_Period_x10ms; // this will trigger the ISR handling of the LED
 8002324:	8138      	strh	r0, [r7, #8]
  
}
 8002326:	b002      	add	sp, #8
 8002328:	bc80      	pop	{r7}
 800232a:	46b9      	mov	r9, r7
 800232c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800232e:	46c0      	nop			; (mov r8, r8)
 8002330:	200008f8 	.word	0x200008f8
 8002334:	20000118 	.word	0x20000118

08002338 <BriskTestLEDs>:
  BriskLEDsInit();
}

uint32_t gLED_TestCounter = 0;

void BriskTestLEDs(void) {
 8002338:	b570      	push	{r4, r5, r6, lr}

    uint8_t i;
    uint32_t duty;
 // skip the test    
#if 1    
     for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 800233a:	2401      	movs	r4, #1
 800233c:	2c01      	cmp	r4, #1
 800233e:	d90c      	bls.n	800235a <BriskTestLEDs+0x22>
        BriskDimTimedLED(i, BRISK_LED_OFF);
 
     for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 8002340:	2401      	movs	r4, #1
 8002342:	2c01      	cmp	r4, #1
 8002344:	d813      	bhi.n	800236e <BriskTestLEDs+0x36>
        BriskDimTimedLED(i, BRISK_LED_ON);
 8002346:	2164      	movs	r1, #100	; 0x64
 8002348:	0020      	movs	r0, r4
 800234a:	f7ff ffb3 	bl	80022b4 <BriskDimTimedLED>
     for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 800234e:	3401      	adds	r4, #1
 8002350:	b2e4      	uxtb	r4, r4
 8002352:	200f      	movs	r0, #15
 8002354:	f001 f9ec 	bl	8003730 <HAL_Delay>
 8002358:	e7f3      	b.n	8002342 <BriskTestLEDs+0xa>
        BriskDimTimedLED(i, BRISK_LED_OFF);
 800235a:	2100      	movs	r1, #0
 800235c:	0020      	movs	r0, r4
 800235e:	f7ff ffa9 	bl	80022b4 <BriskDimTimedLED>
     for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 8002362:	3401      	adds	r4, #1
 8002364:	b2e4      	uxtb	r4, r4
 8002366:	200f      	movs	r0, #15
 8002368:	f001 f9e2 	bl	8003730 <HAL_Delay>
 800236c:	e7e6      	b.n	800233c <BriskTestLEDs+0x4>
      
      for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 800236e:	2401      	movs	r4, #1
 8002370:	2c01      	cmp	r4, #1
 8002372:	d90a      	bls.n	800238a <BriskTestLEDs+0x52>
        BriskDimTimedLED(i, BRISK_LED_OFF);
//while(1) {     
      for(duty=0;duty<=100;duty++, HAL_Delay(5)) {
 8002374:	2500      	movs	r5, #0
 8002376:	2d64      	cmp	r5, #100	; 0x64
 8002378:	d818      	bhi.n	80023ac <BriskTestLEDs+0x74>
        for(i=1;i<LED_COUNT;i++)
 800237a:	2401      	movs	r4, #1
 800237c:	2c01      	cmp	r4, #1
 800237e:	d90e      	bls.n	800239e <BriskTestLEDs+0x66>
      for(duty=0;duty<=100;duty++, HAL_Delay(5)) {
 8002380:	3501      	adds	r5, #1
 8002382:	2005      	movs	r0, #5
 8002384:	f001 f9d4 	bl	8003730 <HAL_Delay>
 8002388:	e7f5      	b.n	8002376 <BriskTestLEDs+0x3e>
        BriskDimTimedLED(i, BRISK_LED_OFF);
 800238a:	2100      	movs	r1, #0
 800238c:	0020      	movs	r0, r4
 800238e:	f7ff ff91 	bl	80022b4 <BriskDimTimedLED>
      for(i=1;i<LED_COUNT;i++, HAL_Delay(15))
 8002392:	3401      	adds	r4, #1
 8002394:	b2e4      	uxtb	r4, r4
 8002396:	200f      	movs	r0, #15
 8002398:	f001 f9ca 	bl	8003730 <HAL_Delay>
 800239c:	e7e8      	b.n	8002370 <BriskTestLEDs+0x38>
          BriskDimTimedLED(i,duty);
 800239e:	b269      	sxtb	r1, r5
 80023a0:	0020      	movs	r0, r4
 80023a2:	f7ff ff87 	bl	80022b4 <BriskDimTimedLED>
        for(i=1;i<LED_COUNT;i++)
 80023a6:	3401      	adds	r4, #1
 80023a8:	b2e4      	uxtb	r4, r4
 80023aa:	e7e7      	b.n	800237c <BriskTestLEDs+0x44>
      }
      

      for(duty=0;duty<=100;duty++, HAL_Delay(5)) {
 80023ac:	2500      	movs	r5, #0
 80023ae:	2d64      	cmp	r5, #100	; 0x64
 80023b0:	d810      	bhi.n	80023d4 <BriskTestLEDs+0x9c>
        for(i=1;i<LED_COUNT;i++)
 80023b2:	2401      	movs	r4, #1
 80023b4:	2c01      	cmp	r4, #1
 80023b6:	d904      	bls.n	80023c2 <BriskTestLEDs+0x8a>
      for(duty=0;duty<=100;duty++, HAL_Delay(5)) {
 80023b8:	3501      	adds	r5, #1
 80023ba:	2005      	movs	r0, #5
 80023bc:	f001 f9b8 	bl	8003730 <HAL_Delay>
 80023c0:	e7f5      	b.n	80023ae <BriskTestLEDs+0x76>
          BriskDimTimedLED(i,100-duty);
 80023c2:	2164      	movs	r1, #100	; 0x64
 80023c4:	1b49      	subs	r1, r1, r5
 80023c6:	b249      	sxtb	r1, r1
 80023c8:	0020      	movs	r0, r4
 80023ca:	f7ff ff73 	bl	80022b4 <BriskDimTimedLED>
        for(i=1;i<LED_COUNT;i++)
 80023ce:	3401      	adds	r4, #1
 80023d0:	b2e4      	uxtb	r4, r4
 80023d2:	e7ef      	b.n	80023b4 <BriskTestLEDs+0x7c>
          
    }/*else
    
    */
#endif    
}
 80023d4:	bd70      	pop	{r4, r5, r6, pc}
	...

080023d8 <BriskLEDsInit>:
void BriskLEDsInit(void) { // Initialize all LEDs as output
 80023d8:	b570      	push	{r4, r5, r6, lr}
 80023da:	b082      	sub	sp, #8
  for(index=1;index<LED_COUNT;index++) {
 80023dc:	2401      	movs	r4, #1
 80023de:	2c01      	cmp	r4, #1
 80023e0:	d903      	bls.n	80023ea <BriskLEDsInit+0x12>
  BriskTestLEDs();
 80023e2:	f7ff ffa9 	bl	8002338 <BriskTestLEDs>
}
 80023e6:	b002      	add	sp, #8
 80023e8:	bd70      	pop	{r4, r5, r6, pc}
    IO_PadInit((IO_Pad_t*)pLED->pPad);
 80023ea:	4d0f      	ldr	r5, [pc, #60]	; (8002428 <BriskLEDsInit+0x50>)
 80023ec:	0126      	lsls	r6, r4, #4
 80023ee:	5970      	ldr	r0, [r6, r5]
 80023f0:	f003 f854 	bl	800549c <IO_PadInit>
    if(pLED->TIM) { // if not null
 80023f4:	19ad      	adds	r5, r5, r6
 80023f6:	6868      	ldr	r0, [r5, #4]
 80023f8:	2800      	cmp	r0, #0
 80023fa:	d011      	beq.n	8002420 <BriskLEDsInit+0x48>
      __HAL_RCC_TIM1_CLK_ENABLE();
 80023fc:	4a0b      	ldr	r2, [pc, #44]	; (800242c <BriskLEDsInit+0x54>)
 80023fe:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002400:	2580      	movs	r5, #128	; 0x80
 8002402:	012d      	lsls	r5, r5, #4
 8002404:	4329      	orrs	r1, r5
 8002406:	6411      	str	r1, [r2, #64]	; 0x40
 8002408:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800240a:	402b      	ands	r3, r5
 800240c:	9301      	str	r3, [sp, #4]
 800240e:	9b01      	ldr	r3, [sp, #4]
      LEDsConfigureTimers(pLED->TIM);
 8002410:	f7ff fe80 	bl	8002114 <LEDsConfigureTimers>
      LEDsConfigureChannel(pLED->TIM, pLED->TIM_CH);
 8002414:	4b04      	ldr	r3, [pc, #16]	; (8002428 <BriskLEDsInit+0x50>)
 8002416:	199b      	adds	r3, r3, r6
 8002418:	6899      	ldr	r1, [r3, #8]
 800241a:	6858      	ldr	r0, [r3, #4]
 800241c:	f7ff fe90 	bl	8002140 <LEDsConfigureChannel>
  for(index=1;index<LED_COUNT;index++) {
 8002420:	3401      	adds	r4, #1
 8002422:	b2e4      	uxtb	r4, r4
 8002424:	e7db      	b.n	80023de <BriskLEDsInit+0x6>
 8002426:	46c0      	nop			; (mov r8, r8)
 8002428:	200000f8 	.word	0x200000f8
 800242c:	40021000 	.word	0x40021000

08002430 <BriskTimedLEDsInit>:
void BriskTimedLEDsInit(void) {
 8002430:	b510      	push	{r4, lr}
  BriskLEDsInit();
 8002432:	f7ff ffd1 	bl	80023d8 <BriskLEDsInit>
}
 8002436:	bd10      	pop	{r4, pc}

08002438 <Is_EEP_Detected>:

uint8_t	EEP_WaitWriteCompletion(EEP_t* pEEP);
static uint8_t EEP_PageWriteBytes (EEP_t* pEEP, uint16_t Adr, uint8_t* ptr, uint16_t Count);

uint8_t Is_EEP_Detected(EEP_t* pEEP)
{
 8002438:	b510      	push	{r4, lr}
 800243a:	0004      	movs	r4, r0
  uint8_t Present = I2C_MasterIO_IsSlavePresent(pEEP->pDevice) && I2C_MasterIO_IsSlavePresent(pEEP->pDeviceID);
 800243c:	6800      	ldr	r0, [r0, #0]
 800243e:	f7ff fb66 	bl	8001b0e <I2C_MasterIO_IsSlavePresent>
 8002442:	2800      	cmp	r0, #0
 8002444:	d103      	bne.n	800244e <Is_EEP_Detected+0x16>
 8002446:	2000      	movs	r0, #0
 8002448:	b2c0      	uxtb	r0, r0
  
  pEEP->IsAvailable = Present; // keep a trace
 800244a:	7220      	strb	r0, [r4, #8]
  
  return Present;
}
 800244c:	bd10      	pop	{r4, pc}
  uint8_t Present = I2C_MasterIO_IsSlavePresent(pEEP->pDevice) && I2C_MasterIO_IsSlavePresent(pEEP->pDeviceID);
 800244e:	6860      	ldr	r0, [r4, #4]
 8002450:	f7ff fb5d 	bl	8001b0e <I2C_MasterIO_IsSlavePresent>
 8002454:	2800      	cmp	r0, #0
 8002456:	d001      	beq.n	800245c <Is_EEP_Detected+0x24>
 8002458:	2001      	movs	r0, #1
 800245a:	e7f5      	b.n	8002448 <Is_EEP_Detected+0x10>
 800245c:	2000      	movs	r0, #0
 800245e:	e7f3      	b.n	8002448 <Is_EEP_Detected+0x10>

08002460 <EEP_WaitWriteCompletion>:
/*\
| | Generic unoptimized. To optimize poll the eeprom and wait for it to ack
\*/

uint8_t	EEP_WaitWriteCompletion(EEP_t* pEEP)	// TRUE = OK, FALSE = NG
{
 8002460:	b510      	push	{r4, lr}
//HAL_Delay(MAX_WRITE_CYCLE_MS); // ADAPT_HERE
  NOPs(MAX_WRITE_CYCLE_MS * SYS_CLK_MHZ * 1000 / 2 ); // crude, should work.
 8002462:	4802      	ldr	r0, [pc, #8]	; (800246c <EEP_WaitWriteCompletion+0xc>)
 8002464:	f000 ff12 	bl	800328c <NOPs>
      return TRUE;
    HAL_Delay(1);//this function may be called while interrupts are disabled.
    countdown--;
  }
  return FALSE; */
}
 8002468:	2001      	movs	r0, #1
 800246a:	bd10      	pop	{r4, pc}
 800246c:	0001d4c0 	.word	0x0001d4c0

08002470 <EEP_ReadID>:
  result =  I2C_MasterIO_AccessSlave(pDevice);
  return result;
}

uint8_t EEP_ReadID (EEP_t* pEEP)	
{
 8002470:	b510      	push	{r4, lr}
 8002472:	0003      	movs	r3, r0
//  uint8_t RetryCount = MAX_RETRIALS_ON_ERROR;
//  uint8_t i;
  uint32_t result;
  I2C_SlaveDevice_t* pDevice = pEEP->pDeviceID;
 8002474:	6840      	ldr	r0, [r0, #4]

  pDevice->SubAdrBytes[0] = 0x00;// msb
 8002476:	2200      	movs	r2, #0
 8002478:	7182      	strb	r2, [r0, #6]
  pDevice->SubAdrBytes[1] = 0x00;// lsb;
 800247a:	71c2      	strb	r2, [r0, #7]
  pDevice->pWriteByte = 0;
 800247c:	60c2      	str	r2, [r0, #12]
  pDevice->WriteByteCount = 0; // no data write
 800247e:	8202      	strh	r2, [r0, #16]
  pDevice->pReadByte = pEEP->ID_Page;
 8002480:	3309      	adds	r3, #9
 8002482:	6143      	str	r3, [r0, #20]
  pDevice->ReadByteCount = EEPPAGESIZE_BYTE;
 8002484:	2340      	movs	r3, #64	; 0x40
 8002486:	8303      	strh	r3, [r0, #24]
  result =  I2C_MasterIO_AccessSlave(pDevice);
 8002488:	f7ff fab2 	bl	80019f0 <I2C_MasterIO_AccessSlave>
  return result;
 800248c:	b2c0      	uxtb	r0, r0
}
 800248e:	bd10      	pop	{r4, pc}

08002490 <EEP_WriteID>:

uint8_t EEP_WriteID (EEP_t* pEEP) {
 8002490:	b530      	push	{r4, r5, lr}
 8002492:	b091      	sub	sp, #68	; 0x44
 8002494:	0004      	movs	r4, r0

  //uint8_t RetryCount = MAX_RETRIALS_ON_ERROR;
  uint8_t i,buf[EEPPAGESIZE_BYTE];
  uint8_t result = 1;
  I2C_SlaveDevice_t* pDevice = pEEP->pDeviceID;
 8002496:	6840      	ldr	r0, [r0, #4]

  pDevice->SubAdrBytes[0] = 0x00;// msb
 8002498:	2300      	movs	r3, #0
 800249a:	7183      	strb	r3, [r0, #6]
  pDevice->SubAdrBytes[1] = 0x00;// lsb;
 800249c:	71c3      	strb	r3, [r0, #7]
  pDevice->pWriteByte = pEEP->ID_Page;
 800249e:	0022      	movs	r2, r4
 80024a0:	3209      	adds	r2, #9
 80024a2:	60c2      	str	r2, [r0, #12]
  pDevice->WriteByteCount = EEPPAGESIZE_BYTE; // no data write
 80024a4:	2240      	movs	r2, #64	; 0x40
 80024a6:	8202      	strh	r2, [r0, #16]
  pDevice->pReadByte = 0;
 80024a8:	6143      	str	r3, [r0, #20]
  pDevice->ReadByteCount = 0;
 80024aa:	8303      	strh	r3, [r0, #24]
  result =  I2C_MasterIO_AccessSlave(pDevice);
 80024ac:	f7ff faa0 	bl	80019f0 <I2C_MasterIO_AccessSlave>
 80024b0:	b2c5      	uxtb	r5, r0
  //
  EEP_WaitWriteCompletion(pEEP); // to mature
 80024b2:	0020      	movs	r0, r4
 80024b4:	f7ff ffd4 	bl	8002460 <EEP_WaitWriteCompletion>
  for(i=0;i<EEPPAGESIZE_BYTE;i++) // backup original
 80024b8:	2300      	movs	r3, #0
 80024ba:	2b3f      	cmp	r3, #63	; 0x3f
 80024bc:	d806      	bhi.n	80024cc <EEP_WriteID+0x3c>
    buf[i] = pEEP->ID_Page[i];
 80024be:	18e2      	adds	r2, r4, r3
 80024c0:	7a52      	ldrb	r2, [r2, #9]
 80024c2:	4669      	mov	r1, sp
 80024c4:	54ca      	strb	r2, [r1, r3]
  for(i=0;i<EEPPAGESIZE_BYTE;i++) // backup original
 80024c6:	3301      	adds	r3, #1
 80024c8:	b2db      	uxtb	r3, r3
 80024ca:	e7f6      	b.n	80024ba <EEP_WriteID+0x2a>
  
  // verify
  EEP_ReadID (pEEP);
 80024cc:	0020      	movs	r0, r4
 80024ce:	f7ff ffcf 	bl	8002470 <EEP_ReadID>
  for(i=0;i<EEPPAGESIZE_BYTE;i++) {
 80024d2:	2300      	movs	r3, #0
 80024d4:	2b3f      	cmp	r3, #63	; 0x3f
 80024d6:	d80a      	bhi.n	80024ee <EEP_WriteID+0x5e>
    if(buf[i] != pEEP->ID_Page[i])
 80024d8:	466a      	mov	r2, sp
 80024da:	5cd2      	ldrb	r2, [r2, r3]
 80024dc:	18e1      	adds	r1, r4, r3
 80024de:	7a49      	ldrb	r1, [r1, #9]
 80024e0:	428a      	cmp	r2, r1
 80024e2:	d104      	bne.n	80024ee <EEP_WriteID+0x5e>
      break;
    pEEP->ID_Page[i] = buf[i];
 80024e4:	18e1      	adds	r1, r4, r3
 80024e6:	724a      	strb	r2, [r1, #9]
  for(i=0;i<EEPPAGESIZE_BYTE;i++) {
 80024e8:	3301      	adds	r3, #1
 80024ea:	b2db      	uxtb	r3, r3
 80024ec:	e7f2      	b.n	80024d4 <EEP_WriteID+0x44>
  };
  if(i != EEPPAGESIZE_BYTE)
 80024ee:	2b40      	cmp	r3, #64	; 0x40
 80024f0:	d000      	beq.n	80024f4 <EEP_WriteID+0x64>
    TrapError(); // warning for hot plug (not supposed to happen for ID Page)
 80024f2:	e7fe      	b.n	80024f2 <EEP_WriteID+0x62>

  return result; // if 0 : writing failed
}
 80024f4:	0028      	movs	r0, r5
 80024f6:	b011      	add	sp, #68	; 0x44
 80024f8:	bd30      	pop	{r4, r5, pc}

080024fa <EEP_SetID_Page>:
  
  }
  */
}

uint8_t EEP_SetID_Page(EEP_t* pEEP, char* pStringID) {
 80024fa:	b510      	push	{r4, lr}
  
  uint16_t i;
  if(pStringID==0) TrapError();
 80024fc:	2900      	cmp	r1, #0
 80024fe:	d00b      	beq.n	8002518 <EEP_SetID_Page+0x1e>
  
  for(i=0;i<EEPPAGESIZE_BYTE;i++,pStringID++) {
 8002500:	2300      	movs	r3, #0
 8002502:	2b3f      	cmp	r3, #63	; 0x3f
 8002504:	d809      	bhi.n	800251a <EEP_SetID_Page+0x20>
    pEEP->ID_Page[i] = *pStringID;
 8002506:	780a      	ldrb	r2, [r1, #0]
 8002508:	18c4      	adds	r4, r0, r3
 800250a:	7262      	strb	r2, [r4, #9]
    if(*pStringID==0) break;
 800250c:	2a00      	cmp	r2, #0
 800250e:	d004      	beq.n	800251a <EEP_SetID_Page+0x20>
  for(i=0;i<EEPPAGESIZE_BYTE;i++,pStringID++) {
 8002510:	3301      	adds	r3, #1
 8002512:	b29b      	uxth	r3, r3
 8002514:	3101      	adds	r1, #1
 8002516:	e7f4      	b.n	8002502 <EEP_SetID_Page+0x8>
  if(pStringID==0) TrapError();
 8002518:	e7fe      	b.n	8002518 <EEP_SetID_Page+0x1e>
  }
  
  if(i>16) TrapError(); // we limit the String ID to 16 characters
 800251a:	2b10      	cmp	r3, #16
 800251c:	d900      	bls.n	8002520 <EEP_SetID_Page+0x26>
 800251e:	e7fe      	b.n	800251e <EEP_SetID_Page+0x24>
  
  return 0;
}
 8002520:	2000      	movs	r0, #0
 8002522:	bd10      	pop	{r4, pc}

08002524 <SIF_to_USARTn_NoLongerEmpty>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002524:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002528:	2301      	movs	r3, #1
 800252a:	f383 8810 	msr	PRIMASK, r3
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_TXE_TXFNF(USART_TypeDef *USARTx)
{
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
 800252e:	6803      	ldr	r3, [r0, #0]
 8002530:	2180      	movs	r1, #128	; 0x80
 8002532:	430b      	orrs	r3, r1
 8002534:	6003      	str	r3, [r0, #0]
 8002536:	f382 8810 	msr	PRIMASK, r2

// Called when the fifo is no longer empty to usually enable peripheral interrupt to digest incoming.
uint32_t SIF_to_USARTn_NoLongerEmpty(uint32_t ct) { // the from_SPIP fifo is not longer empty: activate USART RX to digest them
  LL_USART_EnableIT_TXE((USART_TypeDef*) ct); // something to send will fill the BV if enabled
  return 0;
}
 800253a:	2000      	movs	r0, #0
 800253c:	4770      	bx	lr

0800253e <SIF_to_USARTn_Emptied>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800253e:	f3ef 8210 	mrs	r2, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002542:	2301      	movs	r3, #1
 8002544:	f383 8810 	msr	PRIMASK, r3
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_DisableIT_TXE_TXFNF(USART_TypeDef *USARTx)
{
  ATOMIC_CLEAR_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
 8002548:	6803      	ldr	r3, [r0, #0]
 800254a:	2180      	movs	r1, #128	; 0x80
 800254c:	438b      	bics	r3, r1
 800254e:	6003      	str	r3, [r0, #0]
 8002550:	f382 8810 	msr	PRIMASK, r2

// Called to safely stop interrupts of destination peripheral, as the FIFO is now empty
uint32_t SIF_to_USARTn_Emptied(uint32_t ct) { // there is no data to feed usart anymore, so disable the interrupt
  LL_USART_DisableIT_TXE((USART_TypeDef*) ct);  // this will be enabled when the FIFO is not empty  
  return 0;
}
 8002554:	2000      	movs	r0, #0
 8002556:	4770      	bx	lr

08002558 <USARTs_ClockEnable>:
//const char sHelloToAPP[] = " ";//Hello to Brisk Application 0123456789ABCDEF!\n";
const char HC06_Command[] = "AT+BAUD8\n"; // Can be used to reprogram the default bluetooth dongle baud rate from 9600 to 115200 bps... (manual operation in debug mode)
volatile int32_t DetourHC06_115kProgramming = 0;

void USARTs_ClockEnable(void);
void USARTs_ClockEnable(void) {
 8002558:	b082      	sub	sp, #8
  do { 
    __IO uint32_t tmpreg;
    SET_BIT(RCC->APBENR2, RCC_APBENR2_USART1EN);
 800255a:	4b0a      	ldr	r3, [pc, #40]	; (8002584 <USARTs_ClockEnable+0x2c>)
 800255c:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800255e:	2080      	movs	r0, #128	; 0x80
 8002560:	01c0      	lsls	r0, r0, #7
 8002562:	4301      	orrs	r1, r0
 8002564:	6419      	str	r1, [r3, #64]	; 0x40
/* Delay after an RCC peripheral clock enabling */ 
    tmpreg = READ_BIT(RCC->APBENR2, RCC_APBENR2_USART1EN);
 8002566:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002568:	4002      	ands	r2, r0
 800256a:	9200      	str	r2, [sp, #0]
   UNUSED(tmpreg);
 800256c:	9a00      	ldr	r2, [sp, #0]
  } while(0U);
  
  do {
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APBENR1, RCC_APBENR1_USART2EN);
 800256e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002570:	2180      	movs	r1, #128	; 0x80
 8002572:	0289      	lsls	r1, r1, #10
 8002574:	430a      	orrs	r2, r1
 8002576:	63da      	str	r2, [r3, #60]	; 0x3c
/* Delay after an RCC peripheral clock enabling */ \
  tmpreg = READ_BIT(RCC->APBENR1, RCC_APBENR1_USART2EN);
 8002578:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800257a:	400b      	ands	r3, r1
 800257c:	9301      	str	r3, [sp, #4]
  UNUSED(tmpreg);
 800257e:	9b01      	ldr	r3, [sp, #4]
  } while(0U);
  
}
 8002580:	b002      	add	sp, #8
 8002582:	4770      	bx	lr
 8002584:	40021000 	.word	0x40021000

08002588 <Configure_UART>:
    //  [11:10] = USART1 stop bits: 0.1 1.1,5 2.2 (for now, only one stop bit)
    //  [31:12] USART1 Baudrate

uint8_t SIF_ioconfig_now, SIF_ioconfig_before;

uint32_t Configure_UART(uint32_t* CMD) {
 8002588:	b5f0      	push	{r4, r5, r6, r7, lr}
 800258a:	b08b      	sub	sp, #44	; 0x2c
 800258c:	2600      	movs	r6, #0
    
    SIF_ioconfig_before = SIF_ioconfig_now;
 800258e:	4b7b      	ldr	r3, [pc, #492]	; (800277c <Configure_UART+0x1f4>)
 8002590:	7819      	ldrb	r1, [r3, #0]
 8002592:	4a7b      	ldr	r2, [pc, #492]	; (8002780 <Configure_UART+0x1f8>)
 8002594:	7011      	strb	r1, [r2, #0]
    SIF_ioconfig_now = CMD[0]&0x0F;
 8002596:	240f      	movs	r4, #15
 8002598:	6802      	ldr	r2, [r0, #0]
 800259a:	4014      	ands	r4, r2
 800259c:	701c      	strb	r4, [r3, #0]
    //uint8_t parity = (CMD[0]>>8)&0x03; // 2 bits
    //uint8_t stops = (CMD[0]>>10)&0x03; // 2 bits
    uint32_t bps = (CMD[0]>>12); // 20 bits
 800259e:	6805      	ldr	r5, [r0, #0]
 80025a0:	0b2d      	lsrs	r5, r5, #12
    uint8_t n;
    uint8_t swap_rx_tx = 0;

    // now let's configure all these things
    IO_Pad_t IO_Pad = { PB_6, { .Mode = IO_SIGNAL, .Drive = IO_PUSHPULL, .Pull = IO_PULLUP, .Speed = IO_SPEED_03, .Signal = GPIO_AF0_USART1 } };
 80025a2:	ab09      	add	r3, sp, #36	; 0x24
 80025a4:	9609      	str	r6, [sp, #36]	; 0x24
 80025a6:	2216      	movs	r2, #22
 80025a8:	701a      	strb	r2, [r3, #0]
 80025aa:	785a      	ldrb	r2, [r3, #1]
 80025ac:	2007      	movs	r0, #7
 80025ae:	4382      	bics	r2, r0
 80025b0:	2703      	movs	r7, #3
 80025b2:	433a      	orrs	r2, r7
 80025b4:	705a      	strb	r2, [r3, #1]
 80025b6:	b2d2      	uxtb	r2, r2
 80025b8:	2738      	movs	r7, #56	; 0x38
 80025ba:	43ba      	bics	r2, r7
 80025bc:	2710      	movs	r7, #16
 80025be:	433a      	orrs	r2, r7
 80025c0:	705a      	strb	r2, [r3, #1]
 80025c2:	b2d7      	uxtb	r7, r2
 80025c4:	223f      	movs	r2, #63	; 0x3f
 80025c6:	403a      	ands	r2, r7
 80025c8:	2740      	movs	r7, #64	; 0x40
 80025ca:	433a      	orrs	r2, r7
 80025cc:	705a      	strb	r2, [r3, #1]
 80025ce:	789a      	ldrb	r2, [r3, #2]
 80025d0:	4382      	bics	r2, r0
 80025d2:	2004      	movs	r0, #4
 80025d4:	4302      	orrs	r2, r0
 80025d6:	709a      	strb	r2, [r3, #2]
    
    if(SIF_ioconfig_before != SIF_ioconfig_now)
 80025d8:	42a1      	cmp	r1, r4
 80025da:	d07d      	beq.n	80026d8 <Configure_UART+0x150>
      switch(SIF_ioconfig_now) { // for now, there will be glitches when changing GPIOs, and we don't care the FIFO are flushed, or USART is idle
 80025dc:	2c0c      	cmp	r4, #12
 80025de:	d900      	bls.n	80025e2 <Configure_UART+0x5a>
 80025e0:	e0c6      	b.n	8002770 <Configure_UART+0x1e8>
 80025e2:	00a3      	lsls	r3, r4, #2
 80025e4:	4a67      	ldr	r2, [pc, #412]	; (8002784 <Configure_UART+0x1fc>)
 80025e6:	58d3      	ldr	r3, [r2, r3]
 80025e8:	469f      	mov	pc, r3
 80025ea:	2600      	movs	r6, #0
 80025ec:	e060      	b.n	80026b0 <Configure_UART+0x128>
 80025ee:	2400      	movs	r4, #0
 80025f0:	e007      	b.n	8002602 <Configure_UART+0x7a>
      case 0: // BT&STL USART1 disconnected from GPIOs
        IO_PadDeInit(PB_6);
 80025f2:	2016      	movs	r0, #22
 80025f4:	f003 f83e 	bl	8005674 <IO_PadDeInit>
        IO_PadDeInit(PB_7);
 80025f8:	2017      	movs	r0, #23
 80025fa:	f003 f83b 	bl	8005674 <IO_PadDeInit>
      }

    LL_USART_InitTypeDef USART_InitStruct;
    ErrorStatus Error;
    
    if(n==1) { // configure USART1
 80025fe:	e009      	b.n	8002614 <Configure_UART+0x8c>
    	  swap_rx_tx = 1; // continue the rest is same
 8002600:	2401      	movs	r4, #1
        IO_PadInit(&IO_Pad);
 8002602:	ae09      	add	r6, sp, #36	; 0x24
 8002604:	0030      	movs	r0, r6
 8002606:	f002 ff49 	bl	800549c <IO_PadInit>
        IO_Pad.PadName = PB_7;
 800260a:	2317      	movs	r3, #23
 800260c:	7033      	strb	r3, [r6, #0]
        IO_PadInit(&IO_Pad);
 800260e:	0030      	movs	r0, r6
 8002610:	f002 ff44 	bl	800549c <IO_PadInit>
      LL_USART_DeInit(USART1);
 8002614:	4e5c      	ldr	r6, [pc, #368]	; (8002788 <Configure_UART+0x200>)
 8002616:	0030      	movs	r0, r6
 8002618:	f002 fe4c 	bl	80052b4 <LL_USART_DeInit>
      LL_USART_StructInit(&USART_InitStruct);
 800261c:	a801      	add	r0, sp, #4
 800261e:	f002 fef7 	bl	8005410 <LL_USART_StructInit>
      USART_InitStruct.BaudRate = bps;
 8002622:	9502      	str	r5, [sp, #8]
      Error = LL_USART_Init(USART1, &USART_InitStruct);
 8002624:	a901      	add	r1, sp, #4
 8002626:	0030      	movs	r0, r6
 8002628:	f002 fe6e 	bl	8005308 <LL_USART_Init>
      LL_USART_SetTXRXSwap(USART1, swap_rx_tx ? LL_USART_TXRX_SWAPPED : LL_USART_TXRX_STANDARD); // 
 800262c:	2c00      	cmp	r4, #0
 800262e:	d100      	bne.n	8002632 <Configure_UART+0xaa>
 8002630:	e09a      	b.n	8002768 <Configure_UART+0x1e0>
 8002632:	2280      	movs	r2, #128	; 0x80
 8002634:	0212      	lsls	r2, r2, #8
  MODIFY_REG(USARTx->CR2, USART_CR2_SWAP, SwapConfig);
 8002636:	4b54      	ldr	r3, [pc, #336]	; (8002788 <Configure_UART+0x200>)
 8002638:	6859      	ldr	r1, [r3, #4]
 800263a:	4854      	ldr	r0, [pc, #336]	; (800278c <Configure_UART+0x204>)
 800263c:	4001      	ands	r1, r0
 800263e:	430a      	orrs	r2, r1
 8002640:	605a      	str	r2, [r3, #4]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 8002642:	681a      	ldr	r2, [r3, #0]
 8002644:	2401      	movs	r4, #1
 8002646:	4322      	orrs	r2, r4
 8002648:	601a      	str	r2, [r3, #0]
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800264a:	4951      	ldr	r1, [pc, #324]	; (8002790 <Configure_UART+0x208>)
 800264c:	25c6      	movs	r5, #198	; 0xc6
 800264e:	00ad      	lsls	r5, r5, #2
 8002650:	594a      	ldr	r2, [r1, r5]
 8002652:	0212      	lsls	r2, r2, #8
 8002654:	0a12      	lsrs	r2, r2, #8
 8002656:	20c0      	movs	r0, #192	; 0xc0
 8002658:	0600      	lsls	r0, r0, #24
 800265a:	4302      	orrs	r2, r0
 800265c:	514a      	str	r2, [r1, r5]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 800265e:	2280      	movs	r2, #128	; 0x80
 8002660:	0512      	lsls	r2, r2, #20
 8002662:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002664:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002668:	f384 8810 	msr	PRIMASK, r4
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 800266c:	681a      	ldr	r2, [r3, #0]
 800266e:	2020      	movs	r0, #32
 8002670:	4302      	orrs	r2, r0
 8002672:	601a      	str	r2, [r3, #0]
 8002674:	f381 8810 	msr	PRIMASK, r1
      LL_USART_Enable(USART1);
      NVIC_SetPriority(USART1_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0x0F, 0x00));
      NVIC_EnableIRQ(USART1_IRQn);
      LL_USART_EnableIT_RXNE(USART1);
      if(u8fifo_from_SPIP[ARD_STM_SERIAL].bCount)// Dynamic case: we activate the TX if the u8fifo_from_SPIP is already not empty (or we flush it)
 8002678:	4b46      	ldr	r3, [pc, #280]	; (8002794 <Configure_UART+0x20c>)
 800267a:	68db      	ldr	r3, [r3, #12]
 800267c:	2b00      	cmp	r3, #0
 800267e:	d100      	bne.n	8002682 <Configure_UART+0xfa>
 8002680:	e078      	b.n	8002774 <Configure_UART+0x1ec>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002682:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8002686:	2301      	movs	r3, #1
 8002688:	f383 8810 	msr	PRIMASK, r3
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
 800268c:	4a3e      	ldr	r2, [pc, #248]	; (8002788 <Configure_UART+0x200>)
 800268e:	6813      	ldr	r3, [r2, #0]
 8002690:	3060      	adds	r0, #96	; 0x60
 8002692:	4303      	orrs	r3, r0
 8002694:	6013      	str	r3, [r2, #0]
 8002696:	f381 8810 	msr	PRIMASK, r1
      if(u8fifo_from_SPIP[ARD_STM_SERIAL].bCount)// Dynamic case: we activate the TX if the u8fifo_from_SPIP is already not empty (or we flush it)
        LL_USART_EnableIT_TXE(USART2);
    }else
      NOPs(1);
      
  return 1;
 800269a:	387f      	subs	r0, #127	; 0x7f
}
 800269c:	e060      	b.n	8002760 <Configure_UART+0x1d8>
        IO_PadDeInit(PA_2);
 800269e:	2002      	movs	r0, #2
 80026a0:	f002 ffe8 	bl	8005674 <IO_PadDeInit>
        IO_PadDeInit(PA_3);
 80026a4:	2003      	movs	r0, #3
 80026a6:	f002 ffe5 	bl	8005674 <IO_PadDeInit>
    uint8_t swap_rx_tx = 0;
 80026aa:	2600      	movs	r6, #0
 80026ac:	e017      	b.n	80026de <Configure_UART+0x156>
        swap_rx_tx = 1; // continue as rest is same
 80026ae:	2601      	movs	r6, #1
        IO_PadDeInit(PD_2);
 80026b0:	2032      	movs	r0, #50	; 0x32
 80026b2:	f002 ffdf 	bl	8005674 <IO_PadDeInit>
        IO_PadDeInit(PD_3);
 80026b6:	2033      	movs	r0, #51	; 0x33
 80026b8:	f002 ffdc 	bl	8005674 <IO_PadDeInit>
        IO_Pad.PadName = PA_2;
 80026bc:	ac09      	add	r4, sp, #36	; 0x24
 80026be:	2302      	movs	r3, #2
 80026c0:	7023      	strb	r3, [r4, #0]
        IO_Pad.Config.Signal = GPIO_AF1_USART2;
 80026c2:	3b01      	subs	r3, #1
 80026c4:	70e3      	strb	r3, [r4, #3]
        IO_PadInit(&IO_Pad);
 80026c6:	0020      	movs	r0, r4
 80026c8:	f002 fee8 	bl	800549c <IO_PadInit>
        IO_Pad.PadName = PA_3;
 80026cc:	2303      	movs	r3, #3
 80026ce:	7023      	strb	r3, [r4, #0]
        IO_PadInit(&IO_Pad);
 80026d0:	0020      	movs	r0, r4
 80026d2:	f002 fee3 	bl	800549c <IO_PadInit>
    if(n==1) { // configure USART1
 80026d6:	e002      	b.n	80026de <Configure_UART+0x156>
 80026d8:	2e01      	cmp	r6, #1
 80026da:	d043      	beq.n	8002764 <Configure_UART+0x1dc>
    uint8_t swap_rx_tx = 0;
 80026dc:	2600      	movs	r6, #0
      LL_USART_DeInit(USART2);      
 80026de:	4c2e      	ldr	r4, [pc, #184]	; (8002798 <Configure_UART+0x210>)
 80026e0:	0020      	movs	r0, r4
 80026e2:	f002 fde7 	bl	80052b4 <LL_USART_DeInit>
      LL_USART_StructInit(&USART_InitStruct);
 80026e6:	a801      	add	r0, sp, #4
 80026e8:	f002 fe92 	bl	8005410 <LL_USART_StructInit>
      USART_InitStruct.BaudRate = bps;
 80026ec:	9502      	str	r5, [sp, #8]
      Error = LL_USART_Init(USART2, &USART_InitStruct);
 80026ee:	a901      	add	r1, sp, #4
 80026f0:	0020      	movs	r0, r4
 80026f2:	f002 fe09 	bl	8005308 <LL_USART_Init>
      LL_USART_SetTXRXSwap(USART2, swap_rx_tx ? LL_USART_TXRX_SWAPPED : LL_USART_TXRX_STANDARD); // 
 80026f6:	2e00      	cmp	r6, #0
 80026f8:	d038      	beq.n	800276c <Configure_UART+0x1e4>
 80026fa:	2180      	movs	r1, #128	; 0x80
 80026fc:	0209      	lsls	r1, r1, #8
  MODIFY_REG(USARTx->CR2, USART_CR2_SWAP, SwapConfig);
 80026fe:	4b26      	ldr	r3, [pc, #152]	; (8002798 <Configure_UART+0x210>)
 8002700:	685a      	ldr	r2, [r3, #4]
 8002702:	4822      	ldr	r0, [pc, #136]	; (800278c <Configure_UART+0x204>)
 8002704:	4002      	ands	r2, r0
 8002706:	430a      	orrs	r2, r1
 8002708:	605a      	str	r2, [r3, #4]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 800270a:	681a      	ldr	r2, [r3, #0]
 800270c:	2001      	movs	r0, #1
 800270e:	4302      	orrs	r2, r0
 8002710:	601a      	str	r2, [r3, #0]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8002712:	491f      	ldr	r1, [pc, #124]	; (8002790 <Configure_UART+0x208>)
 8002714:	24c7      	movs	r4, #199	; 0xc7
 8002716:	00a4      	lsls	r4, r4, #2
 8002718:	590a      	ldr	r2, [r1, r4]
 800271a:	25ff      	movs	r5, #255	; 0xff
 800271c:	43aa      	bics	r2, r5
 800271e:	3d3f      	subs	r5, #63	; 0x3f
 8002720:	432a      	orrs	r2, r5
 8002722:	510a      	str	r2, [r1, r4]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002724:	2280      	movs	r2, #128	; 0x80
 8002726:	0552      	lsls	r2, r2, #21
 8002728:	600a      	str	r2, [r1, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 800272a:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800272e:	f380 8810 	msr	PRIMASK, r0
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE);
 8002732:	681a      	ldr	r2, [r3, #0]
 8002734:	301f      	adds	r0, #31
 8002736:	4302      	orrs	r2, r0
 8002738:	601a      	str	r2, [r3, #0]
 800273a:	f381 8810 	msr	PRIMASK, r1
      if(u8fifo_from_SPIP[ARD_STM_SERIAL].bCount)// Dynamic case: we activate the TX if the u8fifo_from_SPIP is already not empty (or we flush it)
 800273e:	4b15      	ldr	r3, [pc, #84]	; (8002794 <Configure_UART+0x20c>)
 8002740:	68db      	ldr	r3, [r3, #12]
 8002742:	2b00      	cmp	r3, #0
 8002744:	d018      	beq.n	8002778 <Configure_UART+0x1f0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8002746:	f3ef 8110 	mrs	r1, PRIMASK
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 800274a:	2301      	movs	r3, #1
 800274c:	f383 8810 	msr	PRIMASK, r3
  ATOMIC_SET_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE);
 8002750:	4a11      	ldr	r2, [pc, #68]	; (8002798 <Configure_UART+0x210>)
 8002752:	6813      	ldr	r3, [r2, #0]
 8002754:	3060      	adds	r0, #96	; 0x60
 8002756:	4303      	orrs	r3, r0
 8002758:	6013      	str	r3, [r2, #0]
 800275a:	f381 8810 	msr	PRIMASK, r1
  return 1;
 800275e:	387f      	subs	r0, #127	; 0x7f
}
 8002760:	b00b      	add	sp, #44	; 0x2c
 8002762:	bdf0      	pop	{r4, r5, r6, r7, pc}
    uint8_t swap_rx_tx = 0;
 8002764:	2400      	movs	r4, #0
 8002766:	e755      	b.n	8002614 <Configure_UART+0x8c>
      LL_USART_SetTXRXSwap(USART1, swap_rx_tx ? LL_USART_TXRX_SWAPPED : LL_USART_TXRX_STANDARD); // 
 8002768:	2200      	movs	r2, #0
 800276a:	e764      	b.n	8002636 <Configure_UART+0xae>
      LL_USART_SetTXRXSwap(USART2, swap_rx_tx ? LL_USART_TXRX_SWAPPED : LL_USART_TXRX_STANDARD); // 
 800276c:	2100      	movs	r1, #0
 800276e:	e7c6      	b.n	80026fe <Configure_UART+0x176>
      switch(SIF_ioconfig_now) { // for now, there will be glitches when changing GPIOs, and we don't care the FIFO are flushed, or USART is idle
 8002770:	2000      	movs	r0, #0
 8002772:	e7f5      	b.n	8002760 <Configure_UART+0x1d8>
  return 1;
 8002774:	2001      	movs	r0, #1
 8002776:	e7f3      	b.n	8002760 <Configure_UART+0x1d8>
 8002778:	2001      	movs	r0, #1
 800277a:	e7f1      	b.n	8002760 <Configure_UART+0x1d8>
 800277c:	200020d5 	.word	0x200020d5
 8002780:	200020d4 	.word	0x200020d4
 8002784:	08006154 	.word	0x08006154
 8002788:	40013800 	.word	0x40013800
 800278c:	ffff7fff 	.word	0xffff7fff
 8002790:	e000e100 	.word	0xe000e100
 8002794:	200020d8 	.word	0x200020d8
 8002798:	40004400 	.word	0x40004400

0800279c <SPIP_SIF_Init>:
void SPIP_SIF_Init(void) {
 800279c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800279e:	46c6      	mov	lr, r8
 80027a0:	b500      	push	{lr}
 80027a2:	b084      	sub	sp, #16
  for(i=0;i<MAX_SERIAL;i++) {
 80027a4:	2400      	movs	r4, #0
 80027a6:	e016      	b.n	80027d6 <SPIP_SIF_Init+0x3a>
    result = Newu8fifo(&u8fifo_to_SPIP[i], (uint32_t) &Bytes_to_SPIP[i][0], sizeof(Bytes_to_SPIP[0]));
 80027a8:	4f27      	ldr	r7, [pc, #156]	; (8002848 <SPIP_SIF_Init+0xac>)
 80027aa:	003e      	movs	r6, r7
 80027ac:	4366      	muls	r6, r4
 80027ae:	4927      	ldr	r1, [pc, #156]	; (800284c <SPIP_SIF_Init+0xb0>)
 80027b0:	1871      	adds	r1, r6, r1
 80027b2:	00e5      	lsls	r5, r4, #3
 80027b4:	1b2a      	subs	r2, r5, r4
 80027b6:	00d3      	lsls	r3, r2, #3
 80027b8:	4825      	ldr	r0, [pc, #148]	; (8002850 <SPIP_SIF_Init+0xb4>)
 80027ba:	18c0      	adds	r0, r0, r3
 80027bc:	003a      	movs	r2, r7
 80027be:	f000 fe05 	bl	80033cc <Newu8fifo>
    result = Newu8fifo(&u8fifo_from_SPIP[i], (uint32_t) &Bytes_from_SPIP[i][0], sizeof(Bytes_from_SPIP[0]));
 80027c2:	4924      	ldr	r1, [pc, #144]	; (8002854 <SPIP_SIF_Init+0xb8>)
 80027c4:	1871      	adds	r1, r6, r1
 80027c6:	1b2d      	subs	r5, r5, r4
 80027c8:	00eb      	lsls	r3, r5, #3
 80027ca:	4823      	ldr	r0, [pc, #140]	; (8002858 <SPIP_SIF_Init+0xbc>)
 80027cc:	18c0      	adds	r0, r0, r3
 80027ce:	003a      	movs	r2, r7
 80027d0:	f000 fdfc 	bl	80033cc <Newu8fifo>
  for(i=0;i<MAX_SERIAL;i++) {
 80027d4:	3401      	adds	r4, #1
 80027d6:	2c01      	cmp	r4, #1
 80027d8:	d9e6      	bls.n	80027a8 <SPIP_SIF_Init+0xc>
  Hooku8fifo_NoLongerEmpty(&u8fifo_from_SPIP[ARD_STM_SERIAL], SIF_to_USARTn_NoLongerEmpty, (uint32_t) USART2 );
 80027da:	4b20      	ldr	r3, [pc, #128]	; (800285c <SPIP_SIF_Init+0xc0>)
 80027dc:	4698      	mov	r8, r3
 80027de:	4e20      	ldr	r6, [pc, #128]	; (8002860 <SPIP_SIF_Init+0xc4>)
 80027e0:	4c1d      	ldr	r4, [pc, #116]	; (8002858 <SPIP_SIF_Init+0xbc>)
 80027e2:	001a      	movs	r2, r3
 80027e4:	0031      	movs	r1, r6
 80027e6:	0020      	movs	r0, r4
 80027e8:	f000 fde8 	bl	80033bc <Hooku8fifo_NoLongerEmpty>
  Hooku8fifo_NoLongerEmpty(&u8fifo_from_SPIP[BT_STL_SERIAL], SIF_to_USARTn_NoLongerEmpty, (uint32_t) USART1 );
 80027ec:	4f1d      	ldr	r7, [pc, #116]	; (8002864 <SPIP_SIF_Init+0xc8>)
 80027ee:	0025      	movs	r5, r4
 80027f0:	3538      	adds	r5, #56	; 0x38
 80027f2:	003a      	movs	r2, r7
 80027f4:	0031      	movs	r1, r6
 80027f6:	0028      	movs	r0, r5
 80027f8:	f000 fde0 	bl	80033bc <Hooku8fifo_NoLongerEmpty>
  Hooku8fifo_Emptied(&u8fifo_from_SPIP[ARD_STM_SERIAL], SIF_to_USARTn_Emptied, (uint32_t) USART2 );
 80027fc:	4e1a      	ldr	r6, [pc, #104]	; (8002868 <SPIP_SIF_Init+0xcc>)
 80027fe:	4642      	mov	r2, r8
 8002800:	0031      	movs	r1, r6
 8002802:	0020      	movs	r0, r4
 8002804:	f000 fdde 	bl	80033c4 <Hooku8fifo_Emptied>
  Hooku8fifo_Emptied(&u8fifo_from_SPIP[BT_STL_SERIAL], SIF_to_USARTn_Emptied, (uint32_t) USART1 );
 8002808:	003a      	movs	r2, r7
 800280a:	0031      	movs	r1, r6
 800280c:	0028      	movs	r0, r5
 800280e:	f000 fdd9 	bl	80033c4 <Hooku8fifo_Emptied>
USARTs_ClockEnable();  
 8002812:	f7ff fea1 	bl	8002558 <USARTs_ClockEnable>
  CMD[0] = ((115200L)<<12) | 1; // default SPIP going to SWD port
 8002816:	4b15      	ldr	r3, [pc, #84]	; (800286c <SPIP_SIF_Init+0xd0>)
 8002818:	9301      	str	r3, [sp, #4]
  Configure_UART(CMD);
 800281a:	a801      	add	r0, sp, #4
 800281c:	f7ff feb4 	bl	8002588 <Configure_UART>
  BTEL_Enable();
 8002820:	f7fe fc8c 	bl	800113c <BTEL_Enable>
  for(i=0;i<200;i++) { AddTou8fifo(&u8fifo_to_SPIP[BT_STL_SERIAL], sHelloFromBT_STL[i]); if(sHelloFromBT_STL[i]==0) break; }
 8002824:	2400      	movs	r4, #0
 8002826:	2cc7      	cmp	r4, #199	; 0xc7
 8002828:	d80a      	bhi.n	8002840 <SPIP_SIF_Init+0xa4>
 800282a:	4b11      	ldr	r3, [pc, #68]	; (8002870 <SPIP_SIF_Init+0xd4>)
 800282c:	5d1d      	ldrb	r5, [r3, r4]
 800282e:	4808      	ldr	r0, [pc, #32]	; (8002850 <SPIP_SIF_Init+0xb4>)
 8002830:	0029      	movs	r1, r5
 8002832:	3038      	adds	r0, #56	; 0x38
 8002834:	f000 fdef 	bl	8003416 <AddTou8fifo>
 8002838:	2d00      	cmp	r5, #0
 800283a:	d001      	beq.n	8002840 <SPIP_SIF_Init+0xa4>
 800283c:	3401      	adds	r4, #1
 800283e:	e7f2      	b.n	8002826 <SPIP_SIF_Init+0x8a>
}
 8002840:	b004      	add	sp, #16
 8002842:	bc80      	pop	{r7}
 8002844:	46b8      	mov	r8, r7
 8002846:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002848:	000005dc 	.word	0x000005dc
 800284c:	2000151c 	.word	0x2000151c
 8002850:	20002148 	.word	0x20002148
 8002854:	20000964 	.word	0x20000964
 8002858:	200020d8 	.word	0x200020d8
 800285c:	40004400 	.word	0x40004400
 8002860:	08002525 	.word	0x08002525
 8002864:	40013800 	.word	0x40013800
 8002868:	0800253f 	.word	0x0800253f
 800286c:	1c200001 	.word	0x1c200001
 8002870:	08006188 	.word	0x08006188

08002874 <STModp_DeInit>:

  // these functions are called at MCU power on, not necessarily when the add-on board is connected... only for global variables initial values needs
  STModp_DeInit(); // 18/11/19
}

void STModp_DeInit(void) {// When unplugged, we shall deselect all the STMOD+ IOs except I2C.
 8002874:	b510      	push	{r4, lr}
  IO_PadDeInit(PA_0); //[1] PA0 CTS2
 8002876:	2000      	movs	r0, #0
 8002878:	f002 fefc 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PA_2); //[2] PA2 TX2
 800287c:	2002      	movs	r0, #2
 800287e:	f002 fef9 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PD_3); //[3] PA3 RX2
 8002882:	2033      	movs	r0, #51	; 0x33
 8002884:	f002 fef6 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PD_1); //[4] PA1 RTS2
 8002888:	2031      	movs	r0, #49	; 0x31
 800288a:	f002 fef3 	bl	8005674 <IO_PadDeInit>
  //----------- (I2C untouched)
  IO_PadDeInit(PA_7);// [8] PA7 ---
 800288e:	2007      	movs	r0, #7
 8002890:	f002 fef0 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PD_2);// [9] PD2
 8002894:	2032      	movs	r0, #50	; 0x32
 8002896:	f002 feed 	bl	8005674 <IO_PadDeInit>
//=================  
  IO_PadDeInit(PC_14);//[11] PC14
 800289a:	202e      	movs	r0, #46	; 0x2e
 800289c:	f002 feea 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PC_15);//[12] PC15
 80028a0:	202f      	movs	r0, #47	; 0x2f
 80028a2:	f002 fee7 	bl	8005674 <IO_PadDeInit>
#if 0 // used as disco user LED and user Analog Rock switch, so it may not need to be reinitialized at unplug event
  IO_PadDeInit(PA_4);// [13] PA4
  IO_PadDeInit(PA_5);// [14] PA5
#endif
  IO_PadDeInit(PB_0);// [17] PB0
 80028a6:	2010      	movs	r0, #16
 80028a8:	f002 fee4 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PA_6);// [18] PA6
 80028ac:	2006      	movs	r0, #6
 80028ae:	f002 fee1 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PD_1);// [19] PD1
 80028b2:	2031      	movs	r0, #49	; 0x31
 80028b4:	f002 fede 	bl	8005674 <IO_PadDeInit>
  IO_PadDeInit(PD_0);// [20] PD0
 80028b8:	2030      	movs	r0, #48	; 0x30
 80028ba:	f002 fedb 	bl	8005674 <IO_PadDeInit>

}
 80028be:	bd10      	pop	{r4, pc}

080028c0 <Add_on_Board_Init>:
void Add_on_Board_Init(ADD_ON_BOARD_t* pA) {
 80028c0:	b510      	push	{r4, lr}
  STModp_DeInit(); // 18/11/19
 80028c2:	f7ff ffd7 	bl	8002874 <STModp_DeInit>
}
 80028c6:	bd10      	pop	{r4, pc}

080028c8 <Add_on_Board_1sec>:
  }

}


void Add_on_Board_1sec(ADD_ON_BOARD_t* pA) { // should be called every 100 msec
 80028c8:	b510      	push	{r4, lr}
  
  if(pA->IsPlugged == 0)
 80028ca:	7a43      	ldrb	r3, [r0, #9]
 80028cc:	2b00      	cmp	r3, #0
 80028ce:	d005      	beq.n	80028dc <Add_on_Board_1sec+0x14>
    return;

  // now we process the add-on specifics for 50 msec event
  switch(pA->ID_Code) {
 80028d0:	232b      	movs	r3, #43	; 0x2b
 80028d2:	5cc3      	ldrb	r3, [r0, r3]
 80028d4:	2b01      	cmp	r3, #1
 80028d6:	d002      	beq.n	80028de <Add_on_Board_1sec+0x16>
 80028d8:	2b08      	cmp	r3, #8
 80028da:	d000      	beq.n	80028de <Add_on_Board_1sec+0x16>
#endif  
//  case STM32WL55C_DK1_BOARD:            WL_1sec(); break;
  default: ;//TrapError();
  }

}
 80028dc:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_1sec(); break; // 8
 80028de:	f7fd ff4f 	bl	8000780 <OI_1sec>
 80028e2:	e7fb      	b.n	80028dc <Add_on_Board_1sec+0x14>

080028e4 <JustUnPlugged>:
  default: break;//TrapError();
  };

}

void JustUnPlugged(ADD_ON_BOARD_t* pA) {
 80028e4:	b510      	push	{r4, lr}
 80028e6:	0004      	movs	r4, r0

    pA->JustUnplugged = 1; // was plugged...    
 80028e8:	2301      	movs	r3, #1
 80028ea:	7283      	strb	r3, [r0, #10]
    pA->IsPresentCounter_50msec = 0;
 80028ec:	2300      	movs	r3, #0
 80028ee:	6043      	str	r3, [r0, #4]
    
    // we can reinitialize all the GPIOs connected to STMod+ connector
    // and we can also notify (callback) in future implementation
  // now we process the add-on specifics for 50 msec event

  switch(pA->ID_Code) {
 80028f0:	332b      	adds	r3, #43	; 0x2b
 80028f2:	5cc3      	ldrb	r3, [r0, r3]
 80028f4:	2b01      	cmp	r3, #1
 80028f6:	d007      	beq.n	8002908 <JustUnPlugged+0x24>
 80028f8:	2b08      	cmp	r3, #8
 80028fa:	d005      	beq.n	8002908 <JustUnPlugged+0x24>
#endif  
//  case STM32WL55C_DK1_BOARD:            WL_IsUnplugged(); break;
  default: ;//TrapError();
  }

  pA->ID_Code = UNDETECTED_ADD_ON_BOARD;
 80028fc:	232b      	movs	r3, #43	; 0x2b
 80028fe:	2200      	movs	r2, #0
 8002900:	54e2      	strb	r2, [r4, r3]
  STModp_DeInit();
 8002902:	f7ff ffb7 	bl	8002874 <STModp_DeInit>
// valid for all  
//DIS  pBTEL->PanelSelectorMax = BRISK_PANELS;
//DIS  BTEL_SetDelayedPanel(0, 5);
//  pBTEL->PanelSelector = 0;
//  DelayedSetPanelCountdown_100ms = 5;
}
 8002906:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_IsUnplugged(); break; // 8
 8002908:	f7fd ff22 	bl	8000750 <OI_IsUnplugged>
 800290c:	e7f6      	b.n	80028fc <JustUnPlugged+0x18>
	...

08002910 <Add_on_BoardConfigure>:

const char BlankStringID[] = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";

volatile uint8_t debug_options = 0; // don't touch this

uint8_t Add_on_BoardConfigure(ADD_ON_BOARD_t* pA) {
 8002910:	b570      	push	{r4, r5, r6, lr}
 8002912:	0004      	movs	r4, r0
  
  if(StringsIdenticals (pA->StringID, BlankStringID, 16)) { // BLANK_ADD_ON_DETECTED
 8002914:	0005      	movs	r5, r0
 8002916:	350b      	adds	r5, #11
 8002918:	2210      	movs	r2, #16
 800291a:	492b      	ldr	r1, [pc, #172]	; (80029c8 <Add_on_BoardConfigure+0xb8>)
 800291c:	0028      	movs	r0, r5
 800291e:	f000 fcdd 	bl	80032dc <StringsIdenticals>
 8002922:	2800      	cmp	r0, #0
 8002924:	d01b      	beq.n	800295e <Add_on_BoardConfigure+0x4e>
    pA->ID_Code = BLANK_ADD_ON_BOARD;
 8002926:	232b      	movs	r3, #43	; 0x2b
 8002928:	2201      	movs	r2, #1
 800292a:	54e2      	strb	r2, [r4, r3]
    // blank ones will be assumed to be LCD
    //pA->ID_Code = B_HMI_LCD16x2_BOARD; //  Put a breakpoint here if you want to program the add-on blank EEPROM. Use debugger "Set Next Step" to directly execute the right case xxx : code. Then reset.
    switch(debug_options) {
 800292c:	4b27      	ldr	r3, [pc, #156]	; (80029cc <Add_on_BoardConfigure+0xbc>)
 800292e:	781b      	ldrb	r3, [r3, #0]
 8002930:	b2da      	uxtb	r2, r3
 8002932:	2b08      	cmp	r3, #8
 8002934:	d003      	beq.n	800293e <Add_on_BoardConfigure+0x2e>
 8002936:	2a10      	cmp	r2, #16
 8002938:	d009      	beq.n	800294e <Add_on_BoardConfigure+0x3e>
        EEP_WriteID(pA->pEEP);
    break;
*/
    }
    
    return 0;
 800293a:	2000      	movs	r0, #0
  }    
*/
  pA->ID_Code = UNKNOWN_ADD_ON_BOARD;
  BriskBlinkTimedLED(1, 1000, 500, pA->ID_Code ); // on all the time
  return 0;
}
 800293c:	bd70      	pop	{r4, r5, r6, pc}
          EEP_SetID_Page(pA->pEEP, "B_OPTO_INERT"); // set the string
 800293e:	4924      	ldr	r1, [pc, #144]	; (80029d0 <Add_on_BoardConfigure+0xc0>)
 8002940:	6820      	ldr	r0, [r4, #0]
 8002942:	f7ff fdda 	bl	80024fa <EEP_SetID_Page>
          EEP_WriteID(pA->pEEP); // program the string
 8002946:	6820      	ldr	r0, [r4, #0]
 8002948:	f7ff fda2 	bl	8002490 <EEP_WriteID>
    break;
 800294c:	e7f5      	b.n	800293a <Add_on_BoardConfigure+0x2a>
          EEP_SetID_Page(pA->pEEP, "B_RS485_DCDC");
 800294e:	4921      	ldr	r1, [pc, #132]	; (80029d4 <Add_on_BoardConfigure+0xc4>)
 8002950:	6820      	ldr	r0, [r4, #0]
 8002952:	f7ff fdd2 	bl	80024fa <EEP_SetID_Page>
          EEP_WriteID(pA->pEEP);
 8002956:	6820      	ldr	r0, [r4, #0]
 8002958:	f7ff fd9a 	bl	8002490 <EEP_WriteID>
    break;
 800295c:	e7ed      	b.n	800293a <Add_on_BoardConfigure+0x2a>
  if(StringsIdenticals (pA->StringID, "B_OPTO_INERT", 16)) { // BLANK_ADD_ON_DETECTED
 800295e:	2210      	movs	r2, #16
 8002960:	491b      	ldr	r1, [pc, #108]	; (80029d0 <Add_on_BoardConfigure+0xc0>)
 8002962:	0028      	movs	r0, r5
 8002964:	f000 fcba 	bl	80032dc <StringsIdenticals>
 8002968:	2800      	cmp	r0, #0
 800296a:	d113      	bne.n	8002994 <Add_on_BoardConfigure+0x84>
  if(StringsIdenticals (pA->StringID, "B_RS485_DCDC", 16)) { // BLANK_ADD_ON_DETECTED
 800296c:	2210      	movs	r2, #16
 800296e:	4919      	ldr	r1, [pc, #100]	; (80029d4 <Add_on_BoardConfigure+0xc4>)
 8002970:	0028      	movs	r0, r5
 8002972:	f000 fcb3 	bl	80032dc <StringsIdenticals>
 8002976:	2800      	cmp	r0, #0
 8002978:	d119      	bne.n	80029ae <Add_on_BoardConfigure+0x9e>
  pA->ID_Code = UNKNOWN_ADD_ON_BOARD;
 800297a:	232b      	movs	r3, #43	; 0x2b
 800297c:	2202      	movs	r2, #2
 800297e:	54e2      	strb	r2, [r4, r3]
  BriskBlinkTimedLED(1, 1000, 500, pA->ID_Code ); // on all the time
 8002980:	32f8      	adds	r2, #248	; 0xf8
 8002982:	21fa      	movs	r1, #250	; 0xfa
 8002984:	3b29      	subs	r3, #41	; 0x29
 8002986:	0052      	lsls	r2, r2, #1
 8002988:	0089      	lsls	r1, r1, #2
 800298a:	2001      	movs	r0, #1
 800298c:	f7ff fcaa 	bl	80022e4 <BriskBlinkTimedLED>
  return 0;
 8002990:	2000      	movs	r0, #0
 8002992:	e7d3      	b.n	800293c <Add_on_BoardConfigure+0x2c>
    pA->ID_Code = B_OPTO_INERT_BOARD;
 8002994:	232b      	movs	r3, #43	; 0x2b
 8002996:	2208      	movs	r2, #8
 8002998:	54e2      	strb	r2, [r4, r3]
    BriskBlinkTimedLED(1, 1000, 500, pA->ID_Code ); // on all the time
 800299a:	32f2      	adds	r2, #242	; 0xf2
 800299c:	21fa      	movs	r1, #250	; 0xfa
 800299e:	3b23      	subs	r3, #35	; 0x23
 80029a0:	0052      	lsls	r2, r2, #1
 80029a2:	0089      	lsls	r1, r1, #2
 80029a4:	2001      	movs	r0, #1
 80029a6:	f7ff fc9d 	bl	80022e4 <BriskBlinkTimedLED>
    return 1;
 80029aa:	2001      	movs	r0, #1
 80029ac:	e7c6      	b.n	800293c <Add_on_BoardConfigure+0x2c>
    pA->ID_Code = B_RS485_DCDC_BOARD;
 80029ae:	232b      	movs	r3, #43	; 0x2b
 80029b0:	2210      	movs	r2, #16
 80029b2:	54e2      	strb	r2, [r4, r3]
    BriskBlinkTimedLED(1, 1000, 500, pA->ID_Code ); // on all the time
 80029b4:	32ea      	adds	r2, #234	; 0xea
 80029b6:	21fa      	movs	r1, #250	; 0xfa
 80029b8:	3b1b      	subs	r3, #27
 80029ba:	0052      	lsls	r2, r2, #1
 80029bc:	0089      	lsls	r1, r1, #2
 80029be:	2001      	movs	r0, #1
 80029c0:	f7ff fc90 	bl	80022e4 <BriskBlinkTimedLED>
    return 1;
 80029c4:	2001      	movs	r0, #1
 80029c6:	e7b9      	b.n	800293c <Add_on_BoardConfigure+0x2c>
 80029c8:	080061ac 	.word	0x080061ac
 80029cc:	200021b8 	.word	0x200021b8
 80029d0:	0800618c 	.word	0x0800618c
 80029d4:	0800619c 	.word	0x0800619c

080029d8 <JustPlugged>:
void JustPlugged(ADD_ON_BOARD_t* pA) {
 80029d8:	b510      	push	{r4, lr}
 80029da:	0004      	movs	r4, r0
  pA->JustPlugged = 1;
 80029dc:	2301      	movs	r3, #1
 80029de:	7203      	strb	r3, [r0, #8]
  pA->IsPlugged = 1;
 80029e0:	7243      	strb	r3, [r0, #9]
  pA->JustUnplugged = 0;
 80029e2:	2300      	movs	r3, #0
 80029e4:	7283      	strb	r3, [r0, #10]
  STModp_DeInit();  
 80029e6:	f7ff ff45 	bl	8002874 <STModp_DeInit>
  EEP_ReadID(pA->pEEP); // Read the ID Page for analysis
 80029ea:	6820      	ldr	r0, [r4, #0]
 80029ec:	f7ff fd40 	bl	8002470 <EEP_ReadID>
  for(i=0;i<16;i++)
 80029f0:	2300      	movs	r3, #0
 80029f2:	e005      	b.n	8002a00 <JustPlugged+0x28>
    pA->StringID[i] = pA->pEEP->ID_Page[i];
 80029f4:	6822      	ldr	r2, [r4, #0]
 80029f6:	18d2      	adds	r2, r2, r3
 80029f8:	7a51      	ldrb	r1, [r2, #9]
 80029fa:	18e2      	adds	r2, r4, r3
 80029fc:	72d1      	strb	r1, [r2, #11]
  for(i=0;i<16;i++)
 80029fe:	3301      	adds	r3, #1
 8002a00:	2b0f      	cmp	r3, #15
 8002a02:	d9f7      	bls.n	80029f4 <JustPlugged+0x1c>
  pA->StringID[16] = 0; // NULL CHAR
 8002a04:	2300      	movs	r3, #0
 8002a06:	76e3      	strb	r3, [r4, #27]
  Add_on_BoardConfigure(pA); // from string to ID_Code
 8002a08:	0020      	movs	r0, r4
 8002a0a:	f7ff ff81 	bl	8002910 <Add_on_BoardConfigure>
  switch(pA->ID_Code) {
 8002a0e:	232b      	movs	r3, #43	; 0x2b
 8002a10:	5ce3      	ldrb	r3, [r4, r3]
 8002a12:	2b01      	cmp	r3, #1
 8002a14:	d002      	beq.n	8002a1c <JustPlugged+0x44>
 8002a16:	2b08      	cmp	r3, #8
 8002a18:	d000      	beq.n	8002a1c <JustPlugged+0x44>
}
 8002a1a:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_IsPlugged(); break; // 8
 8002a1c:	f7fd fe40 	bl	80006a0 <OI_IsPlugged>
}
 8002a20:	e7fb      	b.n	8002a1a <JustPlugged+0x42>

08002a22 <Add_on_Board_50msec>:
void Add_on_Board_50msec(ADD_ON_BOARD_t* pA) { // should be called every 100 msec
 8002a22:	b510      	push	{r4, lr}
 8002a24:	0004      	movs	r4, r0
  pA->pEEP->pDevice->SlaveAdr = 0xAC;
 8002a26:	6803      	ldr	r3, [r0, #0]
 8002a28:	681b      	ldr	r3, [r3, #0]
 8002a2a:	22ac      	movs	r2, #172	; 0xac
 8002a2c:	711a      	strb	r2, [r3, #4]
  pA->pEEP->pDeviceID->SlaveAdr = 0xBC;
 8002a2e:	6803      	ldr	r3, [r0, #0]
 8002a30:	685b      	ldr	r3, [r3, #4]
 8002a32:	3210      	adds	r2, #16
 8002a34:	711a      	strb	r2, [r3, #4]
  if(Is_EEP_Detected(pA->pEEP)) { // the EEPROM is I2C Acked
 8002a36:	6800      	ldr	r0, [r0, #0]
 8002a38:	f7ff fcfe 	bl	8002438 <Is_EEP_Detected>
 8002a3c:	2800      	cmp	r0, #0
 8002a3e:	d011      	beq.n	8002a64 <Add_on_Board_50msec+0x42>
    pA->IsPresentCounter_50msec = min2(0xFFFFFFFE, pA->IsPresentCounter_50msec+1); // increase the match counter
 8002a40:	6863      	ldr	r3, [r4, #4]
 8002a42:	1c9a      	adds	r2, r3, #2
 8002a44:	d000      	beq.n	8002a48 <Add_on_Board_50msec+0x26>
 8002a46:	3301      	adds	r3, #1
 8002a48:	6063      	str	r3, [r4, #4]
    if(pA->IsPresentCounter_50msec == 3) // triple confirmed, let get the processing now
 8002a4a:	2b03      	cmp	r3, #3
 8002a4c:	d006      	beq.n	8002a5c <Add_on_Board_50msec+0x3a>
  switch(pA->ID_Code) {
 8002a4e:	232b      	movs	r3, #43	; 0x2b
 8002a50:	5ce3      	ldrb	r3, [r4, r3]
 8002a52:	2b01      	cmp	r3, #1
 8002a54:	d028      	beq.n	8002aa8 <Add_on_Board_50msec+0x86>
 8002a56:	2b08      	cmp	r3, #8
 8002a58:	d026      	beq.n	8002aa8 <Add_on_Board_50msec+0x86>
}
 8002a5a:	bd10      	pop	{r4, pc}
      JustPlugged(pA);
 8002a5c:	0020      	movs	r0, r4
 8002a5e:	f7ff ffbb 	bl	80029d8 <JustPlugged>
 8002a62:	e7f4      	b.n	8002a4e <Add_on_Board_50msec+0x2c>
    pA->pEEP->pDevice->SlaveAdr = 0xAE;
 8002a64:	6823      	ldr	r3, [r4, #0]
 8002a66:	681b      	ldr	r3, [r3, #0]
 8002a68:	22ae      	movs	r2, #174	; 0xae
 8002a6a:	711a      	strb	r2, [r3, #4]
    pA->pEEP->pDeviceID->SlaveAdr = 0xBE;
 8002a6c:	6823      	ldr	r3, [r4, #0]
 8002a6e:	685b      	ldr	r3, [r3, #4]
 8002a70:	3210      	adds	r2, #16
 8002a72:	711a      	strb	r2, [r3, #4]
    if(Is_EEP_Detected(pA->pEEP)) { // the EEPROM is I2C Acked
 8002a74:	6820      	ldr	r0, [r4, #0]
 8002a76:	f7ff fcdf 	bl	8002438 <Is_EEP_Detected>
 8002a7a:	2800      	cmp	r0, #0
 8002a7c:	d00a      	beq.n	8002a94 <Add_on_Board_50msec+0x72>
      pA->IsPresentCounter_50msec = min2(0xFFFFFFFE, pA->IsPresentCounter_50msec+1); // increase the match counter
 8002a7e:	6863      	ldr	r3, [r4, #4]
 8002a80:	1c9a      	adds	r2, r3, #2
 8002a82:	d000      	beq.n	8002a86 <Add_on_Board_50msec+0x64>
 8002a84:	3301      	adds	r3, #1
 8002a86:	6063      	str	r3, [r4, #4]
      if(pA->IsPresentCounter_50msec == 3) // triple confirmed, let get the processing now
 8002a88:	2b03      	cmp	r3, #3
 8002a8a:	d1e0      	bne.n	8002a4e <Add_on_Board_50msec+0x2c>
        JustPlugged(pA);
 8002a8c:	0020      	movs	r0, r4
 8002a8e:	f7ff ffa3 	bl	80029d8 <JustPlugged>
 8002a92:	e7dc      	b.n	8002a4e <Add_on_Board_50msec+0x2c>
      if(pA->IsPlugged)
 8002a94:	7a63      	ldrb	r3, [r4, #9]
 8002a96:	2b00      	cmp	r3, #0
 8002a98:	d102      	bne.n	8002aa0 <Add_on_Board_50msec+0x7e>
      pA->IsPlugged = 0;    
 8002a9a:	2300      	movs	r3, #0
 8002a9c:	7263      	strb	r3, [r4, #9]
 8002a9e:	e7d6      	b.n	8002a4e <Add_on_Board_50msec+0x2c>
        JustUnPlugged(pA);
 8002aa0:	0020      	movs	r0, r4
 8002aa2:	f7ff ff1f 	bl	80028e4 <JustUnPlugged>
 8002aa6:	e7f8      	b.n	8002a9a <Add_on_Board_50msec+0x78>
  case B_OPTO_INERT_BOARD:              OI_50ms(); break; // 8
 8002aa8:	f7fd fe5a 	bl	8000760 <OI_50ms>
}
 8002aac:	e7d5      	b.n	8002a5a <Add_on_Board_50msec+0x38>

08002aae <Add_on_BoardReport>:

// B_HMI_LCD16x2_t B_HMI_LCD16x2 with StringID = B-HMI-LCD16x2 (or FFFFFFFF)

//=== bluetooth electronics reporting specific functions for the add-on board, if any
int32_t Add_on_BoardReport(ADD_ON_BOARD_t* pA) {
 8002aae:	b510      	push	{r4, lr}
 
  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002ab0:	7a43      	ldrb	r3, [r0, #9]
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d009      	beq.n	8002aca <Add_on_BoardReport+0x1c>

  switch(pA->ID_Code) {
 8002ab6:	232b      	movs	r3, #43	; 0x2b
 8002ab8:	5cc3      	ldrb	r3, [r0, r3]
 8002aba:	2b08      	cmp	r3, #8
 8002abc:	d001      	beq.n	8002ac2 <Add_on_BoardReport+0x14>
#endif  
//  case STM32WL55C_DK1_BOARD:            WL_Report(); break;
  default: ;//TrapError();
  }

  return 0;
 8002abe:	2000      	movs	r0, #0
}
 8002ac0:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_Report(); break; // 8
 8002ac2:	f7fd fe5f 	bl	8000784 <OI_Report>
  return 0;
 8002ac6:	2000      	movs	r0, #0
  case B_OPTO_INERT_BOARD:              OI_Report(); break; // 8
 8002ac8:	e7fa      	b.n	8002ac0 <Add_on_BoardReport+0x12>
  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002aca:	2001      	movs	r0, #1
 8002acc:	4240      	negs	r0, r0
 8002ace:	e7f7      	b.n	8002ac0 <Add_on_BoardReport+0x12>

08002ad0 <AddOnPaneProcess>:

int32_t AddOnPaneProcess(ADD_ON_BOARD_t* pA) {
 8002ad0:	b510      	push	{r4, lr}
 
  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002ad2:	7a43      	ldrb	r3, [r0, #9]
 8002ad4:	2b00      	cmp	r3, #0
 8002ad6:	d009      	beq.n	8002aec <AddOnPaneProcess+0x1c>

  switch(pA->ID_Code) {
 8002ad8:	232b      	movs	r3, #43	; 0x2b
 8002ada:	5cc3      	ldrb	r3, [r0, r3]
 8002adc:	2b08      	cmp	r3, #8
 8002ade:	d001      	beq.n	8002ae4 <AddOnPaneProcess+0x14>
#endif  
//  case STM32WL55C_DK1_BOARD:            WL_PaneProcess();break;
  default: ;//TrapError();
  }

  return 0;
 8002ae0:	2000      	movs	r0, #0
}
 8002ae2:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_PaneProcess(); break; // 8
 8002ae4:	f7fd ff26 	bl	8000934 <OI_PaneProcess>
  return 0;
 8002ae8:	2000      	movs	r0, #0
  case B_OPTO_INERT_BOARD:              OI_PaneProcess(); break; // 8
 8002aea:	e7fa      	b.n	8002ae2 <AddOnPaneProcess+0x12>
  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002aec:	2001      	movs	r0, #1
 8002aee:	4240      	negs	r0, r0
 8002af0:	e7f7      	b.n	8002ae2 <AddOnPaneProcess+0x12>

08002af2 <Add_on_Board_SetPanel>:

int32_t Add_on_Board_SetPanel(ADD_ON_BOARD_t* pA) {
 8002af2:	b510      	push	{r4, lr}

  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002af4:	7a43      	ldrb	r3, [r0, #9]
 8002af6:	2b00      	cmp	r3, #0
 8002af8:	d009      	beq.n	8002b0e <Add_on_Board_SetPanel+0x1c>

  switch(pA->ID_Code) {
 8002afa:	232b      	movs	r3, #43	; 0x2b
 8002afc:	5cc3      	ldrb	r3, [r0, r3]
 8002afe:	2b08      	cmp	r3, #8
 8002b00:	d001      	beq.n	8002b06 <Add_on_Board_SetPanel+0x14>
#endif  
//  case STM32WL55C_DK1_BOARD:            WL_SetPanel(); break;
  default: ;//TrapError();
  }

  return 0;
 8002b02:	2000      	movs	r0, #0
}
 8002b04:	bd10      	pop	{r4, pc}
  case B_OPTO_INERT_BOARD:              OI_SetPanel(); break; // 8
 8002b06:	f7fd ff2f 	bl	8000968 <OI_SetPanel>
  return 0;
 8002b0a:	2000      	movs	r0, #0
  case B_OPTO_INERT_BOARD:              OI_SetPanel(); break; // 8
 8002b0c:	e7fa      	b.n	8002b04 <Add_on_Board_SetPanel+0x12>
  if(pA->IsPlugged == 0) return -1; // nothing to report, there is no add-on board
 8002b0e:	2001      	movs	r0, #1
 8002b10:	4240      	negs	r0, r0
 8002b12:	e7f7      	b.n	8002b04 <Add_on_Board_SetPanel+0x12>

08002b14 <RockGetKey>:
	IO_PadInit((IO_Pad_t*)&UserRockSwitchAnalog); // this should be done after any PA4 GPIO configuration, or in the main loop
}

uint8_t RockGetKey(void) {

	uint16_t lsb = Analog.ADCs.Normal_Lsb[2];
 8002b14:	4b07      	ldr	r3, [pc, #28]	; (8002b34 <RockGetKey+0x20>)
 8002b16:	8899      	ldrh	r1, [r3, #4]
	uint8_t i;
	for(i = 0; i<COUNTOF(rock_limits); i++) {
 8002b18:	2000      	movs	r0, #0
 8002b1a:	2804      	cmp	r0, #4
 8002b1c:	d807      	bhi.n	8002b2e <RockGetKey+0x1a>
		if(lsb<=rock_limits[i])
 8002b1e:	0043      	lsls	r3, r0, #1
 8002b20:	4a05      	ldr	r2, [pc, #20]	; (8002b38 <RockGetKey+0x24>)
 8002b22:	5a9b      	ldrh	r3, [r3, r2]
 8002b24:	428b      	cmp	r3, r1
 8002b26:	d203      	bcs.n	8002b30 <RockGetKey+0x1c>
	for(i = 0; i<COUNTOF(rock_limits); i++) {
 8002b28:	3001      	adds	r0, #1
 8002b2a:	b2c0      	uxtb	r0, r0
 8002b2c:	e7f5      	b.n	8002b1a <RockGetKey+0x6>
			return i;
	}

	return ROCK_UNPRESSED;
 8002b2e:	2005      	movs	r0, #5
}
 8002b30:	4770      	bx	lr
 8002b32:	46c0      	nop			; (mov r8, r8)
 8002b34:	200021bc 	.word	0x200021bc
 8002b38:	080061c0 	.word	0x080061c0

08002b3c <AnalogInit>:


#ifndef hadc1
  ADC_HandleTypeDef hadc1;
#endif
void AnalogInit(void) {
 8002b3c:	b500      	push	{lr}
 8002b3e:	b083      	sub	sp, #12
  // we will use manual single channel conversion as simple 8 bit MCU. Non optimal.

//  ADC_ChannelConfTypeDef sConfig;
//  ADC_InjectionConfTypeDef sConfigInjected;

  __HAL_RCC_ADC_CLK_ENABLE();;//ClockGateEnable_PPP((uint32_t) ADCx, ENABLE); // Enable ADC Clocks
 8002b40:	4a1a      	ldr	r2, [pc, #104]	; (8002bac <AnalogInit+0x70>)
 8002b42:	6c11      	ldr	r1, [r2, #64]	; 0x40
 8002b44:	2080      	movs	r0, #128	; 0x80
 8002b46:	0340      	lsls	r0, r0, #13
 8002b48:	4301      	orrs	r1, r0
 8002b4a:	6411      	str	r1, [r2, #64]	; 0x40
 8002b4c:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8002b4e:	4003      	ands	r3, r0
 8002b50:	9301      	str	r3, [sp, #4]
 8002b52:	9b01      	ldr	r3, [sp, #4]
 //because it's void without MX! HAL_ADC_DeInit(&hadc1);
  hadc1.Instance = ADC1;
 8002b54:	4816      	ldr	r0, [pc, #88]	; (8002bb0 <AnalogInit+0x74>)
 8002b56:	4b17      	ldr	r3, [pc, #92]	; (8002bb4 <AnalogInit+0x78>)
 8002b58:	6003      	str	r3, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;//ADC_CLOCK_ASYNC_DIV2;//ADC_CLOCK_SYNC_PCLK_DIV2; // 48/2 /2 = 12 MHz
 8002b5a:	2380      	movs	r3, #128	; 0x80
 8002b5c:	05db      	lsls	r3, r3, #23
 8002b5e:	6043      	str	r3, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 8002b60:	2300      	movs	r3, #0
 8002b62:	6083      	str	r3, [r0, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8002b64:	60c3      	str	r3, [r0, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;//- ADC_SCAN_ENABLE;
 8002b66:	6103      	str	r3, [r0, #16]
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8002b68:	2204      	movs	r2, #4
 8002b6a:	6142      	str	r2, [r0, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8002b6c:	7603      	strb	r3, [r0, #24]
  hadc1.Init.LowPowerAutoPowerOff = DISABLE;
 8002b6e:	7643      	strb	r3, [r0, #25]
  hadc1.Init.ContinuousConvMode = DISABLE;//ENABLE;//DISABLE;
 8002b70:	7683      	strb	r3, [r0, #26]
  hadc1.Init.NbrOfConversion = 1;//COUNTOF(sConfigs);
 8002b72:	3a03      	subs	r2, #3
 8002b74:	61c2      	str	r2, [r0, #28]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8002b76:	321f      	adds	r2, #31
 8002b78:	5483      	strb	r3, [r0, r2]
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8002b7a:	6243      	str	r3, [r0, #36]	; 0x24
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8002b7c:	6283      	str	r3, [r0, #40]	; 0x28
  hadc1.Init.DMAContinuousRequests = DISABLE;//ENABLE;// DISABLE;
 8002b7e:	320c      	adds	r2, #12
 8002b80:	5483      	strb	r3, [r0, r2]
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8002b82:	6303      	str	r3, [r0, #48]	; 0x30
  hadc1.Init.SamplingTimeCommon1 = ADC_SAMPLETIME_160CYCLES_5;//ADC_SAMPLETIME_12CYCLES_5;//ADC_SAMPLETIME_1CYCLE_5;//ADC_SAMPLETIME_160CYCLES_5;//ADC_SAMPLETIME_1CYCLE_5;
 8002b84:	3a25      	subs	r2, #37	; 0x25
 8002b86:	6342      	str	r2, [r0, #52]	; 0x34
  hadc1.Init.SamplingTimeCommon2 = ADC_SAMPLETIME_39CYCLES_5;//ADC_SAMPLETIME_12CYCLES_5;//ADC_SAMPLETIME_1CYCLE_5;
 8002b88:	3a02      	subs	r2, #2
 8002b8a:	6382      	str	r2, [r0, #56]	; 0x38
  hadc1.Init.OversamplingMode = DISABLE;
 8002b8c:	3237      	adds	r2, #55	; 0x37
 8002b8e:	5483      	strb	r3, [r0, r2]
  hadc1.Init.TriggerFrequencyMode = ADC_TRIGGER_FREQ_HIGH;
 8002b90:	64c3      	str	r3, [r0, #76]	; 0x4c

  if (HAL_ADC_Init(&hadc1) != HAL_OK)  {
 8002b92:	f000 fde1 	bl	8003758 <HAL_ADC_Init>
 8002b96:	2800      	cmp	r0, #0
 8002b98:	d104      	bne.n	8002ba4 <AnalogInit+0x68>
    Error_Handler();
  }

  __HAL_LINKDMA(&hadc1,DMA_Handle,hdma_adc1);
#endif
  HAL_ADCEx_Calibration_Start(&hadc1/*, ADC_SINGLE_ENDED*/);
 8002b9a:	4805      	ldr	r0, [pc, #20]	; (8002bb0 <AnalogInit+0x74>)
 8002b9c:	f001 f98e 	bl	8003ebc <HAL_ADCEx_Calibration_Start>
    	NOPs(1);// breakpoint hook
    	break;
    }
 // return; // go back to main...
  }
}
 8002ba0:	b003      	add	sp, #12
 8002ba2:	bd00      	pop	{pc}
    Error_Handler();
 8002ba4:	f000 fc90 	bl	80034c8 <Error_Handler>
 8002ba8:	e7f7      	b.n	8002b9a <AnalogInit+0x5e>
 8002baa:	46c0      	nop			; (mov r8, r8)
 8002bac:	40021000 	.word	0x40021000
 8002bb0:	20002218 	.word	0x20002218
 8002bb4:	40012400 	.word	0x40012400

08002bb8 <ADC_Normal_LsbTo_mV>:


//============================== The public functions to build your system mecanics

uint32_t ADC_Normal_LsbTo_mV(ADC_t* A, uint32_t Lsb) {
 8002bb8:	b500      	push	{lr}
 8002bba:	b083      	sub	sp, #12
  uint32_t mV = Interpolate_i32 (0, 0x0FFF, 0, A->VRef_mV, Lsb);  
 8002bbc:	6a03      	ldr	r3, [r0, #32]
 8002bbe:	9100      	str	r1, [sp, #0]
 8002bc0:	2200      	movs	r2, #0
 8002bc2:	4903      	ldr	r1, [pc, #12]	; (8002bd0 <ADC_Normal_LsbTo_mV+0x18>)
 8002bc4:	2000      	movs	r0, #0
 8002bc6:	f000 fb7c 	bl	80032c2 <Interpolate_i32>
  return mV;
}
 8002bca:	b003      	add	sp, #12
 8002bcc:	bd00      	pop	{pc}
 8002bce:	46c0      	nop			; (mov r8, r8)
 8002bd0:	00000fff 	.word	0x00000fff

08002bd4 <ADC_Convert_mV_to_DegC_x10>:
  int32_t ADC_Num, ADC_Denum;
  int32_t DegC_x10;
*/
//===================== 8>< ----------------------------------

int32_t ADC_Convert_mV_to_DegC_x10(ADC_t* A, uint32_t Lsb) {
 8002bd4:	b570      	push	{r4, r5, r6, lr}
 8002bd6:	b082      	sub	sp, #8
 8002bd8:	0004      	movs	r4, r0
  int32_t Deg30Lsb;
  int32_t Deg130Lsb;
  //int32_t ADC_Num, ADC_Denum;
  int32_t DegC_x10;
  
  Deg30Lsb = (int32_t)(*((uint16_t*) 0x1FFF7568));  // 3.0V +/- 10mV
 8002bda:	4b0c      	ldr	r3, [pc, #48]	; (8002c0c <ADC_Convert_mV_to_DegC_x10+0x38>)
 8002bdc:	881d      	ldrh	r5, [r3, #0]
  Deg130Lsb = Deg30Lsb + 343; // +100 degC at 2.53mV per degree at 3.0V Vdda result in an offset of 343 lsb
 8002bde:	002e      	movs	r6, r5
 8002be0:	3658      	adds	r6, #88	; 0x58
 8002be2:	36ff      	adds	r6, #255	; 0xff
  // we first convert the LSB calibrated Flash values to mV (let's remove the sign issue between normal and injected channels)

  
  // convert ADC value to 3.0 Vdd vs measured value
  Lsb = (Lsb*A->MeasuredVdd_mV)/3000; // scale the LSB to 3.0V
 8002be4:	2352      	movs	r3, #82	; 0x52
 8002be6:	5ec0      	ldrsh	r0, [r0, r3]
 8002be8:	4348      	muls	r0, r1
 8002bea:	4909      	ldr	r1, [pc, #36]	; (8002c10 <ADC_Convert_mV_to_DegC_x10+0x3c>)
 8002bec:	f7fd fa8c 	bl	8000108 <__udivsi3>
  
  DegC_x10 = Interpolate_i32 (Deg30Lsb, Deg130Lsb, 300U, 1300U, (int32_t)(int16_t)Lsb);
 8002bf0:	b200      	sxth	r0, r0
 8002bf2:	2296      	movs	r2, #150	; 0x96
 8002bf4:	9000      	str	r0, [sp, #0]
 8002bf6:	4b07      	ldr	r3, [pc, #28]	; (8002c14 <ADC_Convert_mV_to_DegC_x10+0x40>)
 8002bf8:	0052      	lsls	r2, r2, #1
 8002bfa:	0031      	movs	r1, r6
 8002bfc:	0028      	movs	r0, r5
 8002bfe:	f000 fb60 	bl	80032c2 <Interpolate_i32>

  A->Temp_degC_x10 = DegC_x10; // capture the value for debugging or reference
 8002c02:	2350      	movs	r3, #80	; 0x50
 8002c04:	52e0      	strh	r0, [r4, r3]
  return DegC_x10;
}
 8002c06:	b002      	add	sp, #8
 8002c08:	bd70      	pop	{r4, r5, r6, pc}
 8002c0a:	46c0      	nop			; (mov r8, r8)
 8002c0c:	1fff7568 	.word	0x1fff7568
 8002c10:	00000bb8 	.word	0x00000bb8
 8002c14:	00000514 	.word	0x00000514

08002c18 <ADC_Convert_VRefByLsb>:

//volatile int32_t monitor;
int32_t ADC_Convert_VRefByLsb(ADC_t* A, uint32_t Lsb) {
 8002c18:	b510      	push	{r4, lr}
 8002c1a:	0004      	movs	r4, r0
  // Vref = 1.212V
  int32_t VRefLsb3p3V_Lsb = (int32_t)(*((uint16_t*) 0x1FFF756A )); // this contains the ADC 12 bit right aligned injected raw data for Vref LSB at 30C and 3.0V
 8002c1c:	4b04      	ldr	r3, [pc, #16]	; (8002c30 <ADC_Convert_VRefByLsb+0x18>)
 8002c1e:	881b      	ldrh	r3, [r3, #0]
//  monitor = VRefLsb3p3V_Lsb;
  uint32_t Vdd_mV = (3000*VRefLsb3p3V_Lsb)/Lsb;
 8002c20:	4804      	ldr	r0, [pc, #16]	; (8002c34 <ADC_Convert_VRefByLsb+0x1c>)
 8002c22:	4358      	muls	r0, r3
 8002c24:	f7fd fa70 	bl	8000108 <__udivsi3>
  A->MeasuredVdd_mV = Vdd_mV;
 8002c28:	2352      	movs	r3, #82	; 0x52
 8002c2a:	52e0      	strh	r0, [r4, r3]
  return 0;
}
 8002c2c:	2000      	movs	r0, #0
 8002c2e:	bd10      	pop	{r4, pc}
 8002c30:	1fff756a 	.word	0x1fff756a
 8002c34:	00000bb8 	.word	0x00000bb8

08002c38 <ADC_MultiShotNoDMA>:

//===================== 8>< ----------------------------------
  
void ADC_MultiShotNoDMA(ADC_HandleTypeDef* A);  

void ADC_MultiShotNoDMA(ADC_HandleTypeDef* A) {
 8002c38:	b570      	push	{r4, r5, r6, lr}
 8002c3a:	0005      	movs	r5, r0
  uint32_t dr;
  /** Configure Regular Channel
  */
  
  for(int i = 0; i<COUNTOF(sConfigs); i++) {
 8002c3c:	2400      	movs	r4, #0
 8002c3e:	2c05      	cmp	r4, #5
 8002c40:	d81c      	bhi.n	8002c7c <ADC_MultiShotNoDMA+0x44>
    if (HAL_ADC_ConfigChannel(A, (ADC_ChannelConfTypeDef*)&sConfigs[i]) != HAL_OK) while(1);
 8002c42:	0061      	lsls	r1, r4, #1
 8002c44:	1909      	adds	r1, r1, r4
 8002c46:	0089      	lsls	r1, r1, #2
 8002c48:	4b0d      	ldr	r3, [pc, #52]	; (8002c80 <ADC_MultiShotNoDMA+0x48>)
 8002c4a:	1859      	adds	r1, r3, r1
 8002c4c:	0028      	movs	r0, r5
 8002c4e:	f000 ff17 	bl	8003a80 <HAL_ADC_ConfigChannel>
 8002c52:	2800      	cmp	r0, #0
 8002c54:	d110      	bne.n	8002c78 <ADC_MultiShotNoDMA+0x40>
    HAL_ADC_Start(A);
 8002c56:	0028      	movs	r0, r5
 8002c58:	f001 f8b6 	bl	8003dc8 <HAL_ADC_Start>
    if(HAL_ADC_PollForConversion(A, 2) != HAL_OK)     while(1);
 8002c5c:	2102      	movs	r1, #2
 8002c5e:	0028      	movs	r0, r5
 8002c60:	f000 feae 	bl	80039c0 <HAL_ADC_PollForConversion>
 8002c64:	2800      	cmp	r0, #0
 8002c66:	d108      	bne.n	8002c7a <ADC_MultiShotNoDMA+0x42>
    Analog.ADCs.Normal_Lsb[i] = dr = HAL_ADC_GetValue(A);
 8002c68:	0028      	movs	r0, r5
 8002c6a:	f000 ff05 	bl	8003a78 <HAL_ADC_GetValue>
 8002c6e:	0063      	lsls	r3, r4, #1
 8002c70:	4a04      	ldr	r2, [pc, #16]	; (8002c84 <ADC_MultiShotNoDMA+0x4c>)
 8002c72:	52d0      	strh	r0, [r2, r3]
  for(int i = 0; i<COUNTOF(sConfigs); i++) {
 8002c74:	3401      	adds	r4, #1
 8002c76:	e7e2      	b.n	8002c3e <ADC_MultiShotNoDMA+0x6>
    if (HAL_ADC_ConfigChannel(A, (ADC_ChannelConfTypeDef*)&sConfigs[i]) != HAL_OK) while(1);
 8002c78:	e7fe      	b.n	8002c78 <ADC_MultiShotNoDMA+0x40>
    if(HAL_ADC_PollForConversion(A, 2) != HAL_OK)     while(1);
 8002c7a:	e7fe      	b.n	8002c7a <ADC_MultiShotNoDMA+0x42>
  }
  
}
 8002c7c:	bd70      	pop	{r4, r5, r6, pc}
 8002c7e:	46c0      	nop			; (mov r8, r8)
 8002c80:	080061cc 	.word	0x080061cc
 8002c84:	200021bc 	.word	0x200021bc

08002c88 <ADC_UpdateConveredValues>:


void ADC_UpdateConveredValues(ADC_t* A) {
 8002c88:	b570      	push	{r4, r5, r6, lr}
 8002c8a:	0005      	movs	r5, r0
  
  uint8_t i;

#if 1
  // we do one shot mode, no DMA assist
  ADC_MultiShotNoDMA(&hadc1);
 8002c8c:	480e      	ldr	r0, [pc, #56]	; (8002cc8 <ADC_UpdateConveredValues+0x40>)
 8002c8e:	f7ff ffd3 	bl	8002c38 <ADC_MultiShotNoDMA>
#endif
   
  
  A->VRef_mV = 3300;
 8002c92:	4b0e      	ldr	r3, [pc, #56]	; (8002ccc <ADC_UpdateConveredValues+0x44>)
 8002c94:	622b      	str	r3, [r5, #32]
  // mmeasure the real Vdd (3.3V?)
  ADC_Convert_VRefByLsb(A, A->Normal_Lsb[0]);
 8002c96:	8829      	ldrh	r1, [r5, #0]
 8002c98:	0028      	movs	r0, r5
 8002c9a:	f7ff ffbd 	bl	8002c18 <ADC_Convert_VRefByLsb>
  // use the precise measurement as reference
  //A->VRef_mV = A->MeasuredVdd_mV; // hmm....  
  // convert all channels to their mV equivalent
  for(i=0; i<COUNTOF(sConfigs); i++)
 8002c9e:	2400      	movs	r4, #0
 8002ca0:	e00a      	b.n	8002cb8 <ADC_UpdateConveredValues+0x30>
    A->Normal_mV[i] = ADC_Normal_LsbTo_mV(A, A->Normal_Lsb[i]);
 8002ca2:	0063      	lsls	r3, r4, #1
 8002ca4:	5b59      	ldrh	r1, [r3, r5]
 8002ca6:	0028      	movs	r0, r5
 8002ca8:	f7ff ff86 	bl	8002bb8 <ADC_Normal_LsbTo_mV>
 8002cac:	0023      	movs	r3, r4
 8002cae:	3314      	adds	r3, #20
 8002cb0:	005b      	lsls	r3, r3, #1
 8002cb2:	52e8      	strh	r0, [r5, r3]
  for(i=0; i<COUNTOF(sConfigs); i++)
 8002cb4:	3401      	adds	r4, #1
 8002cb6:	b2e4      	uxtb	r4, r4
 8002cb8:	2c05      	cmp	r4, #5
 8002cba:	d9f2      	bls.n	8002ca2 <ADC_UpdateConveredValues+0x1a>
  // get the Vbat value
  //A->MeasuredVBat_mV = A->Normal_mV[0]*(5000/750); // external divider 100k over 200k, followed with divider which is also always on... CH18 is static!!!!
  // get the temperature
  ADC_Convert_mV_to_DegC_x10(A,A->Normal_Lsb[1]);
 8002cbc:	8869      	ldrh	r1, [r5, #2]
 8002cbe:	0028      	movs	r0, r5
 8002cc0:	f7ff ff88 	bl	8002bd4 <ADC_Convert_mV_to_DegC_x10>
  
}
 8002cc4:	bd70      	pop	{r4, r5, r6, pc}
 8002cc6:	46c0      	nop			; (mov r8, r8)
 8002cc8:	20002218 	.word	0x20002218
 8002ccc:	00000ce4 	.word	0x00000ce4

08002cd0 <Brisk_1ms_ISR>:
uint32_t Brisk_1sec_Counter;


void Brisk_1ms_ISR(void) {

  Brisk_1ms_Counter++;
 8002cd0:	4a0f      	ldr	r2, [pc, #60]	; (8002d10 <Brisk_1ms_ISR+0x40>)
 8002cd2:	6813      	ldr	r3, [r2, #0]
 8002cd4:	3301      	adds	r3, #1
 8002cd6:	6013      	str	r3, [r2, #0]
  if((Brisk_1ms_Counter % 8/*5*/)==0) { // optimisation for speed and size avoiding division on CortexM0
 8002cd8:	075a      	lsls	r2, r3, #29
 8002cda:	d117      	bne.n	8002d0c <Brisk_1ms_ISR+0x3c>
    Brisk_5ms_Flag = 1;
 8002cdc:	4a0d      	ldr	r2, [pc, #52]	; (8002d14 <Brisk_1ms_ISR+0x44>)
 8002cde:	2101      	movs	r1, #1
 8002ce0:	7011      	strb	r1, [r2, #0]
    if((Brisk_1ms_Counter % 16 /*10*/)==0) {
 8002ce2:	071a      	lsls	r2, r3, #28
 8002ce4:	d112      	bne.n	8002d0c <Brisk_1ms_ISR+0x3c>
      Brisk_10ms_Flag = 1;
 8002ce6:	4a0c      	ldr	r2, [pc, #48]	; (8002d18 <Brisk_1ms_ISR+0x48>)
 8002ce8:	7011      	strb	r1, [r2, #0]
      if((Brisk_1ms_Counter % 64 /*50*/)==0) {
 8002cea:	069a      	lsls	r2, r3, #26
 8002cec:	d10e      	bne.n	8002d0c <Brisk_1ms_ISR+0x3c>
        Brisk_50ms_Flag = 1;
 8002cee:	4a0b      	ldr	r2, [pc, #44]	; (8002d1c <Brisk_1ms_ISR+0x4c>)
 8002cf0:	7011      	strb	r1, [r2, #0]
        if((Brisk_1ms_Counter % 128 /*100*/)==0) {
 8002cf2:	065a      	lsls	r2, r3, #25
 8002cf4:	d10a      	bne.n	8002d0c <Brisk_1ms_ISR+0x3c>
          Brisk_100ms_Flag = 1;
 8002cf6:	4a0a      	ldr	r2, [pc, #40]	; (8002d20 <Brisk_1ms_ISR+0x50>)
 8002cf8:	7011      	strb	r1, [r2, #0]
          if((Brisk_1ms_Counter % 1024 /*1000*/)==0) {
 8002cfa:	059b      	lsls	r3, r3, #22
 8002cfc:	d106      	bne.n	8002d0c <Brisk_1ms_ISR+0x3c>
            Brisk_1sec_Flag = 1;
 8002cfe:	4b09      	ldr	r3, [pc, #36]	; (8002d24 <Brisk_1ms_ISR+0x54>)
 8002d00:	2201      	movs	r2, #1
 8002d02:	701a      	strb	r2, [r3, #0]
            Brisk_1sec_Counter++; 
 8002d04:	4a08      	ldr	r2, [pc, #32]	; (8002d28 <Brisk_1ms_ISR+0x58>)
 8002d06:	6813      	ldr	r3, [r2, #0]
 8002d08:	3301      	adds	r3, #1
 8002d0a:	6013      	str	r3, [r2, #0]
          }
        }
      }
    }
  }
}
 8002d0c:	4770      	bx	lr
 8002d0e:	46c0      	nop			; (mov r8, r8)
 8002d10:	20002280 	.word	0x20002280
 8002d14:	2000228a 	.word	0x2000228a
 8002d18:	2000227d 	.word	0x2000227d
 8002d1c:	20002289 	.word	0x20002289
 8002d20:	2000227c 	.word	0x2000227c
 8002d24:	20002288 	.word	0x20002288
 8002d28:	20002284 	.word	0x20002284

08002d2c <UserKeyInit>:
//IO_Pin_t UserKeyPin =    {  GPIOA, {    GPIO_PIN_4, GPIO_MODE_INPUT, GPIO_PULLUP, GPIO_SPEED_FREQ_LOW,          0,   } }; // as digital push-in button, can also be used as analog keyboard...




int32_t UserKeyInit(void) {
 8002d2c:	b510      	push	{r4, lr}
  
  IO_PadInit((IO_Pad_t*)&UserKeyPin); // input with pull up
 8002d2e:	4802      	ldr	r0, [pc, #8]	; (8002d38 <UserKeyInit+0xc>)
 8002d30:	f002 fbb4 	bl	800549c <IO_PadInit>
  return 0;
}
 8002d34:	2000      	movs	r0, #0
 8002d36:	bd10      	pop	{r4, pc}
 8002d38:	08006218 	.word	0x08006218

08002d3c <Brisk_PostInit>:
void Brisk_PostInit(void) { // hook from main() after HAL initialisation (override here)
 8002d3c:	b510      	push	{r4, lr}
  Add_on_Board_Init(&STModADD_On); // 18/11/19
 8002d3e:	4826      	ldr	r0, [pc, #152]	; (8002dd8 <Brisk_PostInit+0x9c>)
 8002d40:	f7ff fdbe 	bl	80028c0 <Add_on_Board_Init>
  BriskTimedLEDsInit();
 8002d44:	f7ff fb74 	bl	8002430 <BriskTimedLEDsInit>
  for(i=1;i<=1;i++, MinDelay_ms(15))
 8002d48:	2401      	movs	r4, #1
 8002d4a:	2c01      	cmp	r4, #1
 8002d4c:	d90f      	bls.n	8002d6e <Brisk_PostInit+0x32>
  BriskDimTimedLED(1, 100);
 8002d4e:	2164      	movs	r1, #100	; 0x64
 8002d50:	2001      	movs	r0, #1
 8002d52:	f7ff faaf 	bl	80022b4 <BriskDimTimedLED>
  BriskBlinkTimedLED(1, 1000, 500, BRISK_LED_BLINK_FOREVER );
 8002d56:	22fa      	movs	r2, #250	; 0xfa
 8002d58:	21fa      	movs	r1, #250	; 0xfa
 8002d5a:	23ff      	movs	r3, #255	; 0xff
 8002d5c:	0052      	lsls	r2, r2, #1
 8002d5e:	0089      	lsls	r1, r1, #2
 8002d60:	2001      	movs	r0, #1
 8002d62:	f7ff fabf 	bl	80022e4 <BriskBlinkTimedLED>
  Brisk_I2C_MasterIO_Init();
 8002d66:	f7fe feef 	bl	8001b48 <Brisk_I2C_MasterIO_Init>
  StartAdr = 0;
 8002d6a:	2400      	movs	r4, #0
  while(StartAdr = I2C_MasterIO_FindNextSlaveByAddress(&gI2C_STMod, StartAdr)) {
 8002d6c:	e00c      	b.n	8002d88 <Brisk_PostInit+0x4c>
    BriskDimLED(i, BRISK_LED_OFF);
 8002d6e:	2100      	movs	r1, #0
 8002d70:	0020      	movs	r0, r4
 8002d72:	f7ff fa1b 	bl	80021ac <BriskDimLED>
  for(i=1;i<=1;i++, MinDelay_ms(15))
 8002d76:	3401      	adds	r4, #1
 8002d78:	b2e4      	uxtb	r4, r4
 8002d7a:	200f      	movs	r0, #15
 8002d7c:	f000 fa96 	bl	80032ac <MinDelay_ms>
 8002d80:	e7e3      	b.n	8002d4a <Brisk_PostInit+0xe>
      NOPs(1); // Breakpoint here to sweep and find all I2C slaves on the bus (handy for board bringup, alive test)
 8002d82:	2001      	movs	r0, #1
 8002d84:	f000 fa82 	bl	800328c <NOPs>
  while(StartAdr = I2C_MasterIO_FindNextSlaveByAddress(&gI2C_STMod, StartAdr)) {
 8002d88:	0021      	movs	r1, r4
 8002d8a:	4814      	ldr	r0, [pc, #80]	; (8002ddc <Brisk_PostInit+0xa0>)
 8002d8c:	f7fe fec5 	bl	8001b1a <I2C_MasterIO_FindNextSlaveByAddress>
 8002d90:	1e04      	subs	r4, r0, #0
 8002d92:	d1f6      	bne.n	8002d82 <Brisk_PostInit+0x46>
  NOPs(1); // breakpoint hook
 8002d94:	2001      	movs	r0, #1
 8002d96:	f000 fa79 	bl	800328c <NOPs>
  while(StartAdr = I2C_MasterIO_FindNextSlaveByAddress(&gI2C_Arduino, StartAdr)) {
 8002d9a:	e002      	b.n	8002da2 <Brisk_PostInit+0x66>
      NOPs(1); // Breakpoint here to sweep and find all I2C slaves on the bus (handy for board bringup, alive test)
 8002d9c:	2001      	movs	r0, #1
 8002d9e:	f000 fa75 	bl	800328c <NOPs>
  while(StartAdr = I2C_MasterIO_FindNextSlaveByAddress(&gI2C_Arduino, StartAdr)) {
 8002da2:	0021      	movs	r1, r4
 8002da4:	480e      	ldr	r0, [pc, #56]	; (8002de0 <Brisk_PostInit+0xa4>)
 8002da6:	f7fe feb8 	bl	8001b1a <I2C_MasterIO_FindNextSlaveByAddress>
 8002daa:	1e04      	subs	r4, r0, #0
 8002dac:	d1f6      	bne.n	8002d9c <Brisk_PostInit+0x60>
  NOPs(1); // breakpoint hook
 8002dae:	2001      	movs	r0, #1
 8002db0:	f000 fa6c 	bl	800328c <NOPs>
  SPIP_SIF_Init();
 8002db4:	f7ff fcf2 	bl	800279c <SPIP_SIF_Init>
  UserKeyInit(); // mae it analog input
 8002db8:	f7ff ffb8 	bl	8002d2c <UserKeyInit>
  AnalogInit();
 8002dbc:	f7ff febe 	bl	8002b3c <AnalogInit>
  BTEL_Init(); // Bluetooth Electronics Android AP using BT HC-06 Serial link over STMod+ by default
 8002dc0:	f7fe f9d0 	bl	8001164 <BTEL_Init>
  UserKeyInit();
 8002dc4:	f7ff ffb2 	bl	8002d2c <UserKeyInit>
  IO_PadInit((IO_Pad_t*)&PA11_Default);
 8002dc8:	4806      	ldr	r0, [pc, #24]	; (8002de4 <Brisk_PostInit+0xa8>)
 8002dca:	f002 fb67 	bl	800549c <IO_PadInit>
  INTs_AllStats_Init();
 8002dce:	f7fe ff21 	bl	8001c14 <INTs_AllStats_Init>
IRQ_OVR_DemoEnter(); // activate MCO (until a plug and play STMod+ addon board is plugged in
 8002dd2:	f7ff f8bd 	bl	8001f50 <IRQ_OVR_DemoEnter>
}
 8002dd6:	bd10      	pop	{r4, pc}
 8002dd8:	200001b4 	.word	0x200001b4
 8002ddc:	20000594 	.word	0x20000594
 8002de0:	2000056c 	.word	0x2000056c
 8002de4:	08006214 	.word	0x08006214

08002de8 <UserKey_50ms>:

int32_t UserKey_50ms(void) {
 8002de8:	b510      	push	{r4, lr}
  
  UserKey.codebefore = UserKey.codenow;
 8002dea:	4c11      	ldr	r4, [pc, #68]	; (8002e30 <UserKey_50ms+0x48>)
 8002dec:	7963      	ldrb	r3, [r4, #5]
 8002dee:	7123      	strb	r3, [r4, #4]
  UserKey.codenow = RockGetKey();//==ROCK_SEL)
 8002df0:	f7ff fe90 	bl	8002b14 <RockGetKey>
 8002df4:	7160      	strb	r0, [r4, #5]
    
  //-------------------  
  if(UserKey.codebefore == UserKey.codenow) {
 8002df6:	7923      	ldrb	r3, [r4, #4]
 8002df8:	4298      	cmp	r0, r3
 8002dfa:	d004      	beq.n	8002e06 <UserKey_50ms+0x1e>
    else
      if(UserKey.PressedCount_50ms == 100)
        UserKey.Pressed_5sec = 1;
    
  }else{
    UserKey.PressedCount_50ms = 0;
 8002dfc:	4b0c      	ldr	r3, [pc, #48]	; (8002e30 <UserKey_50ms+0x48>)
 8002dfe:	2200      	movs	r2, #0
 8002e00:	609a      	str	r2, [r3, #8]
  }
  
  return 0;
}
 8002e02:	2000      	movs	r0, #0
 8002e04:	bd10      	pop	{r4, pc}
    UserKey.PressedCount_50ms = min2(UserKey.PressedCount_50ms + 1,200);
 8002e06:	4b0a      	ldr	r3, [pc, #40]	; (8002e30 <UserKey_50ms+0x48>)
 8002e08:	689b      	ldr	r3, [r3, #8]
 8002e0a:	2bc7      	cmp	r3, #199	; 0xc7
 8002e0c:	dd00      	ble.n	8002e10 <UserKey_50ms+0x28>
 8002e0e:	23c7      	movs	r3, #199	; 0xc7
 8002e10:	3301      	adds	r3, #1
 8002e12:	4a07      	ldr	r2, [pc, #28]	; (8002e30 <UserKey_50ms+0x48>)
 8002e14:	6093      	str	r3, [r2, #8]
    if(UserKey.PressedCount_50ms == 4)
 8002e16:	2b04      	cmp	r3, #4
 8002e18:	d005      	beq.n	8002e26 <UserKey_50ms+0x3e>
      if(UserKey.PressedCount_50ms == 100)
 8002e1a:	2b64      	cmp	r3, #100	; 0x64
 8002e1c:	d1f1      	bne.n	8002e02 <UserKey_50ms+0x1a>
        UserKey.Pressed_5sec = 1;
 8002e1e:	4b04      	ldr	r3, [pc, #16]	; (8002e30 <UserKey_50ms+0x48>)
 8002e20:	2201      	movs	r2, #1
 8002e22:	71da      	strb	r2, [r3, #7]
 8002e24:	e7ed      	b.n	8002e02 <UserKey_50ms+0x1a>
      UserKey.Pressed |= 1;
 8002e26:	7993      	ldrb	r3, [r2, #6]
 8002e28:	2101      	movs	r1, #1
 8002e2a:	430b      	orrs	r3, r1
 8002e2c:	7193      	strb	r3, [r2, #6]
 8002e2e:	e7e8      	b.n	8002e02 <UserKey_50ms+0x1a>
 8002e30:	200001e0 	.word	0x200001e0

08002e34 <Brisk_Polling>:
void Brisk_Polling(void) { // hook from main() loop
 8002e34:	b510      	push	{r4, lr}
  if(Brisk_5ms_Flag) { // 8 ms
 8002e36:	4b4a      	ldr	r3, [pc, #296]	; (8002f60 <Brisk_Polling+0x12c>)
 8002e38:	781b      	ldrb	r3, [r3, #0]
 8002e3a:	2b00      	cmp	r3, #0
 8002e3c:	d016      	beq.n	8002e6c <Brisk_Polling+0x38>
    Brisk_5ms_Flag = 0;
 8002e3e:	4b48      	ldr	r3, [pc, #288]	; (8002f60 <Brisk_Polling+0x12c>)
 8002e40:	2200      	movs	r2, #0
 8002e42:	701a      	strb	r2, [r3, #0]
    SleepingLED += 1;
 8002e44:	4a47      	ldr	r2, [pc, #284]	; (8002f64 <Brisk_Polling+0x130>)
 8002e46:	6813      	ldr	r3, [r2, #0]
 8002e48:	3301      	adds	r3, #1
 8002e4a:	6013      	str	r3, [r2, #0]
    if(SleepingLED>200)
 8002e4c:	2bc8      	cmp	r3, #200	; 0xc8
 8002e4e:	dd02      	ble.n	8002e56 <Brisk_Polling+0x22>
      SleepingLED = 0;
 8002e50:	0013      	movs	r3, r2
 8002e52:	2200      	movs	r2, #0
 8002e54:	601a      	str	r2, [r3, #0]
    if(SleepingLED>100)
 8002e56:	4b43      	ldr	r3, [pc, #268]	; (8002f64 <Brisk_Polling+0x130>)
 8002e58:	6819      	ldr	r1, [r3, #0]
 8002e5a:	2964      	cmp	r1, #100	; 0x64
 8002e5c:	dd3e      	ble.n	8002edc <Brisk_Polling+0xa8>
      BriskDimTimedLED(1,200-SleepingLED);
 8002e5e:	2338      	movs	r3, #56	; 0x38
 8002e60:	425b      	negs	r3, r3
 8002e62:	1a59      	subs	r1, r3, r1
 8002e64:	b249      	sxtb	r1, r1
 8002e66:	2001      	movs	r0, #1
 8002e68:	f7ff fa24 	bl	80022b4 <BriskDimTimedLED>
  if(Brisk_10ms_Flag) { // 16ms things to do each 10+ msec
 8002e6c:	4b3e      	ldr	r3, [pc, #248]	; (8002f68 <Brisk_Polling+0x134>)
 8002e6e:	781b      	ldrb	r3, [r3, #0]
 8002e70:	2b00      	cmp	r3, #0
 8002e72:	d138      	bne.n	8002ee6 <Brisk_Polling+0xb2>
  if(Brisk_50ms_Flag) { // 64ms things to do each 50+ msec
 8002e74:	4b3d      	ldr	r3, [pc, #244]	; (8002f6c <Brisk_Polling+0x138>)
 8002e76:	781b      	ldrb	r3, [r3, #0]
 8002e78:	2b00      	cmp	r3, #0
 8002e7a:	d13a      	bne.n	8002ef2 <Brisk_Polling+0xbe>
  if(Brisk_100ms_Flag) { // things to do each 100 msec
 8002e7c:	4b3c      	ldr	r3, [pc, #240]	; (8002f70 <Brisk_Polling+0x13c>)
 8002e7e:	781b      	ldrb	r3, [r3, #0]
 8002e80:	2b00      	cmp	r3, #0
 8002e82:	d13f      	bne.n	8002f04 <Brisk_Polling+0xd0>
  if(Brisk_1sec_Flag) { // 1 second
 8002e84:	4b3b      	ldr	r3, [pc, #236]	; (8002f74 <Brisk_Polling+0x140>)
 8002e86:	781b      	ldrb	r3, [r3, #0]
 8002e88:	2b00      	cmp	r3, #0
 8002e8a:	d143      	bne.n	8002f14 <Brisk_Polling+0xe0>
     && (UserKey.Pressed_5sec == 1)  ) { // push the BTEL dashboard
 8002e8c:	4b3a      	ldr	r3, [pc, #232]	; (8002f78 <Brisk_Polling+0x144>)
 8002e8e:	685b      	ldr	r3, [r3, #4]
 8002e90:	4a3a      	ldr	r2, [pc, #232]	; (8002f7c <Brisk_Polling+0x148>)
 8002e92:	4013      	ands	r3, r2
  if(   (UserKey.codenow==ROCK_SEL)
 8002e94:	2280      	movs	r2, #128	; 0x80
 8002e96:	0452      	lsls	r2, r2, #17
 8002e98:	4293      	cmp	r3, r2
 8002e9a:	d042      	beq.n	8002f22 <Brisk_Polling+0xee>
     && (UserKey.Pressed_5sec == 1)  ) { // push the BTEL dashboard
 8002e9c:	4b36      	ldr	r3, [pc, #216]	; (8002f78 <Brisk_Polling+0x144>)
 8002e9e:	685b      	ldr	r3, [r3, #4]
 8002ea0:	4a36      	ldr	r2, [pc, #216]	; (8002f7c <Brisk_Polling+0x148>)
 8002ea2:	4013      	ands	r3, r2
  if(   (UserKey.codenow==ROCK_DOWN)
 8002ea4:	4a36      	ldr	r2, [pc, #216]	; (8002f80 <Brisk_Polling+0x14c>)
 8002ea6:	4293      	cmp	r3, r2
 8002ea8:	d042      	beq.n	8002f30 <Brisk_Polling+0xfc>
     && (UserKey.Pressed_5sec == 1)  ) { // push the BTEL dashboard
 8002eaa:	4b33      	ldr	r3, [pc, #204]	; (8002f78 <Brisk_Polling+0x144>)
 8002eac:	685b      	ldr	r3, [r3, #4]
 8002eae:	4a33      	ldr	r2, [pc, #204]	; (8002f7c <Brisk_Polling+0x148>)
 8002eb0:	4013      	ands	r3, r2
  if(   (UserKey.codenow==ROCK_UP)
 8002eb2:	4a34      	ldr	r2, [pc, #208]	; (8002f84 <Brisk_Polling+0x150>)
 8002eb4:	4293      	cmp	r3, r2
 8002eb6:	d041      	beq.n	8002f3c <Brisk_Polling+0x108>
     && (UserKey.Pressed == 1)  ) { // push the BTEL dashboard
 8002eb8:	4b2f      	ldr	r3, [pc, #188]	; (8002f78 <Brisk_Polling+0x144>)
 8002eba:	685b      	ldr	r3, [r3, #4]
 8002ebc:	4a32      	ldr	r2, [pc, #200]	; (8002f88 <Brisk_Polling+0x154>)
 8002ebe:	4013      	ands	r3, r2
  if(   (UserKey.codenow==ROCK_RIGHT)
 8002ec0:	2282      	movs	r2, #130	; 0x82
 8002ec2:	0252      	lsls	r2, r2, #9
 8002ec4:	4293      	cmp	r3, r2
 8002ec6:	d03f      	beq.n	8002f48 <Brisk_Polling+0x114>
     && (UserKey.Pressed == 1)  ) { // push the BTEL dashboard
 8002ec8:	4b2b      	ldr	r3, [pc, #172]	; (8002f78 <Brisk_Polling+0x144>)
 8002eca:	685b      	ldr	r3, [r3, #4]
 8002ecc:	4a2e      	ldr	r2, [pc, #184]	; (8002f88 <Brisk_Polling+0x154>)
 8002ece:	4013      	ands	r3, r2
  if(   (UserKey.codenow==ROCK_LEFT)
 8002ed0:	4a2e      	ldr	r2, [pc, #184]	; (8002f8c <Brisk_Polling+0x158>)
 8002ed2:	4293      	cmp	r3, r2
 8002ed4:	d03e      	beq.n	8002f54 <Brisk_Polling+0x120>
  BTEL_Polling(); // monitor the FIFO from STmod+ USART and process any incoming/outgoing message.
 8002ed6:	f7fe f99f 	bl	8001218 <BTEL_Polling>
}
 8002eda:	bd10      	pop	{r4, pc}
      BriskDimTimedLED(1,SleepingLED);
 8002edc:	b249      	sxtb	r1, r1
 8002ede:	2001      	movs	r0, #1
 8002ee0:	f7ff f9e8 	bl	80022b4 <BriskDimTimedLED>
 8002ee4:	e7c2      	b.n	8002e6c <Brisk_Polling+0x38>
    BriskTimedLED_10msecTick(); // manage LED Blink function
 8002ee6:	f7ff f995 	bl	8002214 <BriskTimedLED_10msecTick>
    Brisk_10ms_Flag = 0; // 10ms++ (relaxed)
 8002eea:	4b1f      	ldr	r3, [pc, #124]	; (8002f68 <Brisk_Polling+0x134>)
 8002eec:	2200      	movs	r2, #0
 8002eee:	701a      	strb	r2, [r3, #0]
 8002ef0:	e7c0      	b.n	8002e74 <Brisk_Polling+0x40>
      Add_on_Board_50msec(&STModADD_On);
 8002ef2:	4827      	ldr	r0, [pc, #156]	; (8002f90 <Brisk_Polling+0x15c>)
 8002ef4:	f7ff fd95 	bl	8002a22 <Add_on_Board_50msec>
      UserKey_50ms();
 8002ef8:	f7ff ff76 	bl	8002de8 <UserKey_50ms>
    Brisk_50ms_Flag = 0; // 50ms++
 8002efc:	4b1b      	ldr	r3, [pc, #108]	; (8002f6c <Brisk_Polling+0x138>)
 8002efe:	2200      	movs	r2, #0
 8002f00:	701a      	strb	r2, [r3, #0]
 8002f02:	e7bb      	b.n	8002e7c <Brisk_Polling+0x48>
    IRQ_OVR_DemoEXTI_MainLoop_100msec();
 8002f04:	f7fe ff5e 	bl	8001dc4 <IRQ_OVR_DemoEXTI_MainLoop_100msec>
    BTEL_100ms();
 8002f08:	f000 f9ac 	bl	8003264 <BTEL_100ms>
    Brisk_100ms_Flag = 0; // 100ms++
 8002f0c:	4b18      	ldr	r3, [pc, #96]	; (8002f70 <Brisk_Polling+0x13c>)
 8002f0e:	2200      	movs	r2, #0
 8002f10:	701a      	strb	r2, [r3, #0]
 8002f12:	e7b7      	b.n	8002e84 <Brisk_Polling+0x50>
    Add_on_Board_1sec(&STModADD_On);
 8002f14:	481e      	ldr	r0, [pc, #120]	; (8002f90 <Brisk_Polling+0x15c>)
 8002f16:	f7ff fcd7 	bl	80028c8 <Add_on_Board_1sec>
    Brisk_1sec_Flag = 0;
 8002f1a:	4b16      	ldr	r3, [pc, #88]	; (8002f74 <Brisk_Polling+0x140>)
 8002f1c:	2200      	movs	r2, #0
 8002f1e:	701a      	strb	r2, [r3, #0]
 8002f20:	e7b4      	b.n	8002e8c <Brisk_Polling+0x58>
	  UserKey.Pressed_5sec = 0;
 8002f22:	4b15      	ldr	r3, [pc, #84]	; (8002f78 <Brisk_Polling+0x144>)
 8002f24:	2200      	movs	r2, #0
 8002f26:	71da      	strb	r2, [r3, #7]
	  BTEL.Delayed_PanelCountdown_100ms = 2;
 8002f28:	4b1a      	ldr	r3, [pc, #104]	; (8002f94 <Brisk_Polling+0x160>)
 8002f2a:	3202      	adds	r2, #2
 8002f2c:	80da      	strh	r2, [r3, #6]
 8002f2e:	e7b5      	b.n	8002e9c <Brisk_Polling+0x68>
	  UserKey.Pressed_5sec = 0;
 8002f30:	4b11      	ldr	r3, [pc, #68]	; (8002f78 <Brisk_Polling+0x144>)
 8002f32:	2200      	movs	r2, #0
 8002f34:	71da      	strb	r2, [r3, #7]
	  IRQ_OVR_DemoEnter();
 8002f36:	f7ff f80b 	bl	8001f50 <IRQ_OVR_DemoEnter>
 8002f3a:	e7b6      	b.n	8002eaa <Brisk_Polling+0x76>
	  UserKey.Pressed_5sec = 0;
 8002f3c:	4b0e      	ldr	r3, [pc, #56]	; (8002f78 <Brisk_Polling+0x144>)
 8002f3e:	2200      	movs	r2, #0
 8002f40:	71da      	strb	r2, [r3, #7]
	  IRQ_OVR_DemoLeave();
 8002f42:	f7fe ff72 	bl	8001e2a <IRQ_OVR_DemoLeave>
 8002f46:	e7b7      	b.n	8002eb8 <Brisk_Polling+0x84>
	  UserKey.Pressed = 0;
 8002f48:	4b0b      	ldr	r3, [pc, #44]	; (8002f78 <Brisk_Polling+0x144>)
 8002f4a:	2200      	movs	r2, #0
 8002f4c:	719a      	strb	r2, [r3, #6]
	  IRQ_OVR_ProtectionEnable();
 8002f4e:	f7fe ff5c 	bl	8001e0a <IRQ_OVR_ProtectionEnable>
 8002f52:	e7b9      	b.n	8002ec8 <Brisk_Polling+0x94>
	  UserKey.Pressed = 0;
 8002f54:	4b08      	ldr	r3, [pc, #32]	; (8002f78 <Brisk_Polling+0x144>)
 8002f56:	2200      	movs	r2, #0
 8002f58:	719a      	strb	r2, [r3, #6]
	  IRQ_OVR_ProtectionDisable();
 8002f5a:	f7fe ff5c 	bl	8001e16 <IRQ_OVR_ProtectionDisable>
 8002f5e:	e7ba      	b.n	8002ed6 <Brisk_Polling+0xa2>
 8002f60:	2000228a 	.word	0x2000228a
 8002f64:	2000228c 	.word	0x2000228c
 8002f68:	2000227d 	.word	0x2000227d
 8002f6c:	20002289 	.word	0x20002289
 8002f70:	2000227c 	.word	0x2000227c
 8002f74:	20002288 	.word	0x20002288
 8002f78:	200001e0 	.word	0x200001e0
 8002f7c:	ff00ff00 	.word	0xff00ff00
 8002f80:	01000200 	.word	0x01000200
 8002f84:	01000300 	.word	0x01000300
 8002f88:	00ffff00 	.word	0x00ffff00
 8002f8c:	00010100 	.word	0x00010100
 8002f90:	200001b4 	.word	0x200001b4
 8002f94:	20000354 	.word	0x20000354

08002f98 <BTEL_LeftPaneReport>:
  return 0;
}



int32_t BTEL_LeftPaneReport(u8fifo_t* pBrisk_Report) {
 8002f98:	b510      	push	{r4, lr}
 8002f9a:	0004      	movs	r4, r0

  // main frame drawing
  BTEL_Printf(pBrisk_Report,"*1Demo-1");
 8002f9c:	4912      	ldr	r1, [pc, #72]	; (8002fe8 <BTEL_LeftPaneReport+0x50>)
 8002f9e:	f7fe f9ab 	bl	80012f8 <BTEL_Printf>
  BTEL_Printf(pBrisk_Report,"*2");
 8002fa2:	4912      	ldr	r1, [pc, #72]	; (8002fec <BTEL_LeftPaneReport+0x54>)
 8002fa4:	0020      	movs	r0, r4
 8002fa6:	f7fe f9a7 	bl	80012f8 <BTEL_Printf>
  if(         (STModADD_On.IsPlugged) ) {
 8002faa:	4b11      	ldr	r3, [pc, #68]	; (8002ff0 <BTEL_LeftPaneReport+0x58>)
 8002fac:	7a5b      	ldrb	r3, [r3, #9]
 8002fae:	2b00      	cmp	r3, #0
 8002fb0:	d014      	beq.n	8002fdc <BTEL_LeftPaneReport+0x44>
    STModADD_On.StringID[16] = 0; // stop at 16th char (crude here)
 8002fb2:	490f      	ldr	r1, [pc, #60]	; (8002ff0 <BTEL_LeftPaneReport+0x58>)
 8002fb4:	2300      	movs	r3, #0
 8002fb6:	76cb      	strb	r3, [r1, #27]
    BTEL_Printf(pBrisk_Report,STModADD_On.StringID); // hope the string exist!
 8002fb8:	310b      	adds	r1, #11
 8002fba:	0020      	movs	r0, r4
 8002fbc:	f7fe f99c 	bl	80012f8 <BTEL_Printf>
  }
  else
    BTEL_Printf(pBrisk_Report,"No add-on");
  
    BTEL_Printf(pBrisk_Report, "*3STM32C0316-DK", 0);
 8002fc0:	2200      	movs	r2, #0
 8002fc2:	490c      	ldr	r1, [pc, #48]	; (8002ff4 <BTEL_LeftPaneReport+0x5c>)
 8002fc4:	0020      	movs	r0, r4
 8002fc6:	f7fe f997 	bl	80012f8 <BTEL_Printf>
  
  BTEL_Printf(pBrisk_Report, "*4 %d of %d*", BTEL.PanelSelector, BTEL.PanelSelectorMax);
 8002fca:	4b0b      	ldr	r3, [pc, #44]	; (8002ff8 <BTEL_LeftPaneReport+0x60>)
 8002fcc:	78da      	ldrb	r2, [r3, #3]
 8002fce:	791b      	ldrb	r3, [r3, #4]
 8002fd0:	490a      	ldr	r1, [pc, #40]	; (8002ffc <BTEL_LeftPaneReport+0x64>)
 8002fd2:	0020      	movs	r0, r4
 8002fd4:	f7fe f990 	bl	80012f8 <BTEL_Printf>
  
  return 0;
}
 8002fd8:	2000      	movs	r0, #0
 8002fda:	bd10      	pop	{r4, pc}
    BTEL_Printf(pBrisk_Report,"No add-on");
 8002fdc:	4908      	ldr	r1, [pc, #32]	; (8003000 <BTEL_LeftPaneReport+0x68>)
 8002fde:	0020      	movs	r0, r4
 8002fe0:	f7fe f98a 	bl	80012f8 <BTEL_Printf>
 8002fe4:	e7ec      	b.n	8002fc0 <BTEL_LeftPaneReport+0x28>
 8002fe6:	46c0      	nop			; (mov r8, r8)
 8002fe8:	0800621c 	.word	0x0800621c
 8002fec:	08006228 	.word	0x08006228
 8002ff0:	200001b4 	.word	0x200001b4
 8002ff4:	08006238 	.word	0x08006238
 8002ff8:	20000354 	.word	0x20000354
 8002ffc:	08006248 	.word	0x08006248
 8003000:	0800622c 	.word	0x0800622c

08003004 <BTEL_MasterRightPaneReport>:

int32_t BTEL_MasterRightPaneReport(u8fifo_t* pBrisk_Report) {
 8003004:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003006:	0004      	movs	r4, r0
  
  // gravity accelerator vector (disabled)
  //BTEL_Printf(pBrisk_Report,"*G%d", (int32_t)() ); //
  //BTEL_Printf(pBrisk_Report,"*g%C g", (int32_t)(Motion3D.gravity_x100) ); //
  // roll and pitch
  BTEL_Printf(pBrisk_Report,"*A%D,%D", (int32_t)(Analog.ADCs.Normal_mV[2]/100), (int32_t)(Analog.ADCs.Normal_mV[3]/100) ); //
 8003008:	4d19      	ldr	r5, [pc, #100]	; (8003070 <BTEL_MasterRightPaneReport+0x6c>)
 800300a:	8daf      	ldrh	r7, [r5, #44]	; 0x2c
 800300c:	8de8      	ldrh	r0, [r5, #46]	; 0x2e
 800300e:	2164      	movs	r1, #100	; 0x64
 8003010:	f7fd f87a 	bl	8000108 <__udivsi3>
 8003014:	b286      	uxth	r6, r0
 8003016:	2164      	movs	r1, #100	; 0x64
 8003018:	0038      	movs	r0, r7
 800301a:	f7fd f875 	bl	8000108 <__udivsi3>
 800301e:	b282      	uxth	r2, r0
 8003020:	0033      	movs	r3, r6
 8003022:	4914      	ldr	r1, [pc, #80]	; (8003074 <BTEL_MasterRightPaneReport+0x70>)
 8003024:	0020      	movs	r0, r4
 8003026:	f7fe f967 	bl	80012f8 <BTEL_Printf>
  // voltages as text
  BTEL_Printf(pBrisk_Report,"*V%C V", (int32_t)(Analog.ADCs.MeasuredVdd_mV/10) ); //
 800302a:	2352      	movs	r3, #82	; 0x52
 800302c:	5ee8      	ldrsh	r0, [r5, r3]
 800302e:	210a      	movs	r1, #10
 8003030:	f7fd f8f4 	bl	800021c <__divsi3>
 8003034:	b202      	sxth	r2, r0
 8003036:	4910      	ldr	r1, [pc, #64]	; (8003078 <BTEL_MasterRightPaneReport+0x74>)
 8003038:	0020      	movs	r0, r4
 800303a:	f7fe f95d 	bl	80012f8 <BTEL_Printf>
  //BTEL_Printf(pBrisk_Report,"*B%C V", (int32_t)(Analog.ADCs.MeasuredVBat_mV/10) ); //
  // temperature
  BTEL_Printf(pBrisk_Report,"*T%d", (int32_t)(Analog.ADCs.Temp_degC_x10/10) ); //
 800303e:	2650      	movs	r6, #80	; 0x50
 8003040:	5fa8      	ldrsh	r0, [r5, r6]
 8003042:	210a      	movs	r1, #10
 8003044:	f7fd f8ea 	bl	800021c <__divsi3>
 8003048:	b202      	sxth	r2, r0
 800304a:	490c      	ldr	r1, [pc, #48]	; (800307c <BTEL_MasterRightPaneReport+0x78>)
 800304c:	0020      	movs	r0, r4
 800304e:	f7fe f953 	bl	80012f8 <BTEL_Printf>
  BTEL_Printf(pBrisk_Report,"*t%D C", (int32_t)(Analog.ADCs.Temp_degC_x10) ); //
 8003052:	5faa      	ldrsh	r2, [r5, r6]
 8003054:	490a      	ldr	r1, [pc, #40]	; (8003080 <BTEL_MasterRightPaneReport+0x7c>)
 8003056:	0020      	movs	r0, r4
 8003058:	f7fe f94e 	bl	80012f8 <BTEL_Printf>
  // console log
  BTEL_Printf(pBrisk_Report, "*MTimestamp: %d\n", HAL_GetTick());
 800305c:	f000 fb62 	bl	8003724 <HAL_GetTick>
 8003060:	0002      	movs	r2, r0
 8003062:	4908      	ldr	r1, [pc, #32]	; (8003084 <BTEL_MasterRightPaneReport+0x80>)
 8003064:	0020      	movs	r0, r4
 8003066:	f7fe f947 	bl	80012f8 <BTEL_Printf>
    
  return 0;
};
 800306a:	2000      	movs	r0, #0
 800306c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800306e:	46c0      	nop			; (mov r8, r8)
 8003070:	200021bc 	.word	0x200021bc
 8003074:	08006258 	.word	0x08006258
 8003078:	08006260 	.word	0x08006260
 800307c:	080058dc 	.word	0x080058dc
 8003080:	08006268 	.word	0x08006268
 8003084:	08006270 	.word	0x08006270

08003088 <Brisk_Report>:
int32_t Brisk_Report(void) {
 8003088:	b510      	push	{r4, lr}
    ADC_UpdateConveredValues(&Analog.ADCs); // update ADC values in mV
 800308a:	480f      	ldr	r0, [pc, #60]	; (80030c8 <Brisk_Report+0x40>)
 800308c:	f7ff fdfc 	bl	8002c88 <ADC_UpdateConveredValues>
    BR_SubSample = (BR_SubSample+1)%3;
 8003090:	4c0e      	ldr	r4, [pc, #56]	; (80030cc <Brisk_Report+0x44>)
 8003092:	6823      	ldr	r3, [r4, #0]
 8003094:	1c58      	adds	r0, r3, #1
 8003096:	2103      	movs	r1, #3
 8003098:	f7fd f8bc 	bl	8000214 <__aeabi_uidivmod>
 800309c:	6021      	str	r1, [r4, #0]
    if(BR_SubSample==0)
 800309e:	2900      	cmp	r1, #0
 80030a0:	d008      	beq.n	80030b4 <Brisk_Report+0x2c>
    if(BTEL.PanelSelector >= BRISK_PANELS) { // pages
 80030a2:	4b0b      	ldr	r3, [pc, #44]	; (80030d0 <Brisk_Report+0x48>)
 80030a4:	78db      	ldrb	r3, [r3, #3]
 80030a6:	2b00      	cmp	r3, #0
 80030a8:	d009      	beq.n	80030be <Brisk_Report+0x36>
      Add_on_BoardReport(&STModADD_On); // add-on board report through the serial interface
 80030aa:	480a      	ldr	r0, [pc, #40]	; (80030d4 <Brisk_Report+0x4c>)
 80030ac:	f7ff fcff 	bl	8002aae <Add_on_BoardReport>
}
 80030b0:	2000      	movs	r0, #0
 80030b2:	bd10      	pop	{r4, pc}
      BTEL_LeftPaneReport(pBrisk_Report); // update the left side of the panel (common to all)
 80030b4:	4b08      	ldr	r3, [pc, #32]	; (80030d8 <Brisk_Report+0x50>)
 80030b6:	6818      	ldr	r0, [r3, #0]
 80030b8:	f7ff ff6e 	bl	8002f98 <BTEL_LeftPaneReport>
 80030bc:	e7f1      	b.n	80030a2 <Brisk_Report+0x1a>
      BTEL_MasterRightPaneReport(pBrisk_Report); // main frame
 80030be:	4b06      	ldr	r3, [pc, #24]	; (80030d8 <Brisk_Report+0x50>)
 80030c0:	6818      	ldr	r0, [r3, #0]
 80030c2:	f7ff ff9f 	bl	8003004 <BTEL_MasterRightPaneReport>
 80030c6:	e7f3      	b.n	80030b0 <Brisk_Report+0x28>
 80030c8:	200021bc 	.word	0x200021bc
 80030cc:	20002290 	.word	0x20002290
 80030d0:	20000354 	.word	0x20000354
 80030d4:	200001b4 	.word	0x200001b4
 80030d8:	200001f0 	.word	0x200001f0

080030dc <RightPaneProcess>:
  return 0;
}
         
int32_t LED_SliderValue = 0;

int32_t RightPaneProcess(void) {
 80030dc:	b570      	push	{r4, r5, r6, lr}

	int32_t i;

  // this one is panel number dependent
  // for now, brisk uses panel 0 only 1+ for add-on boards
  if(pBTEL->PanelSelector>=BRISK_PANELS) {
 80030de:	4b24      	ldr	r3, [pc, #144]	; (8003170 <RightPaneProcess+0x94>)
 80030e0:	681b      	ldr	r3, [r3, #0]
 80030e2:	78db      	ldrb	r3, [r3, #3]
 80030e4:	2b00      	cmp	r3, #0
 80030e6:	d11a      	bne.n	800311e <RightPaneProcess+0x42>
    return 0;
  }
  
  // Brisk pane has no interaction as of today
  // now we can interact..
  char c = BTEL.incoming[0];//BTEL.in_ndx];
 80030e8:	4b22      	ldr	r3, [pc, #136]	; (8003174 <RightPaneProcess+0x98>)
 80030ea:	7c1b      	ldrb	r3, [r3, #16]

  if((STModADD_On.IsPlugged) ) { // if an add-on board is plugged, there is not control available.
 80030ec:	4a22      	ldr	r2, [pc, #136]	; (8003178 <RightPaneProcess+0x9c>)
 80030ee:	7a52      	ldrb	r2, [r2, #9]
 80030f0:	2a00      	cmp	r2, #0
 80030f2:	d11a      	bne.n	800312a <RightPaneProcess+0x4e>
    return 0;
  }
  
  switch(c){
 80030f4:	2b58      	cmp	r3, #88	; 0x58
 80030f6:	d028      	beq.n	800314a <RightPaneProcess+0x6e>
 80030f8:	d819      	bhi.n	800312e <RightPaneProcess+0x52>
 80030fa:	2b44      	cmp	r3, #68	; 0x44
 80030fc:	d01f      	beq.n	800313e <RightPaneProcess+0x62>
 80030fe:	2b54      	cmp	r3, #84	; 0x54
 8003100:	d132      	bne.n	8003168 <RightPaneProcess+0x8c>
 8003102:	2401      	movs	r4, #1
      // adjust the LED dimming as percentage
      BriskDimLED(1, LED_SliderValue);
//      BriskBlinkTimedLED(1, 1000, 500, BRISK_LED_BLINK_FOREVER );
	  break;
  case 'T': // send box: send the string directly to the other usart (arduino/stmod+)
	  for(i=1;i<32;i++) {
 8003104:	2c1f      	cmp	r4, #31
 8003106:	dc10      	bgt.n	800312a <RightPaneProcess+0x4e>
		  c = BTEL.incoming[i];
 8003108:	4b1a      	ldr	r3, [pc, #104]	; (8003174 <RightPaneProcess+0x98>)
 800310a:	191b      	adds	r3, r3, r4
 800310c:	7c1d      	ldrb	r5, [r3, #16]
		  AddTou8fifo(&u8fifo_from_SPIP[ARD_STM_SERIAL],c);
 800310e:	0029      	movs	r1, r5
 8003110:	481a      	ldr	r0, [pc, #104]	; (800317c <RightPaneProcess+0xa0>)
 8003112:	f000 f980 	bl	8003416 <AddTou8fifo>
		  if(c==0) break; // null char sent too
 8003116:	2d00      	cmp	r5, #0
 8003118:	d007      	beq.n	800312a <RightPaneProcess+0x4e>
	  for(i=1;i<32;i++) {
 800311a:	3401      	adds	r4, #1
 800311c:	e7f2      	b.n	8003104 <RightPaneProcess+0x28>
    AddOnPaneProcess(&STModADD_On);
 800311e:	4816      	ldr	r0, [pc, #88]	; (8003178 <RightPaneProcess+0x9c>)
 8003120:	f7ff fcd6 	bl	8002ad0 <AddOnPaneProcess>
    NOPs(1);
 8003124:	2001      	movs	r0, #1
 8003126:	f000 f8b1 	bl	800328c <NOPs>
	  break;
  default: NOPs(1);

  }
  return 0;
}
 800312a:	2000      	movs	r0, #0
 800312c:	bd70      	pop	{r4, r5, r6, pc}
  switch(c){
 800312e:	2b64      	cmp	r3, #100	; 0x64
 8003130:	d11a      	bne.n	8003168 <RightPaneProcess+0x8c>
    BriskTimedLED_Enable();
 8003132:	f7fe ffe9 	bl	8002108 <BriskTimedLED_Enable>
	  NOPs(1);
 8003136:	2001      	movs	r0, #1
 8003138:	f000 f8a8 	bl	800328c <NOPs>
	  break;
 800313c:	e7f5      	b.n	800312a <RightPaneProcess+0x4e>
    BriskTimedLED_Disable();
 800313e:	f7fe ffdd 	bl	80020fc <BriskTimedLED_Disable>
	  NOPs(1);
 8003142:	2001      	movs	r0, #1
 8003144:	f000 f8a2 	bl	800328c <NOPs>
	  break;
 8003148:	e7ef      	b.n	800312a <RightPaneProcess+0x4e>
      if(StringToFrac(&BTEL.incoming[1], &LED_SliderValue)<0) return 0;
 800314a:	490d      	ldr	r1, [pc, #52]	; (8003180 <RightPaneProcess+0xa4>)
 800314c:	480d      	ldr	r0, [pc, #52]	; (8003184 <RightPaneProcess+0xa8>)
 800314e:	f7fe f867 	bl	8001220 <StringToFrac>
 8003152:	2800      	cmp	r0, #0
 8003154:	dbe9      	blt.n	800312a <RightPaneProcess+0x4e>
      if((LED_SliderValue<0)||(LED_SliderValue>100)) return 0; // out of range
 8003156:	4b0a      	ldr	r3, [pc, #40]	; (8003180 <RightPaneProcess+0xa4>)
 8003158:	6819      	ldr	r1, [r3, #0]
 800315a:	2964      	cmp	r1, #100	; 0x64
 800315c:	d8e5      	bhi.n	800312a <RightPaneProcess+0x4e>
      BriskDimLED(1, LED_SliderValue);
 800315e:	b249      	sxtb	r1, r1
 8003160:	2001      	movs	r0, #1
 8003162:	f7ff f823 	bl	80021ac <BriskDimLED>
	  break;
 8003166:	e7e0      	b.n	800312a <RightPaneProcess+0x4e>
  default: NOPs(1);
 8003168:	2001      	movs	r0, #1
 800316a:	f000 f88f 	bl	800328c <NOPs>
 800316e:	e7dc      	b.n	800312a <RightPaneProcess+0x4e>
 8003170:	200000f0 	.word	0x200000f0
 8003174:	20000354 	.word	0x20000354
 8003178:	200001b4 	.word	0x200001b4
 800317c:	200020d8 	.word	0x200020d8
 8003180:	20002294 	.word	0x20002294
 8003184:	20000365 	.word	0x20000365

08003188 <BTEL_SetPanel>:
        Brisk_Report();        
  }
  
}

void BTEL_SetPanel(void) { // draw the page content
 8003188:	b510      	push	{r4, lr}
  // send the panel layout
  BTEL.Delayed_PanelCountdown_100ms = 0; // stop any delayed panel pop up
 800318a:	4b0c      	ldr	r3, [pc, #48]	; (80031bc <BTEL_SetPanel+0x34>)
 800318c:	2200      	movs	r2, #0
 800318e:	80da      	strh	r2, [r3, #6]
  BTEL.PanelSelector = min2(BTEL.Delayed_PanelSelector,BTEL.PanelSelectorMax); // back in valid range
 8003190:	791a      	ldrb	r2, [r3, #4]
 8003192:	7959      	ldrb	r1, [r3, #5]
 8003194:	1c13      	adds	r3, r2, #0
 8003196:	428a      	cmp	r2, r1
 8003198:	d900      	bls.n	800319c <BTEL_SetPanel+0x14>
 800319a:	1c0b      	adds	r3, r1, #0
 800319c:	b2da      	uxtb	r2, r3
 800319e:	4907      	ldr	r1, [pc, #28]	; (80031bc <BTEL_SetPanel+0x34>)
 80031a0:	70cb      	strb	r3, [r1, #3]
  if(BTEL.PanelSelector==0)
 80031a2:	2a00      	cmp	r2, #0
 80031a4:	d106      	bne.n	80031b4 <BTEL_SetPanel+0x2c>
    TransmitPanel(pBrisk_Report, (char*)BTEL_MasterPanel0);
 80031a6:	4b06      	ldr	r3, [pc, #24]	; (80031c0 <BTEL_SetPanel+0x38>)
 80031a8:	6819      	ldr	r1, [r3, #0]
 80031aa:	4b06      	ldr	r3, [pc, #24]	; (80031c4 <BTEL_SetPanel+0x3c>)
 80031ac:	6818      	ldr	r0, [r3, #0]
 80031ae:	f7fe fa21 	bl	80015f4 <TransmitPanel>
  else
    Add_on_Board_SetPanel(&STModADD_On);
}
 80031b2:	bd10      	pop	{r4, pc}
    Add_on_Board_SetPanel(&STModADD_On);
 80031b4:	4804      	ldr	r0, [pc, #16]	; (80031c8 <BTEL_SetPanel+0x40>)
 80031b6:	f7ff fc9c 	bl	8002af2 <Add_on_Board_SetPanel>
}
 80031ba:	e7fa      	b.n	80031b2 <BTEL_SetPanel+0x2a>
 80031bc:	20000354 	.word	0x20000354
 80031c0:	200001ec 	.word	0x200001ec
 80031c4:	200001f0 	.word	0x200001f0
 80031c8:	200001b4 	.word	0x200001b4

080031cc <BTEL_SetDelayedPanel>:
void BTEL_SetDelayedPanel(int32_t PanelSelector, int32_t Delay_100ms) {
 80031cc:	b510      	push	{r4, lr}
  BTEL.Delayed_PanelCountdown_100ms = Delay_100ms;
 80031ce:	b289      	uxth	r1, r1
 80031d0:	4b09      	ldr	r3, [pc, #36]	; (80031f8 <BTEL_SetDelayedPanel+0x2c>)
 80031d2:	80d9      	strh	r1, [r3, #6]
  BTEL.Delayed_PanelSelector = min2(PanelSelector, BTEL.PanelSelectorMax); // max limit
 80031d4:	791b      	ldrb	r3, [r3, #4]
 80031d6:	4283      	cmp	r3, r0
 80031d8:	dd00      	ble.n	80031dc <BTEL_SetDelayedPanel+0x10>
 80031da:	0003      	movs	r3, r0
 80031dc:	4a06      	ldr	r2, [pc, #24]	; (80031f8 <BTEL_SetDelayedPanel+0x2c>)
 80031de:	7153      	strb	r3, [r2, #5]
  BTEL.Delayed_PanelSelector = max2(PanelSelector, 0); // min limit
 80031e0:	2800      	cmp	r0, #0
 80031e2:	db04      	blt.n	80031ee <BTEL_SetDelayedPanel+0x22>
 80031e4:	4b04      	ldr	r3, [pc, #16]	; (80031f8 <BTEL_SetDelayedPanel+0x2c>)
 80031e6:	7158      	strb	r0, [r3, #5]
  if(BTEL.Delayed_PanelCountdown_100ms==0) BTEL_SetPanel(); // if no delay, draw immediately
 80031e8:	2900      	cmp	r1, #0
 80031ea:	d002      	beq.n	80031f2 <BTEL_SetDelayedPanel+0x26>
}
 80031ec:	bd10      	pop	{r4, pc}
  BTEL.Delayed_PanelSelector = max2(PanelSelector, 0); // min limit
 80031ee:	2000      	movs	r0, #0
 80031f0:	e7f8      	b.n	80031e4 <BTEL_SetDelayedPanel+0x18>
  if(BTEL.Delayed_PanelCountdown_100ms==0) BTEL_SetPanel(); // if no delay, draw immediately
 80031f2:	f7ff ffc9 	bl	8003188 <BTEL_SetPanel>
}
 80031f6:	e7f9      	b.n	80031ec <BTEL_SetDelayedPanel+0x20>
 80031f8:	20000354 	.word	0x20000354

080031fc <LeftPaneProcess>:
int32_t LeftPaneProcess(void) {
 80031fc:	b510      	push	{r4, lr}
  char c = BTEL.incoming[BTEL.in_ndx];
 80031fe:	4b18      	ldr	r3, [pc, #96]	; (8003260 <LeftPaneProcess+0x64>)
 8003200:	2284      	movs	r2, #132	; 0x84
 8003202:	0092      	lsls	r2, r2, #2
 8003204:	5e9a      	ldrsh	r2, [r3, r2]
 8003206:	189b      	adds	r3, r3, r2
 8003208:	7c1b      	ldrb	r3, [r3, #16]
  switch(c) { // the common panel commands      
 800320a:	2b37      	cmp	r3, #55	; 0x37
 800320c:	d01d      	beq.n	800324a <LeftPaneProcess+0x4e>
 800320e:	d80d      	bhi.n	800322c <LeftPaneProcess+0x30>
 8003210:	2b35      	cmp	r3, #53	; 0x35
 8003212:	d012      	beq.n	800323a <LeftPaneProcess+0x3e>
 8003214:	2b36      	cmp	r3, #54	; 0x36
 8003216:	d11f      	bne.n	8003258 <LeftPaneProcess+0x5c>
      BTEL.DeviceSelector = 0;
 8003218:	4b11      	ldr	r3, [pc, #68]	; (8003260 <LeftPaneProcess+0x64>)
 800321a:	2200      	movs	r2, #0
 800321c:	705a      	strb	r2, [r3, #1]
      BTEL_SelectDevice(); // configure XBAR_SIF with range check
 800321e:	f7fe f9e3 	bl	80015e8 <BTEL_SelectDevice>
      BTEL_SetDelayedPanel(0,2);
 8003222:	2102      	movs	r1, #2
 8003224:	2000      	movs	r0, #0
 8003226:	f7ff ffd1 	bl	80031cc <BTEL_SetDelayedPanel>
    break;// right
 800322a:	e00c      	b.n	8003246 <LeftPaneProcess+0x4a>
  switch(c) { // the common panel commands      
 800322c:	2b38      	cmp	r3, #56	; 0x38
 800322e:	d113      	bne.n	8003258 <LeftPaneProcess+0x5c>
      BTEL_SetDelayedPanel(0,5);
 8003230:	2105      	movs	r1, #5
 8003232:	2000      	movs	r0, #0
 8003234:	f7ff ffca 	bl	80031cc <BTEL_SetDelayedPanel>
    break;// left
 8003238:	e005      	b.n	8003246 <LeftPaneProcess+0x4a>
    BTEL_SetDelayedPanel(BTEL.PanelSelector-1, 2);
 800323a:	4b09      	ldr	r3, [pc, #36]	; (8003260 <LeftPaneProcess+0x64>)
 800323c:	78d8      	ldrb	r0, [r3, #3]
 800323e:	3801      	subs	r0, #1
 8003240:	2102      	movs	r1, #2
 8003242:	f7ff ffc3 	bl	80031cc <BTEL_SetDelayedPanel>
}
 8003246:	2000      	movs	r0, #0
 8003248:	bd10      	pop	{r4, pc}
    BTEL_SetDelayedPanel(BTEL.PanelSelector+1,2);
 800324a:	4b05      	ldr	r3, [pc, #20]	; (8003260 <LeftPaneProcess+0x64>)
 800324c:	78d8      	ldrb	r0, [r3, #3]
 800324e:	3001      	adds	r0, #1
 8003250:	2102      	movs	r1, #2
 8003252:	f7ff ffbb 	bl	80031cc <BTEL_SetDelayedPanel>
    break;// down
 8003256:	e7f6      	b.n	8003246 <LeftPaneProcess+0x4a>
    NOPs(1); // breakpoint
 8003258:	2001      	movs	r0, #1
 800325a:	f000 f817 	bl	800328c <NOPs>
    return 0;
 800325e:	e7f2      	b.n	8003246 <LeftPaneProcess+0x4a>
 8003260:	20000354 	.word	0x20000354

08003264 <BTEL_100ms>:
void BTEL_100ms(void) { // implement the countdown to push the layout to the phone
 8003264:	b510      	push	{r4, lr}
    if(BTEL.Delayed_PanelCountdown_100ms) {
 8003266:	4b08      	ldr	r3, [pc, #32]	; (8003288 <BTEL_100ms+0x24>)
 8003268:	88db      	ldrh	r3, [r3, #6]
 800326a:	2b00      	cmp	r3, #0
 800326c:	d009      	beq.n	8003282 <BTEL_100ms+0x1e>
      BTEL.Delayed_PanelCountdown_100ms--;
 800326e:	3b01      	subs	r3, #1
 8003270:	b29b      	uxth	r3, r3
 8003272:	4a05      	ldr	r2, [pc, #20]	; (8003288 <BTEL_100ms+0x24>)
 8003274:	80d3      	strh	r3, [r2, #6]
      if((BTEL.Delayed_PanelCountdown_100ms==0)/*&&(SPIP.Device==IS_MASTER)*/) {
 8003276:	2b00      	cmp	r3, #0
 8003278:	d000      	beq.n	800327c <BTEL_100ms+0x18>
}
 800327a:	bd10      	pop	{r4, pc}
        BTEL_SetPanel();
 800327c:	f7ff ff84 	bl	8003188 <BTEL_SetPanel>
 8003280:	e7fb      	b.n	800327a <BTEL_100ms+0x16>
        Brisk_Report();        
 8003282:	f7ff ff01 	bl	8003088 <Brisk_Report>
}
 8003286:	e7f8      	b.n	800327a <BTEL_100ms+0x16>
 8003288:	20000354 	.word	0x20000354

0800328c <NOPs>:
#include "main.h"
#include "brisk.h"
//#include "commons.h"

void NOPs(uint32_t loop) { // global
  while(loop--) asm("nop\n"); 
 800328c:	e001      	b.n	8003292 <NOPs+0x6>
 800328e:	46c0      	nop			; (mov r8, r8)
 8003290:	0018      	movs	r0, r3
 8003292:	1e43      	subs	r3, r0, #1
 8003294:	2800      	cmp	r0, #0
 8003296:	d1fa      	bne.n	800328e <NOPs+0x2>
}
 8003298:	4770      	bx	lr

0800329a <MinDelay_us>:
  
  while(ms--)
    MinDelay_us(1000);
}

void MinDelay_us(uint32_t us) {
 800329a:	b510      	push	{r4, lr}
 800329c:	0003      	movs	r3, r0
  
  NOPs(us * SYS_CLK_MHZ / 2); // gross
 800329e:	0040      	lsls	r0, r0, #1
 80032a0:	18c0      	adds	r0, r0, r3
 80032a2:	0100      	lsls	r0, r0, #4
 80032a4:	0840      	lsrs	r0, r0, #1
 80032a6:	f7ff fff1 	bl	800328c <NOPs>
}
 80032aa:	bd10      	pop	{r4, pc}

080032ac <MinDelay_ms>:
void MinDelay_ms(uint32_t ms) { // this can be SW delay with non exact delay.
 80032ac:	b510      	push	{r4, lr}
  while(ms--)
 80032ae:	e004      	b.n	80032ba <MinDelay_ms+0xe>
    MinDelay_us(1000);
 80032b0:	20fa      	movs	r0, #250	; 0xfa
 80032b2:	0080      	lsls	r0, r0, #2
 80032b4:	f7ff fff1 	bl	800329a <MinDelay_us>
  while(ms--)
 80032b8:	0020      	movs	r0, r4
 80032ba:	1e44      	subs	r4, r0, #1
 80032bc:	2800      	cmp	r0, #0
 80032be:	d1f7      	bne.n	80032b0 <MinDelay_ms+0x4>
}
 80032c0:	bd10      	pop	{r4, pc}

080032c2 <Interpolate_i32>:


int32_t Interpolate_i32 (int32_t x0, int32_t x1, int32_t y0, int32_t y1, int32_t x) { 
 80032c2:	b570      	push	{r4, r5, r6, lr}
 80032c4:	0004      	movs	r4, r0
  int32_t dwQ;
  dwQ = ((y1-y0))*x+(x1*y0)-(x0*y1);	// overflow not checked yet
 80032c6:	1a98      	subs	r0, r3, r2
 80032c8:	9d04      	ldr	r5, [sp, #16]
 80032ca:	4368      	muls	r0, r5
 80032cc:	434a      	muls	r2, r1
 80032ce:	1880      	adds	r0, r0, r2
 80032d0:	4363      	muls	r3, r4
 80032d2:	1ac0      	subs	r0, r0, r3
  dwQ = dwQ / (x1-x0);// we can also do roundings here
 80032d4:	1b09      	subs	r1, r1, r4
 80032d6:	f7fc ffa1 	bl	800021c <__divsi3>
  
  return dwQ;
}
 80032da:	bd70      	pop	{r4, r5, r6, pc}

080032dc <StringsIdenticals>:

  return 1;
}

// Compare strings
uint32_t StringsIdenticals (const void* dst, const void* src, uint32_t cnt) {	/* ZR:same, NZ:different */
 80032dc:	b510      	push	{r4, lr}
  
	const uint8_t *d = (const uint8_t *)dst, *s = (const uint8_t *)src;

        if(cnt==0) TrapError();
 80032de:	2a00      	cmp	r2, #0
 80032e0:	d100      	bne.n	80032e4 <StringsIdenticals+0x8>
 80032e2:	e7fe      	b.n	80032e2 <StringsIdenticals+0x6>

        while(cnt--) {
 80032e4:	1e54      	subs	r4, r2, #1
 80032e6:	2a00      	cmp	r2, #0
 80032e8:	d009      	beq.n	80032fe <StringsIdenticals+0x22>
		if( *d != *s ) return 0;
 80032ea:	7803      	ldrb	r3, [r0, #0]
 80032ec:	780a      	ldrb	r2, [r1, #0]
 80032ee:	4293      	cmp	r3, r2
 80032f0:	d107      	bne.n	8003302 <StringsIdenticals+0x26>
                if(*d==0) return 1;
 80032f2:	2b00      	cmp	r3, #0
 80032f4:	d007      	beq.n	8003306 <StringsIdenticals+0x2a>
                d++;s++;
 80032f6:	3001      	adds	r0, #1
 80032f8:	3101      	adds	r1, #1
        while(cnt--) {
 80032fa:	0022      	movs	r2, r4
 80032fc:	e7f2      	b.n	80032e4 <StringsIdenticals+0x8>
	};

	return 1;
 80032fe:	2001      	movs	r0, #1
}
 8003300:	bd10      	pop	{r4, pc}
		if( *d != *s ) return 0;
 8003302:	2000      	movs	r0, #0
 8003304:	e7fc      	b.n	8003300 <StringsIdenticals+0x24>
                if(*d==0) return 1;
 8003306:	2001      	movs	r0, #1
 8003308:	e7fa      	b.n	8003300 <StringsIdenticals+0x24>

0800330a <_Clipu8fifo_Down>:

//==========================================================
// manage the left side

static uint32_t _Clipu8fifo_Down(u8fifo_t* pu8fifo);
static uint32_t _Clipu8fifo_Down(u8fifo_t* pu8fifo) { // 0 or 1, returns the bit pointer
 800330a:	b510      	push	{r4, lr}
 800330c:	0004      	movs	r4, r0

//  if(bCountLimit==0) while(1); // error
  
  if(pu8fifo->bCount==0) // if strand empty, nothing to read from it, error
 800330e:	68c3      	ldr	r3, [r0, #12]
 8003310:	2b00      	cmp	r3, #0
 8003312:	d100      	bne.n	8003316 <_Clipu8fifo_Down+0xc>
    while(1); // error, nothing on this strand, check its size is non zero first!
 8003314:	e7fe      	b.n	8003314 <_Clipu8fifo_Down+0xa>

  pu8fifo->bCount--;  // strand not empty. Get the left bit first, reduce strand size
 8003316:	3b01      	subs	r3, #1
 8003318:	60c3      	str	r3, [r0, #12]
  pu8fifo->Out = *(uint8_t*) pu8fifo->pbDown; // we create one more bit space on the left (lower memory)
 800331a:	6942      	ldr	r2, [r0, #20]
 800331c:	7811      	ldrb	r1, [r2, #0]
 800331e:	6201      	str	r1, [r0, #32]
  
  // point to the new left side
  pu8fifo->pbDown++;
 8003320:	3201      	adds	r2, #1
 8003322:	6142      	str	r2, [r0, #20]
  if(pu8fifo->pbDown>pu8fifo->pbHighest) // circular memory space bottom reached.
 8003324:	6841      	ldr	r1, [r0, #4]
 8003326:	428a      	cmp	r2, r1
 8003328:	d901      	bls.n	800332e <_Clipu8fifo_Down+0x24>
    pu8fifo->pbDown = pu8fifo->pbLowest; // jump to higher end
 800332a:	6802      	ldr	r2, [r0, #0]
 800332c:	6142      	str	r2, [r0, #20]
  
  if(pu8fifo->bCount==0) {
 800332e:	2b00      	cmp	r3, #0
 8003330:	d104      	bne.n	800333c <_Clipu8fifo_Down+0x32>
    if(pu8fifo->fnEmptied) {// if the strand turns empty, tell someone?
 8003332:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8003334:	2b00      	cmp	r3, #0
 8003336:	d003      	beq.n	8003340 <_Clipu8fifo_Down+0x36>
      pu8fifo->fnEmptied(pu8fifo->ctEmptied);
 8003338:	6b20      	ldr	r0, [r4, #48]	; 0x30
 800333a:	4798      	blx	r3
  };

  // one item was added, check if someone is ready to empty it
//TBD  if(pu8fifo->fnIn) ((uint32_t(*)(uint32_t))pu8fifo->fnIn)(pu8fifo->ctIn);
  
  return pu8fifo->Out;// return read valid bit
 800333c:	6a20      	ldr	r0, [r4, #32]
}
 800333e:	bd10      	pop	{r4, pc}
      pu8fifo->FlagEmptied = 1;
 8003340:	2234      	movs	r2, #52	; 0x34
 8003342:	5ca3      	ldrb	r3, [r4, r2]
 8003344:	2102      	movs	r1, #2
 8003346:	430b      	orrs	r3, r1
 8003348:	54a3      	strb	r3, [r4, r2]
 800334a:	e7f7      	b.n	800333c <_Clipu8fifo_Down+0x32>

0800334c <_Glueu8fifo_Up>:

//==========================================================
// manage the right side
static uint32_t _Glueu8fifo_Up(u8fifo_t* pu8fifo);
static uint32_t _Glueu8fifo_Up(u8fifo_t* pu8fifo) {
 800334c:	b510      	push	{r4, lr}
 800334e:	0004      	movs	r4, r0

  if(pu8fifo->bCountLimit==0) while(1); // error
 8003350:	6883      	ldr	r3, [r0, #8]
 8003352:	2b00      	cmp	r3, #0
 8003354:	d100      	bne.n	8003358 <_Glueu8fifo_Up+0xc>
 8003356:	e7fe      	b.n	8003356 <_Glueu8fifo_Up+0xa>
  
  if(pu8fifo->bCount==0) { // if strand empty: Create the first bit
 8003358:	68c2      	ldr	r2, [r0, #12]
 800335a:	2a00      	cmp	r2, #0
 800335c:	d110      	bne.n	8003380 <_Glueu8fifo_Up+0x34>
    pu8fifo->pbUp = pu8fifo->pbDown = pu8fifo->pbLowest; // arbitrary left is the start creation side
 800335e:	6803      	ldr	r3, [r0, #0]
 8003360:	6143      	str	r3, [r0, #20]
 8003362:	6183      	str	r3, [r0, #24]
    if(pu8fifo->pbUp>pu8fifo->pbHighest) // rollover if out of range
      pu8fifo->pbUp = pu8fifo->pbLowest;
  };
  
  // write in memory and increase bit counter safely
  *(uint8_t*)pu8fifo->pbUp = pu8fifo->In;
 8003364:	69e3      	ldr	r3, [r4, #28]
 8003366:	69a2      	ldr	r2, [r4, #24]
 8003368:	7013      	strb	r3, [r2, #0]
  pu8fifo->bCount++;
 800336a:	68e3      	ldr	r3, [r4, #12]
 800336c:	3301      	adds	r3, #1
 800336e:	60e3      	str	r3, [r4, #12]
  if(pu8fifo->bCount>pu8fifo->bCountMax) pu8fifo->bCountMax = pu8fifo->bCount;
 8003370:	6922      	ldr	r2, [r4, #16]
 8003372:	4293      	cmp	r3, r2
 8003374:	d900      	bls.n	8003378 <_Glueu8fifo_Up+0x2c>
 8003376:	6123      	str	r3, [r4, #16]
  
  if(pu8fifo->bCount==1) {
 8003378:	2b01      	cmp	r3, #1
 800337a:	d013      	beq.n	80033a4 <_Glueu8fifo_Up+0x58>
  }

  // one item was added, check if someone is ready to empty it
//TBD  if(pu8fifo->fnOut) ((uint32_t(*)(uint32_t))pu8fifo->fnOut)(pu8fifo->ctOut);

  return pu8fifo->pbUp;
 800337c:	69a0      	ldr	r0, [r4, #24]
}
 800337e:	bd10      	pop	{r4, pc}
    if(pu8fifo->bCount>=pu8fifo->bCountLimit) {
 8003380:	4293      	cmp	r3, r2
 8003382:	d908      	bls.n	8003396 <_Glueu8fifo_Up+0x4a>
    pu8fifo->pbUp++;
 8003384:	6983      	ldr	r3, [r0, #24]
 8003386:	3301      	adds	r3, #1
 8003388:	6183      	str	r3, [r0, #24]
    if(pu8fifo->pbUp>pu8fifo->pbHighest) // rollover if out of range
 800338a:	6842      	ldr	r2, [r0, #4]
 800338c:	4293      	cmp	r3, r2
 800338e:	d9e9      	bls.n	8003364 <_Glueu8fifo_Up+0x18>
      pu8fifo->pbUp = pu8fifo->pbLowest;
 8003390:	6803      	ldr	r3, [r0, #0]
 8003392:	6183      	str	r3, [r0, #24]
 8003394:	e7e6      	b.n	8003364 <_Glueu8fifo_Up+0x18>
      pu8fifo->FlagFull=1;
 8003396:	2234      	movs	r2, #52	; 0x34
 8003398:	5c83      	ldrb	r3, [r0, r2]
 800339a:	2104      	movs	r1, #4
 800339c:	430b      	orrs	r3, r1
 800339e:	5483      	strb	r3, [r0, r2]
      return 0;
 80033a0:	2000      	movs	r0, #0
 80033a2:	e7ec      	b.n	800337e <_Glueu8fifo_Up+0x32>
    if(pu8fifo->fnNoLongerEmpty) { // if the strand not empty, tell someone?
 80033a4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80033a6:	2b00      	cmp	r3, #0
 80033a8:	d002      	beq.n	80033b0 <_Glueu8fifo_Up+0x64>
      pu8fifo->fnNoLongerEmpty(pu8fifo->ctNoLongerEmpty); //!!! this can activate interrupt IRQ...
 80033aa:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80033ac:	4798      	blx	r3
 80033ae:	e7e5      	b.n	800337c <_Glueu8fifo_Up+0x30>
      pu8fifo->FlagNoLongerEmpty = 1;
 80033b0:	2234      	movs	r2, #52	; 0x34
 80033b2:	5ca3      	ldrb	r3, [r4, r2]
 80033b4:	2101      	movs	r1, #1
 80033b6:	430b      	orrs	r3, r1
 80033b8:	54a3      	strb	r3, [r4, r2]
 80033ba:	e7df      	b.n	800337c <_Glueu8fifo_Up+0x30>

080033bc <Hooku8fifo_NoLongerEmpty>:
  pu8fifo->ctNoLongerEmpty = ct;  
 80033bc:	6282      	str	r2, [r0, #40]	; 0x28
  pu8fifo->fnNoLongerEmpty = fn;
 80033be:	6241      	str	r1, [r0, #36]	; 0x24
}
 80033c0:	2000      	movs	r0, #0
 80033c2:	4770      	bx	lr

080033c4 <Hooku8fifo_Emptied>:
  pu8fifo->ctEmptied = ct;    
 80033c4:	6302      	str	r2, [r0, #48]	; 0x30
  pu8fifo->fnEmptied = fn;
 80033c6:	62c1      	str	r1, [r0, #44]	; 0x2c
}
 80033c8:	2000      	movs	r0, #0
 80033ca:	4770      	bx	lr

080033cc <Newu8fifo>:
uint32_t Newu8fifo(u8fifo_t* pu8fifo, uint32_t begin, int32_t size) {
 80033cc:	0003      	movs	r3, r0
 80033ce:	0008      	movs	r0, r1
  if(size==0)
 80033d0:	2a00      	cmp	r2, #0
 80033d2:	d100      	bne.n	80033d6 <Newu8fifo+0xa>
    while(1); // no memory for it?
 80033d4:	e7fe      	b.n	80033d4 <Newu8fifo+0x8>
  pu8fifo->pbLowest = begin; // left is decreasing memory address with rollover circular buffer
 80033d6:	6019      	str	r1, [r3, #0]
  pu8fifo->pbHighest = begin + (size - 1); // tight is increasing memory address with rollover circular buffer inclusive pointer
 80033d8:	1851      	adds	r1, r2, r1
 80033da:	3901      	subs	r1, #1
 80033dc:	6059      	str	r1, [r3, #4]
  pu8fifo->bCountLimit = size; // we validate the strand size (action can occur)
 80033de:	609a      	str	r2, [r3, #8]
  pu8fifo->bCount = 0;
 80033e0:	2200      	movs	r2, #0
 80033e2:	60da      	str	r2, [r3, #12]
}
 80033e4:	4770      	bx	lr

080033e6 <Clipu8fifo_Down>:

// here we make the interrupt disable wrapper for fifo functions. not optimized.
// good enough to make progress


uint32_t Clipu8fifo_Down(u8fifo_t* pu8fifo) {
 80033e6:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80033e8:	f3ef 8410 	mrs	r4, PRIMASK
  
  uint32_t result;
  uint32_t tmp = __get_PRIMASK();
  __set_PRIMASK(tmp | 1);
 80033ec:	2301      	movs	r3, #1
 80033ee:	4323      	orrs	r3, r4
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80033f0:	f383 8810 	msr	PRIMASK, r3
  result = _Clipu8fifo_Down(pu8fifo);
 80033f4:	f7ff ff89 	bl	800330a <_Clipu8fifo_Down>
 80033f8:	f384 8810 	msr	PRIMASK, r4
  __set_PRIMASK(tmp);
  return result;
}
 80033fc:	bd10      	pop	{r4, pc}

080033fe <Glueu8fifo_Up>:

uint32_t Glueu8fifo_Up(u8fifo_t* pu8fifo) {
 80033fe:	b510      	push	{r4, lr}
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003400:	f3ef 8410 	mrs	r4, PRIMASK
  
  uint32_t result;
  uint32_t tmp = __get_PRIMASK();
  __set_PRIMASK(tmp | 1);
 8003404:	2301      	movs	r3, #1
 8003406:	4323      	orrs	r3, r4
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8003408:	f383 8810 	msr	PRIMASK, r3
  result = _Glueu8fifo_Up(pu8fifo);
 800340c:	f7ff ff9e 	bl	800334c <_Glueu8fifo_Up>
 8003410:	f384 8810 	msr	PRIMASK, r4
  __set_PRIMASK(tmp);
  return result;
}
 8003414:	bd10      	pop	{r4, pc}

08003416 <AddTou8fifo>:
uint32_t AddTou8fifo(u8fifo_t* pu8fifo, uint32_t In) {
 8003416:	b510      	push	{r4, lr}
  pu8fifo->In = In;
 8003418:	61c1      	str	r1, [r0, #28]
  return Glueu8fifo_Up(pu8fifo);
 800341a:	f7ff fff0 	bl	80033fe <Glueu8fifo_Up>
}
 800341e:	bd10      	pop	{r4, pc}

08003420 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8003420:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003422:	46c6      	mov	lr, r8
 8003424:	b500      	push	{lr}
 8003426:	b08a      	sub	sp, #40	; 0x28
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8003428:	2214      	movs	r2, #20
 800342a:	2100      	movs	r1, #0
 800342c:	a805      	add	r0, sp, #20
 800342e:	f002 f9ff 	bl	8005830 <memset>

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8003432:	4b23      	ldr	r3, [pc, #140]	; (80034c0 <MX_GPIO_Init+0xa0>)
 8003434:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003436:	2404      	movs	r4, #4
 8003438:	4322      	orrs	r2, r4
 800343a:	635a      	str	r2, [r3, #52]	; 0x34
 800343c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800343e:	4022      	ands	r2, r4
 8003440:	9201      	str	r2, [sp, #4]
 8003442:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8003444:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003446:	2720      	movs	r7, #32
 8003448:	433a      	orrs	r2, r7
 800344a:	635a      	str	r2, [r3, #52]	; 0x34
 800344c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800344e:	403a      	ands	r2, r7
 8003450:	9202      	str	r2, [sp, #8]
 8003452:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8003454:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003456:	2601      	movs	r6, #1
 8003458:	4332      	orrs	r2, r6
 800345a:	635a      	str	r2, [r3, #52]	; 0x34
 800345c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800345e:	4032      	ands	r2, r6
 8003460:	9203      	str	r2, [sp, #12]
 8003462:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8003464:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8003466:	2202      	movs	r2, #2
 8003468:	4311      	orrs	r1, r2
 800346a:	6359      	str	r1, [r3, #52]	; 0x34
 800346c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800346e:	401a      	ands	r2, r3
 8003470:	9204      	str	r2, [sp, #16]
 8003472:	9b04      	ldr	r3, [sp, #16]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(Led_GPIO_Port, Led_Pin, GPIO_PIN_SET);
 8003474:	25a0      	movs	r5, #160	; 0xa0
 8003476:	05ed      	lsls	r5, r5, #23
 8003478:	2201      	movs	r2, #1
 800347a:	2120      	movs	r1, #32
 800347c:	0028      	movs	r0, r5
 800347e:	f000 fefb 	bl	8004278 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : Button_Pin */
  GPIO_InitStruct.Pin = Button_Pin;
 8003482:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8003484:	2400      	movs	r4, #0
 8003486:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003488:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(Button_GPIO_Port, &GPIO_InitStruct);
 800348a:	a905      	add	r1, sp, #20
 800348c:	480d      	ldr	r0, [pc, #52]	; (80034c4 <MX_GPIO_Init+0xa4>)
 800348e:	f000 fe15 	bl	80040bc <HAL_GPIO_Init>

  /*Configure GPIO pin : Joystick_Pin */
  GPIO_InitStruct.Pin = Joystick_Pin;
 8003492:	2310      	movs	r3, #16
 8003494:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8003496:	3b0d      	subs	r3, #13
 8003498:	4698      	mov	r8, r3
 800349a:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800349c:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(Joystick_GPIO_Port, &GPIO_InitStruct);
 800349e:	a905      	add	r1, sp, #20
 80034a0:	0028      	movs	r0, r5
 80034a2:	f000 fe0b 	bl	80040bc <HAL_GPIO_Init>

  /*Configure GPIO pin : Led_Pin */
  GPIO_InitStruct.Pin = Led_Pin;
 80034a6:	9705      	str	r7, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80034a8:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80034aa:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80034ac:	4643      	mov	r3, r8
 80034ae:	9308      	str	r3, [sp, #32]
  HAL_GPIO_Init(Led_GPIO_Port, &GPIO_InitStruct);
 80034b0:	a905      	add	r1, sp, #20
 80034b2:	0028      	movs	r0, r5
 80034b4:	f000 fe02 	bl	80040bc <HAL_GPIO_Init>

}
 80034b8:	b00a      	add	sp, #40	; 0x28
 80034ba:	bc80      	pop	{r7}
 80034bc:	46b8      	mov	r8, r7
 80034be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80034c0:	40021000 	.word	0x40021000
 80034c4:	50001400 	.word	0x50001400

080034c8 <Error_Handler>:
  __ASM volatile ("cpsid i" : : : "memory");
 80034c8:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 80034ca:	e7fe      	b.n	80034ca <Error_Handler+0x2>

080034cc <SystemClock_Config>:
{
 80034cc:	b500      	push	{lr}
 80034ce:	b08d      	sub	sp, #52	; 0x34
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80034d0:	221c      	movs	r2, #28
 80034d2:	2100      	movs	r1, #0
 80034d4:	a805      	add	r0, sp, #20
 80034d6:	f002 f9ab 	bl	8005830 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80034da:	2214      	movs	r2, #20
 80034dc:	2100      	movs	r1, #0
 80034de:	4668      	mov	r0, sp
 80034e0:	f002 f9a6 	bl	8005830 <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
 80034e4:	2302      	movs	r3, #2
 80034e6:	9305      	str	r3, [sp, #20]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 80034e8:	33fe      	adds	r3, #254	; 0xfe
 80034ea:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 80034ec:	3bc0      	subs	r3, #192	; 0xc0
 80034ee:	930a      	str	r3, [sp, #40]	; 0x28
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80034f0:	a805      	add	r0, sp, #20
 80034f2:	f000 fee1 	bl	80042b8 <HAL_RCC_OscConfig>
 80034f6:	2800      	cmp	r0, #0
 80034f8:	d10e      	bne.n	8003518 <SystemClock_Config+0x4c>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 80034fa:	2307      	movs	r3, #7
 80034fc:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
 80034fe:	2300      	movs	r3, #0
 8003500:	9301      	str	r3, [sp, #4]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8003502:	9302      	str	r3, [sp, #8]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
 8003504:	9303      	str	r3, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV1;
 8003506:	9304      	str	r3, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8003508:	2101      	movs	r1, #1
 800350a:	4668      	mov	r0, sp
 800350c:	f001 f876 	bl	80045fc <HAL_RCC_ClockConfig>
 8003510:	2800      	cmp	r0, #0
 8003512:	d103      	bne.n	800351c <SystemClock_Config+0x50>
}
 8003514:	b00d      	add	sp, #52	; 0x34
 8003516:	bd00      	pop	{pc}
    Error_Handler();
 8003518:	f7ff ffd6 	bl	80034c8 <Error_Handler>
    Error_Handler();
 800351c:	f7ff ffd4 	bl	80034c8 <Error_Handler>

08003520 <main>:
{
 8003520:	b510      	push	{r4, lr}
  HAL_Init();
 8003522:	f000 f8e7 	bl	80036f4 <HAL_Init>
  SystemClock_Config();
 8003526:	f7ff ffd1 	bl	80034cc <SystemClock_Config>
  MX_GPIO_Init();
 800352a:	f7ff ff79 	bl	8003420 <MX_GPIO_Init>
  Brisk_PostInit();
 800352e:	f7ff fc05 	bl	8002d3c <Brisk_PostInit>
	  Brisk_Polling();
 8003532:	f7ff fc7f 	bl	8002e34 <Brisk_Polling>
  while (1)
 8003536:	e7fc      	b.n	8003532 <main+0x12>

08003538 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8003538:	b082      	sub	sp, #8
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800353a:	4b0a      	ldr	r3, [pc, #40]	; (8003564 <HAL_MspInit+0x2c>)
 800353c:	6c19      	ldr	r1, [r3, #64]	; 0x40
 800353e:	2201      	movs	r2, #1
 8003540:	4311      	orrs	r1, r2
 8003542:	6419      	str	r1, [r3, #64]	; 0x40
 8003544:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8003546:	400a      	ands	r2, r1
 8003548:	9200      	str	r2, [sp, #0]
 800354a:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800354c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800354e:	2180      	movs	r1, #128	; 0x80
 8003550:	0549      	lsls	r1, r1, #21
 8003552:	430a      	orrs	r2, r1
 8003554:	63da      	str	r2, [r3, #60]	; 0x3c
 8003556:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8003558:	400b      	ands	r3, r1
 800355a:	9301      	str	r3, [sp, #4]
 800355c:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800355e:	b002      	add	sp, #8
 8003560:	4770      	bx	lr
 8003562:	46c0      	nop			; (mov r8, r8)
 8003564:	40021000 	.word	0x40021000

08003568 <NMI_Handler>:
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
 8003568:	e7fe      	b.n	8003568 <NMI_Handler>

0800356a <HardFault_Handler>:
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800356a:	e7fe      	b.n	800356a <HardFault_Handler>

0800356c <SVC_Handler>:

  /* USER CODE END SVC_IRQn 0 */
  /* USER CODE BEGIN SVC_IRQn 1 */

  /* USER CODE END SVC_IRQn 1 */
}
 800356c:	4770      	bx	lr

0800356e <PendSV_Handler>:

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800356e:	4770      	bx	lr

08003570 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8003570:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */
  INT_Enter(SYSTICK_INT);
 8003572:	2000      	movs	r0, #0
 8003574:	f7fe fb60 	bl	8001c38 <INT_Enter>
  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8003578:	f000 f8c8 	bl	800370c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */
  Brisk_1ms_ISR();
 800357c:	f7ff fba8 	bl	8002cd0 <Brisk_1ms_ISR>
  INT_Leave(SYSTICK_INT);
 8003580:	2000      	movs	r0, #0
 8003582:	f7fe fb71 	bl	8001c68 <INT_Leave>
  /* USER CODE END SysTick_IRQn 1 */
}
 8003586:	bd10      	pop	{r4, pc}

08003588 <USART1_IRQHandler>:
/* please refer to the startup file (startup_stm32c0xx.s).                    */
/******************************************************************************/

/* USER CODE BEGIN 1 */
void USART1_IRQHandler(void)
{
 8003588:	b510      	push	{r4, lr}
  uint8_t byte;
  /* USER CODE BEGIN USART1_IRQn 0 */
  INT_Enter(USART1_INT);
 800358a:	2011      	movs	r0, #17
 800358c:	f7fe fb54 	bl	8001c38 <INT_Enter>
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabledIT_RXNE_RXFNE(USART_TypeDef *USARTx)
{
  return ((READ_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE) == (USART_CR1_RXNEIE_RXFNEIE)) ? 1UL : 0UL);
 8003590:	4b10      	ldr	r3, [pc, #64]	; (80035d4 <USART1_IRQHandler+0x4c>)
 8003592:	681b      	ldr	r3, [r3, #0]
 8003594:	069b      	lsls	r3, r3, #26
 8003596:	d50a      	bpl.n	80035ae <USART1_IRQHandler+0x26>
  return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE_RXFNE) == (USART_ISR_RXNE_RXFNE)) ? 1UL : 0UL);
 8003598:	4b0e      	ldr	r3, [pc, #56]	; (80035d4 <USART1_IRQHandler+0x4c>)
 800359a:	69db      	ldr	r3, [r3, #28]
 800359c:	069b      	lsls	r3, r3, #26
 800359e:	d506      	bpl.n	80035ae <USART1_IRQHandler+0x26>
  * @param  USARTx USART Instance
  * @retval Value between Min_Data=0x00 and Max_Data=0xFF
  */
__STATIC_INLINE uint8_t LL_USART_ReceiveData8(USART_TypeDef *USARTx)
{
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 80035a0:	4b0c      	ldr	r3, [pc, #48]	; (80035d4 <USART1_IRQHandler+0x4c>)
 80035a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  if (LL_USART_IsEnabledIT_RXNE(USART1)&&(LL_USART_IsActiveFlag_RXNE(USART1))) { // RNXEbyte received by USART
    AddTou8fifo(&u8fifo_to_SPIP[BT_STL_SERIAL], LL_USART_ReceiveData8(USART1));
 80035a4:	21ff      	movs	r1, #255	; 0xff
 80035a6:	4019      	ands	r1, r3
 80035a8:	480b      	ldr	r0, [pc, #44]	; (80035d8 <USART1_IRQHandler+0x50>)
 80035aa:	f7ff ff34 	bl	8003416 <AddTou8fifo>
  return ((READ_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE) == (USART_CR1_TXEIE_TXFNFIE)) ? 1UL : 0UL);
 80035ae:	4b09      	ldr	r3, [pc, #36]	; (80035d4 <USART1_IRQHandler+0x4c>)
 80035b0:	681b      	ldr	r3, [r3, #0]
 80035b2:	061b      	lsls	r3, r3, #24
 80035b4:	d50a      	bpl.n	80035cc <USART1_IRQHandler+0x44>
  return ((READ_BIT(USARTx->ISR, USART_ISR_TXE_TXFNF) == (USART_ISR_TXE_TXFNF)) ? 1UL : 0UL);
 80035b6:	4b07      	ldr	r3, [pc, #28]	; (80035d4 <USART1_IRQHandler+0x4c>)
 80035b8:	69db      	ldr	r3, [r3, #28]
 80035ba:	061b      	lsls	r3, r3, #24
 80035bc:	d506      	bpl.n	80035cc <USART1_IRQHandler+0x44>
  }

  if (LL_USART_IsEnabledIT_TXE(USART1)&&(LL_USART_IsActiveFlag_TXE(USART1))) { // TXE byte ready to send by USART
    byte = Clipu8fifo_Down(&u8fifo_from_SPIP[BT_STL_SERIAL]);
 80035be:	4807      	ldr	r0, [pc, #28]	; (80035dc <USART1_IRQHandler+0x54>)
 80035c0:	f7ff ff11 	bl	80033e6 <Clipu8fifo_Down>
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
  USARTx->TDR = Value;
 80035c4:	23ff      	movs	r3, #255	; 0xff
 80035c6:	4003      	ands	r3, r0
 80035c8:	4a02      	ldr	r2, [pc, #8]	; (80035d4 <USART1_IRQHandler+0x4c>)
 80035ca:	6293      	str	r3, [r2, #40]	; 0x28
    LL_USART_TransmitData8(USART1, byte);
  }
  /* USER CODE END USART1_IRQn 0 */
  /* USER CODE BEGIN USART1_IRQn 1 */
  INT_Leave(USART1_INT);
 80035cc:	2011      	movs	r0, #17
 80035ce:	f7fe fb4b 	bl	8001c68 <INT_Leave>
  /* USER CODE END USART1_IRQn 1 */
}
 80035d2:	bd10      	pop	{r4, pc}
 80035d4:	40013800 	.word	0x40013800
 80035d8:	20002180 	.word	0x20002180
 80035dc:	20002110 	.word	0x20002110

080035e0 <USART2_IRQHandler>:

/**
* @brief This function handles USART1 global interrupt.
*/
void USART2_IRQHandler(void)
{
 80035e0:	b510      	push	{r4, lr}
  uint8_t byte;
  /* USER CODE BEGIN USART2_IRQn 0 */
  INT_Enter(USART2_INT);
 80035e2:	2012      	movs	r0, #18
 80035e4:	f7fe fb28 	bl	8001c38 <INT_Enter>
  return ((READ_BIT(USARTx->CR1, USART_CR1_RXNEIE_RXFNEIE) == (USART_CR1_RXNEIE_RXFNEIE)) ? 1UL : 0UL);
 80035e8:	4b10      	ldr	r3, [pc, #64]	; (800362c <USART2_IRQHandler+0x4c>)
 80035ea:	681b      	ldr	r3, [r3, #0]
 80035ec:	069b      	lsls	r3, r3, #26
 80035ee:	d50a      	bpl.n	8003606 <USART2_IRQHandler+0x26>
  return ((READ_BIT(USARTx->ISR, USART_ISR_RXNE_RXFNE) == (USART_ISR_RXNE_RXFNE)) ? 1UL : 0UL);
 80035f0:	4b0e      	ldr	r3, [pc, #56]	; (800362c <USART2_IRQHandler+0x4c>)
 80035f2:	69db      	ldr	r3, [r3, #28]
 80035f4:	069b      	lsls	r3, r3, #26
 80035f6:	d506      	bpl.n	8003606 <USART2_IRQHandler+0x26>
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR) & 0xFFU);
 80035f8:	4b0c      	ldr	r3, [pc, #48]	; (800362c <USART2_IRQHandler+0x4c>)
 80035fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  if (LL_USART_IsEnabledIT_RXNE(USART2)&&(LL_USART_IsActiveFlag_RXNE(USART2))) { // RNXEbyte received by USART
    AddTou8fifo(&u8fifo_to_SPIP[ARD_STM_SERIAL], LL_USART_ReceiveData8(USART2));
 80035fc:	21ff      	movs	r1, #255	; 0xff
 80035fe:	4019      	ands	r1, r3
 8003600:	480b      	ldr	r0, [pc, #44]	; (8003630 <USART2_IRQHandler+0x50>)
 8003602:	f7ff ff08 	bl	8003416 <AddTou8fifo>
  return ((READ_BIT(USARTx->CR1, USART_CR1_TXEIE_TXFNFIE) == (USART_CR1_TXEIE_TXFNFIE)) ? 1UL : 0UL);
 8003606:	4b09      	ldr	r3, [pc, #36]	; (800362c <USART2_IRQHandler+0x4c>)
 8003608:	681b      	ldr	r3, [r3, #0]
 800360a:	061b      	lsls	r3, r3, #24
 800360c:	d50a      	bpl.n	8003624 <USART2_IRQHandler+0x44>
  return ((READ_BIT(USARTx->ISR, USART_ISR_TXE_TXFNF) == (USART_ISR_TXE_TXFNF)) ? 1UL : 0UL);
 800360e:	4b07      	ldr	r3, [pc, #28]	; (800362c <USART2_IRQHandler+0x4c>)
 8003610:	69db      	ldr	r3, [r3, #28]
 8003612:	061b      	lsls	r3, r3, #24
 8003614:	d506      	bpl.n	8003624 <USART2_IRQHandler+0x44>
  }

  if (LL_USART_IsEnabledIT_TXE(USART2)&&(LL_USART_IsActiveFlag_TXE(USART2))) { // TXE byte ready to send by USART
    byte = Clipu8fifo_Down(&u8fifo_from_SPIP[ARD_STM_SERIAL]);
 8003616:	4807      	ldr	r0, [pc, #28]	; (8003634 <USART2_IRQHandler+0x54>)
 8003618:	f7ff fee5 	bl	80033e6 <Clipu8fifo_Down>
  USARTx->TDR = Value;
 800361c:	23ff      	movs	r3, #255	; 0xff
 800361e:	4003      	ands	r3, r0
 8003620:	4a02      	ldr	r2, [pc, #8]	; (800362c <USART2_IRQHandler+0x4c>)
 8003622:	6293      	str	r3, [r2, #40]	; 0x28
    LL_USART_TransmitData8(USART2, byte);
  }
  /* USER CODE END USART2_IRQn 0 */
  /* USER CODE BEGIN USART2_IRQn 1 */
INT_Leave(USART2_INT);
 8003624:	2012      	movs	r0, #18
 8003626:	f7fe fb1f 	bl	8001c68 <INT_Leave>
  /* USER CODE END USART2_IRQn 1 */
}
 800362a:	bd10      	pop	{r4, pc}
 800362c:	40004400 	.word	0x40004400
 8003630:	20002148 	.word	0x20002148
 8003634:	200020d8 	.word	0x200020d8

08003638 <SystemInit>:
  
  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8003638:	4b02      	ldr	r3, [pc, #8]	; (8003644 <SystemInit+0xc>)
 800363a:	2280      	movs	r2, #128	; 0x80
 800363c:	0512      	lsls	r2, r2, #20
 800363e:	609a      	str	r2, [r3, #8]
#endif
}
 8003640:	4770      	bx	lr
 8003642:	46c0      	nop			; (mov r8, r8)
 8003644:	e000ed00 	.word	0xe000ed00

08003648 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8003648:	480d      	ldr	r0, [pc, #52]	; (8003680 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800364a:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  movs r1, #0
 800364c:	2100      	movs	r1, #0
  b LoopCopyDataInit
 800364e:	e003      	b.n	8003658 <LoopCopyDataInit>

08003650 <CopyDataInit>:

CopyDataInit:
  ldr r3, =_sidata
 8003650:	4b0c      	ldr	r3, [pc, #48]	; (8003684 <LoopForever+0x6>)
  ldr r3, [r3, r1]
 8003652:	585b      	ldr	r3, [r3, r1]
  str r3, [r0, r1]
 8003654:	5043      	str	r3, [r0, r1]
  adds r1, r1, #4
 8003656:	3104      	adds	r1, #4

08003658 <LoopCopyDataInit>:

LoopCopyDataInit:
  ldr r0, =_sdata
 8003658:	480b      	ldr	r0, [pc, #44]	; (8003688 <LoopForever+0xa>)
  ldr r3, =_edata
 800365a:	4b0c      	ldr	r3, [pc, #48]	; (800368c <LoopForever+0xe>)
  adds r2, r0, r1
 800365c:	1842      	adds	r2, r0, r1
  cmp r2, r3
 800365e:	429a      	cmp	r2, r3
  bcc CopyDataInit
 8003660:	d3f6      	bcc.n	8003650 <CopyDataInit>
  ldr r2, =_sbss
 8003662:	4a0b      	ldr	r2, [pc, #44]	; (8003690 <LoopForever+0x12>)
  b LoopFillZerobss
 8003664:	e002      	b.n	800366c <LoopFillZerobss>

08003666 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
  movs r3, #0
 8003666:	2300      	movs	r3, #0
  str  r3, [r2]
 8003668:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800366a:	3204      	adds	r2, #4

0800366c <LoopFillZerobss>:


LoopFillZerobss:
  ldr r3, = _ebss
 800366c:	4b09      	ldr	r3, [pc, #36]	; (8003694 <LoopForever+0x16>)
  cmp r2, r3
 800366e:	429a      	cmp	r2, r3
  bcc FillZerobss
 8003670:	d3f9      	bcc.n	8003666 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit
 8003672:	f7ff ffe1 	bl	8003638 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 8003676:	f002 f8b7 	bl	80057e8 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800367a:	f7ff ff51 	bl	8003520 <main>

0800367e <LoopForever>:

LoopForever:
    b LoopForever
 800367e:	e7fe      	b.n	800367e <LoopForever>
  ldr   r0, =_estack
 8003680:	20003000 	.word	0x20003000
  ldr r3, =_sidata
 8003684:	08007130 	.word	0x08007130
  ldr r0, =_sdata
 8003688:	20000000 	.word	0x20000000
  ldr r3, =_edata
 800368c:	20000218 	.word	0x20000218
  ldr r2, =_sbss
 8003690:	20000218 	.word	0x20000218
  ldr r3, = _ebss
 8003694:	2000229c 	.word	0x2000229c

08003698 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8003698:	e7fe      	b.n	8003698 <ADC1_IRQHandler>
	...

0800369c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800369c:	b510      	push	{r4, lr}
 800369e:	0004      	movs	r4, r0
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 80036a0:	4b11      	ldr	r3, [pc, #68]	; (80036e8 <HAL_InitTick+0x4c>)
 80036a2:	6819      	ldr	r1, [r3, #0]
 80036a4:	2900      	cmp	r1, #0
 80036a6:	d101      	bne.n	80036ac <HAL_InitTick+0x10>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 80036a8:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 80036aa:	bd10      	pop	{r4, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 80036ac:	20fa      	movs	r0, #250	; 0xfa
 80036ae:	0080      	lsls	r0, r0, #2
 80036b0:	f7fc fd2a 	bl	8000108 <__udivsi3>
 80036b4:	0001      	movs	r1, r0
 80036b6:	4b0d      	ldr	r3, [pc, #52]	; (80036ec <HAL_InitTick+0x50>)
 80036b8:	6818      	ldr	r0, [r3, #0]
 80036ba:	f7fc fd25 	bl	8000108 <__udivsi3>
 80036be:	f000 fce1 	bl	8004084 <HAL_SYSTICK_Config>
 80036c2:	2800      	cmp	r0, #0
 80036c4:	d10d      	bne.n	80036e2 <HAL_InitTick+0x46>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80036c6:	2c03      	cmp	r4, #3
 80036c8:	d901      	bls.n	80036ce <HAL_InitTick+0x32>
        status = HAL_ERROR;
 80036ca:	2001      	movs	r0, #1
 80036cc:	e7ed      	b.n	80036aa <HAL_InitTick+0xe>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80036ce:	3001      	adds	r0, #1
 80036d0:	2200      	movs	r2, #0
 80036d2:	0021      	movs	r1, r4
 80036d4:	4240      	negs	r0, r0
 80036d6:	f000 fc89 	bl	8003fec <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 80036da:	4b05      	ldr	r3, [pc, #20]	; (80036f0 <HAL_InitTick+0x54>)
 80036dc:	601c      	str	r4, [r3, #0]
  HAL_StatusTypeDef  status = HAL_OK;
 80036de:	2000      	movs	r0, #0
 80036e0:	e7e3      	b.n	80036aa <HAL_InitTick+0xe>
      status = HAL_ERROR;
 80036e2:	2001      	movs	r0, #1
 80036e4:	e7e1      	b.n	80036aa <HAL_InitTick+0xe>
 80036e6:	46c0      	nop			; (mov r8, r8)
 80036e8:	200001f8 	.word	0x200001f8
 80036ec:	200001f4 	.word	0x200001f4
 80036f0:	200001fc 	.word	0x200001fc

080036f4 <HAL_Init>:
{
 80036f4:	b510      	push	{r4, lr}
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80036f6:	2003      	movs	r0, #3
 80036f8:	f7ff ffd0 	bl	800369c <HAL_InitTick>
 80036fc:	1e04      	subs	r4, r0, #0
 80036fe:	d002      	beq.n	8003706 <HAL_Init+0x12>
    status = HAL_ERROR;
 8003700:	2401      	movs	r4, #1
}
 8003702:	0020      	movs	r0, r4
 8003704:	bd10      	pop	{r4, pc}
    HAL_MspInit();
 8003706:	f7ff ff17 	bl	8003538 <HAL_MspInit>
 800370a:	e7fa      	b.n	8003702 <HAL_Init+0xe>

0800370c <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 800370c:	4a03      	ldr	r2, [pc, #12]	; (800371c <HAL_IncTick+0x10>)
 800370e:	6813      	ldr	r3, [r2, #0]
 8003710:	4903      	ldr	r1, [pc, #12]	; (8003720 <HAL_IncTick+0x14>)
 8003712:	6809      	ldr	r1, [r1, #0]
 8003714:	185b      	adds	r3, r3, r1
 8003716:	6013      	str	r3, [r2, #0]
}
 8003718:	4770      	bx	lr
 800371a:	46c0      	nop			; (mov r8, r8)
 800371c:	20002298 	.word	0x20002298
 8003720:	200001f8 	.word	0x200001f8

08003724 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8003724:	4b01      	ldr	r3, [pc, #4]	; (800372c <HAL_GetTick+0x8>)
 8003726:	6818      	ldr	r0, [r3, #0]
}
 8003728:	4770      	bx	lr
 800372a:	46c0      	nop			; (mov r8, r8)
 800372c:	20002298 	.word	0x20002298

08003730 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8003730:	b570      	push	{r4, r5, r6, lr}
 8003732:	0004      	movs	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8003734:	f7ff fff6 	bl	8003724 <HAL_GetTick>
 8003738:	0005      	movs	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800373a:	1c63      	adds	r3, r4, #1
 800373c:	d002      	beq.n	8003744 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800373e:	4b04      	ldr	r3, [pc, #16]	; (8003750 <HAL_Delay+0x20>)
 8003740:	681b      	ldr	r3, [r3, #0]
 8003742:	18e4      	adds	r4, r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8003744:	f7ff ffee 	bl	8003724 <HAL_GetTick>
 8003748:	1b40      	subs	r0, r0, r5
 800374a:	42a0      	cmp	r0, r4
 800374c:	d3fa      	bcc.n	8003744 <HAL_Delay+0x14>
  {
  }
}
 800374e:	bd70      	pop	{r4, r5, r6, pc}
 8003750:	200001f8 	.word	0x200001f8

08003754 <HAL_ADC_MspInit>:
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADC_MspInit must be implemented in the user file.
   */
}
 8003754:	4770      	bx	lr
	...

08003758 <HAL_ADC_Init>:
{
 8003758:	b570      	push	{r4, r5, r6, lr}
 800375a:	b082      	sub	sp, #8
 800375c:	0004      	movs	r4, r0
  __IO uint32_t wait_loop_index = 0UL;
 800375e:	2300      	movs	r3, #0
 8003760:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
 8003762:	2800      	cmp	r0, #0
 8003764:	d100      	bne.n	8003768 <HAL_ADC_Init+0x10>
 8003766:	e119      	b.n	800399c <HAL_ADC_Init+0x244>
  if (hadc->State == HAL_ADC_STATE_RESET)
 8003768:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800376a:	2b00      	cmp	r3, #0
 800376c:	d012      	beq.n	8003794 <HAL_ADC_Init+0x3c>
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 800376e:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8003770:	689a      	ldr	r2, [r3, #8]
 8003772:	00d2      	lsls	r2, r2, #3
 8003774:	d41b      	bmi.n	80037ae <HAL_ADC_Init+0x56>
  MODIFY_REG(ADCx->CR,
 8003776:	689a      	ldr	r2, [r3, #8]
 8003778:	4989      	ldr	r1, [pc, #548]	; (80039a0 <HAL_ADC_Init+0x248>)
 800377a:	4011      	ands	r1, r2
 800377c:	2280      	movs	r2, #128	; 0x80
 800377e:	0552      	lsls	r2, r2, #21
 8003780:	430a      	orrs	r2, r1
 8003782:	609a      	str	r2, [r3, #8]
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8003784:	4b87      	ldr	r3, [pc, #540]	; (80039a4 <HAL_ADC_Init+0x24c>)
 8003786:	6818      	ldr	r0, [r3, #0]
 8003788:	4987      	ldr	r1, [pc, #540]	; (80039a8 <HAL_ADC_Init+0x250>)
 800378a:	f7fc fcbd 	bl	8000108 <__udivsi3>
 800378e:	0040      	lsls	r0, r0, #1
 8003790:	9001      	str	r0, [sp, #4]
    while (wait_loop_index != 0UL)
 8003792:	e009      	b.n	80037a8 <HAL_ADC_Init+0x50>
    HAL_ADC_MspInit(hadc);
 8003794:	f7ff ffde 	bl	8003754 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8003798:	2300      	movs	r3, #0
 800379a:	65e3      	str	r3, [r4, #92]	; 0x5c
    hadc->Lock = HAL_UNLOCKED;
 800379c:	2254      	movs	r2, #84	; 0x54
 800379e:	54a3      	strb	r3, [r4, r2]
 80037a0:	e7e5      	b.n	800376e <HAL_ADC_Init+0x16>
      wait_loop_index--;
 80037a2:	9b01      	ldr	r3, [sp, #4]
 80037a4:	3b01      	subs	r3, #1
 80037a6:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 80037a8:	9b01      	ldr	r3, [sp, #4]
 80037aa:	2b00      	cmp	r3, #0
 80037ac:	d1f9      	bne.n	80037a2 <HAL_ADC_Init+0x4a>
  if (LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0UL)
 80037ae:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 80037b0:	689a      	ldr	r2, [r3, #8]
 80037b2:	00d2      	lsls	r2, r2, #3
 80037b4:	d500      	bpl.n	80037b8 <HAL_ADC_Init+0x60>
 80037b6:	e09d      	b.n	80038f4 <HAL_ADC_Init+0x19c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 80037b8:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80037ba:	2110      	movs	r1, #16
 80037bc:	430a      	orrs	r2, r1
 80037be:	65a2      	str	r2, [r4, #88]	; 0x58
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80037c0:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80037c2:	390f      	subs	r1, #15
 80037c4:	430a      	orrs	r2, r1
 80037c6:	65e2      	str	r2, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
 80037c8:	2001      	movs	r0, #1
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80037ca:	689a      	ldr	r2, [r3, #8]
 80037cc:	2104      	movs	r1, #4
 80037ce:	000d      	movs	r5, r1
 80037d0:	4015      	ands	r5, r2
 80037d2:	4211      	tst	r1, r2
 80037d4:	d000      	beq.n	80037d8 <HAL_ADC_Init+0x80>
 80037d6:	2501      	movs	r5, #1
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 80037d8:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80037da:	06d2      	lsls	r2, r2, #27
 80037dc:	d500      	bpl.n	80037e0 <HAL_ADC_Init+0x88>
 80037de:	e0d6      	b.n	800398e <HAL_ADC_Init+0x236>
      && (tmp_adc_reg_is_conversion_on_going == 0UL)
 80037e0:	2d00      	cmp	r5, #0
 80037e2:	d000      	beq.n	80037e6 <HAL_ADC_Init+0x8e>
 80037e4:	e0d3      	b.n	800398e <HAL_ADC_Init+0x236>
    ADC_STATE_CLR_SET(hadc->State,
 80037e6:	6da2      	ldr	r2, [r4, #88]	; 0x58
 80037e8:	4970      	ldr	r1, [pc, #448]	; (80039ac <HAL_ADC_Init+0x254>)
 80037ea:	400a      	ands	r2, r1
 80037ec:	3106      	adds	r1, #6
 80037ee:	31ff      	adds	r1, #255	; 0xff
 80037f0:	430a      	orrs	r2, r1
 80037f2:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80037f4:	689a      	ldr	r2, [r3, #8]
 80037f6:	07d2      	lsls	r2, r2, #31
 80037f8:	d452      	bmi.n	80038a0 <HAL_ADC_Init+0x148>
                   ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 80037fa:	7e22      	ldrb	r2, [r4, #24]
 80037fc:	0392      	lsls	r2, r2, #14
      tmpCFGR1 |= (hadc->Init.Resolution                                          |
 80037fe:	68a1      	ldr	r1, [r4, #8]
 8003800:	430a      	orrs	r2, r1
                   ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 8003802:	7e61      	ldrb	r1, [r4, #25]
 8003804:	03c9      	lsls	r1, r1, #15
                   ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)      |
 8003806:	430a      	orrs	r2, r1
                   ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 8003808:	7ea6      	ldrb	r6, [r4, #26]
 800380a:	0371      	lsls	r1, r6, #13
                   ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)   |
 800380c:	430a      	orrs	r2, r1
                   ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 800380e:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8003810:	2900      	cmp	r1, #0
 8003812:	d001      	beq.n	8003818 <HAL_ADC_Init+0xc0>
 8003814:	2180      	movs	r1, #128	; 0x80
 8003816:	0149      	lsls	r1, r1, #5
                   ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)  |
 8003818:	430a      	orrs	r2, r1
                   ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                          |
 800381a:	68e1      	ldr	r1, [r4, #12]
 800381c:	430a      	orrs	r2, r1
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 800381e:	6921      	ldr	r1, [r4, #16]
 8003820:	2900      	cmp	r1, #0
 8003822:	db69      	blt.n	80038f8 <HAL_ADC_Init+0x1a0>
 8003824:	2180      	movs	r1, #128	; 0x80
 8003826:	0389      	lsls	r1, r1, #14
                   hadc->Init.DataAlign                                           |
 8003828:	430a      	orrs	r2, r1
                   ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests));
 800382a:	212c      	movs	r1, #44	; 0x2c
 800382c:	5c61      	ldrb	r1, [r4, r1]
 800382e:	0049      	lsls	r1, r1, #1
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 8003830:	430a      	orrs	r2, r1
      if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8003832:	2120      	movs	r1, #32
 8003834:	5c61      	ldrb	r1, [r4, r1]
 8003836:	2901      	cmp	r1, #1
 8003838:	d061      	beq.n	80038fe <HAL_ADC_Init+0x1a6>
      if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 800383a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800383c:	2900      	cmp	r1, #0
 800383e:	d005      	beq.n	800384c <HAL_ADC_Init+0xf4>
        tmpCFGR1 |= ((hadc->Init.ExternalTrigConv & ADC_CFGR1_EXTSEL) |
 8003840:	26e0      	movs	r6, #224	; 0xe0
 8003842:	0076      	lsls	r6, r6, #1
 8003844:	4031      	ands	r1, r6
 8003846:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8003848:	4331      	orrs	r1, r6
 800384a:	430a      	orrs	r2, r1
      MODIFY_REG(hadc->Instance->CFGR1,
 800384c:	68d9      	ldr	r1, [r3, #12]
 800384e:	4e58      	ldr	r6, [pc, #352]	; (80039b0 <HAL_ADC_Init+0x258>)
 8003850:	4031      	ands	r1, r6
 8003852:	430a      	orrs	r2, r1
 8003854:	60da      	str	r2, [r3, #12]
      tmpCFGR2 |= ((hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 8003856:	6863      	ldr	r3, [r4, #4]
 8003858:	0f9b      	lsrs	r3, r3, #30
 800385a:	079b      	lsls	r3, r3, #30
 800385c:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 800385e:	431a      	orrs	r2, r3
      if (hadc->Init.OversamplingMode == ENABLE)
 8003860:	213c      	movs	r1, #60	; 0x3c
 8003862:	5c61      	ldrb	r1, [r4, r1]
 8003864:	2901      	cmp	r1, #1
 8003866:	d059      	beq.n	800391c <HAL_ADC_Init+0x1c4>
      MODIFY_REG(hadc->Instance->CFGR2,
 8003868:	6821      	ldr	r1, [r4, #0]
 800386a:	690b      	ldr	r3, [r1, #16]
 800386c:	4e51      	ldr	r6, [pc, #324]	; (80039b4 <HAL_ADC_Init+0x25c>)
 800386e:	4033      	ands	r3, r6
 8003870:	4313      	orrs	r3, r2
 8003872:	610b      	str	r3, [r1, #16]
      if (((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV1) &&
 8003874:	6863      	ldr	r3, [r4, #4]
 8003876:	22c0      	movs	r2, #192	; 0xc0
 8003878:	0612      	lsls	r2, r2, #24
 800387a:	4293      	cmp	r3, r2
 800387c:	d010      	beq.n	80038a0 <HAL_ADC_Init+0x148>
 800387e:	2280      	movs	r2, #128	; 0x80
 8003880:	05d2      	lsls	r2, r2, #23
 8003882:	4293      	cmp	r3, r2
 8003884:	d00c      	beq.n	80038a0 <HAL_ADC_Init+0x148>
          ((hadc->Init.ClockPrescaler) != ADC_CLOCK_SYNC_PCLK_DIV2) &&
 8003886:	2280      	movs	r2, #128	; 0x80
 8003888:	0612      	lsls	r2, r2, #24
 800388a:	4293      	cmp	r3, r2
 800388c:	d008      	beq.n	80038a0 <HAL_ADC_Init+0x148>
        MODIFY_REG(ADC1_COMMON->CCR,
 800388e:	494a      	ldr	r1, [pc, #296]	; (80039b8 <HAL_ADC_Init+0x260>)
 8003890:	680a      	ldr	r2, [r1, #0]
 8003892:	4e4a      	ldr	r6, [pc, #296]	; (80039bc <HAL_ADC_Init+0x264>)
 8003894:	4032      	ands	r2, r6
 8003896:	26f0      	movs	r6, #240	; 0xf0
 8003898:	03b6      	lsls	r6, r6, #14
 800389a:	4033      	ands	r3, r6
 800389c:	4313      	orrs	r3, r2
 800389e:	600b      	str	r3, [r1, #0]
    LL_ADC_SetSamplingTimeCommonChannels(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_1, hadc->Init.SamplingTimeCommon1);
 80038a0:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->SMPR,
 80038a2:	6953      	ldr	r3, [r2, #20]
 80038a4:	2107      	movs	r1, #7
 80038a6:	438b      	bics	r3, r1
 80038a8:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80038aa:	430b      	orrs	r3, r1
 80038ac:	6153      	str	r3, [r2, #20]
    LL_ADC_SetSamplingTimeCommonChannels(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_2, hadc->Init.SamplingTimeCommon2);
 80038ae:	6821      	ldr	r1, [r4, #0]
 80038b0:	694b      	ldr	r3, [r1, #20]
 80038b2:	2270      	movs	r2, #112	; 0x70
 80038b4:	4393      	bics	r3, r2
 80038b6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80038b8:	0112      	lsls	r2, r2, #4
 80038ba:	4313      	orrs	r3, r2
 80038bc:	614b      	str	r3, [r1, #20]
    if (hadc->Init.ScanConvMode == ADC_SCAN_DISABLE)
 80038be:	6923      	ldr	r3, [r4, #16]
 80038c0:	2b00      	cmp	r3, #0
 80038c2:	d135      	bne.n	8003930 <HAL_ADC_Init+0x1d8>
      SET_BIT(hadc->Instance->CHSELR,
 80038c4:	6822      	ldr	r2, [r4, #0]
 80038c6:	6a91      	ldr	r1, [r2, #40]	; 0x28
 80038c8:	3b10      	subs	r3, #16
 80038ca:	430b      	orrs	r3, r1
 80038cc:	6293      	str	r3, [r2, #40]	; 0x28
    if (LL_ADC_GetSamplingTimeCommonChannels(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_1)
 80038ce:	6823      	ldr	r3, [r4, #0]
  return (uint32_t)((READ_BIT(ADCx->SMPR, ADC_SMPR_SMP1 << (SamplingTimeY & ADC_SAMPLING_TIME_SMP_SHIFT_MASK)))
 80038d0:	695a      	ldr	r2, [r3, #20]
 80038d2:	2307      	movs	r3, #7
 80038d4:	4013      	ands	r3, r2
 80038d6:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80038d8:	429a      	cmp	r2, r3
 80038da:	d04f      	beq.n	800397c <HAL_ADC_Init+0x224>
      ADC_STATE_CLR_SET(hadc->State,
 80038dc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80038de:	2212      	movs	r2, #18
 80038e0:	4393      	bics	r3, r2
 80038e2:	3a02      	subs	r2, #2
 80038e4:	4313      	orrs	r3, r2
 80038e6:	65a3      	str	r3, [r4, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 80038e8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80038ea:	3a0f      	subs	r2, #15
 80038ec:	4313      	orrs	r3, r2
 80038ee:	65e3      	str	r3, [r4, #92]	; 0x5c
      tmp_hal_status = HAL_ERROR;
 80038f0:	2001      	movs	r0, #1
 80038f2:	e051      	b.n	8003998 <HAL_ADC_Init+0x240>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80038f4:	2000      	movs	r0, #0
 80038f6:	e768      	b.n	80037ca <HAL_ADC_Init+0x72>
                   ADC_SCAN_SEQ_MODE(hadc->Init.ScanConvMode)                     |
 80038f8:	0049      	lsls	r1, r1, #1
 80038fa:	0849      	lsrs	r1, r1, #1
 80038fc:	e794      	b.n	8003828 <HAL_ADC_Init+0xd0>
        if (hadc->Init.ContinuousConvMode == DISABLE)
 80038fe:	2e00      	cmp	r6, #0
 8003900:	d103      	bne.n	800390a <HAL_ADC_Init+0x1b2>
          tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8003902:	2180      	movs	r1, #128	; 0x80
 8003904:	0249      	lsls	r1, r1, #9
 8003906:	430a      	orrs	r2, r1
 8003908:	e797      	b.n	800383a <HAL_ADC_Init+0xe2>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800390a:	6da1      	ldr	r1, [r4, #88]	; 0x58
 800390c:	2620      	movs	r6, #32
 800390e:	4331      	orrs	r1, r6
 8003910:	65a1      	str	r1, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003912:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8003914:	3e1f      	subs	r6, #31
 8003916:	4331      	orrs	r1, r6
 8003918:	65e1      	str	r1, [r4, #92]	; 0x5c
 800391a:	e78e      	b.n	800383a <HAL_ADC_Init+0xe2>
                     (hadc->Init.ClockPrescaler & ADC_CFGR2_CKMODE) |
 800391c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800391e:	430b      	orrs	r3, r1
                     hadc->Init.Oversampling.Ratio         |
 8003920:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8003922:	430b      	orrs	r3, r1
                     hadc->Init.Oversampling.RightBitShift |
 8003924:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8003926:	430b      	orrs	r3, r1
        tmpCFGR2 |= (ADC_CFGR2_OVSE |
 8003928:	4313      	orrs	r3, r2
 800392a:	2201      	movs	r2, #1
 800392c:	431a      	orrs	r2, r3
 800392e:	e79b      	b.n	8003868 <HAL_ADC_Init+0x110>
    else if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8003930:	2280      	movs	r2, #128	; 0x80
 8003932:	0392      	lsls	r2, r2, #14
 8003934:	4293      	cmp	r3, r2
 8003936:	d1ca      	bne.n	80038ce <HAL_ADC_Init+0x176>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 8003938:	2d07      	cmp	r5, #7
 800393a:	d808      	bhi.n	800394e <HAL_ADC_Init+0x1f6>
        if (((hadc->ADCGroupRegularSequencerRanks >> (ADCGroupRegularSequencerRanksCount * 4UL)) & ADC_CHSELR_SQ1) ==
 800393c:	00ab      	lsls	r3, r5, #2
 800393e:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8003940:	40da      	lsrs	r2, r3
 8003942:	230f      	movs	r3, #15
 8003944:	4013      	ands	r3, r2
 8003946:	2b0f      	cmp	r3, #15
 8003948:	d001      	beq.n	800394e <HAL_ADC_Init+0x1f6>
      for (ADCGroupRegularSequencerRanksCount = 0UL; ADCGroupRegularSequencerRanksCount < (8UL); ADCGroupRegularSequencerRanksCount++)
 800394a:	3501      	adds	r5, #1
 800394c:	e7f4      	b.n	8003938 <HAL_ADC_Init+0x1e0>
      if (ADCGroupRegularSequencerRanksCount == 1UL)
 800394e:	2d01      	cmp	r5, #1
 8003950:	d00d      	beq.n	800396e <HAL_ADC_Init+0x216>
        MODIFY_REG(hadc->Instance->CHSELR,
 8003952:	6821      	ldr	r1, [r4, #0]
 8003954:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8003956:	69e3      	ldr	r3, [r4, #28]
 8003958:	3b01      	subs	r3, #1
 800395a:	009b      	lsls	r3, r3, #2
 800395c:	221c      	movs	r2, #28
 800395e:	401a      	ands	r2, r3
 8003960:	2310      	movs	r3, #16
 8003962:	425b      	negs	r3, r3
 8003964:	4093      	lsls	r3, r2
 8003966:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8003968:	4313      	orrs	r3, r2
 800396a:	628b      	str	r3, [r1, #40]	; 0x28
 800396c:	e7af      	b.n	80038ce <HAL_ADC_Init+0x176>
        SET_BIT(hadc->Instance->CHSELR,
 800396e:	6822      	ldr	r2, [r4, #0]
 8003970:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8003972:	2310      	movs	r3, #16
 8003974:	425b      	negs	r3, r3
 8003976:	430b      	orrs	r3, r1
 8003978:	6293      	str	r3, [r2, #40]	; 0x28
 800397a:	e7a8      	b.n	80038ce <HAL_ADC_Init+0x176>
      ADC_CLEAR_ERRORCODE(hadc);
 800397c:	2300      	movs	r3, #0
 800397e:	65e3      	str	r3, [r4, #92]	; 0x5c
      ADC_STATE_CLR_SET(hadc->State,
 8003980:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003982:	2203      	movs	r2, #3
 8003984:	4393      	bics	r3, r2
 8003986:	3a02      	subs	r2, #2
 8003988:	4313      	orrs	r3, r2
 800398a:	65a3      	str	r3, [r4, #88]	; 0x58
 800398c:	e004      	b.n	8003998 <HAL_ADC_Init+0x240>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800398e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003990:	2210      	movs	r2, #16
 8003992:	4313      	orrs	r3, r2
 8003994:	65a3      	str	r3, [r4, #88]	; 0x58
    tmp_hal_status = HAL_ERROR;
 8003996:	2001      	movs	r0, #1
}
 8003998:	b002      	add	sp, #8
 800399a:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 800399c:	2001      	movs	r0, #1
 800399e:	e7fb      	b.n	8003998 <HAL_ADC_Init+0x240>
 80039a0:	6fffffe8 	.word	0x6fffffe8
 80039a4:	200001f4 	.word	0x200001f4
 80039a8:	00030d40 	.word	0x00030d40
 80039ac:	fffffefd 	.word	0xfffffefd
 80039b0:	fffe0201 	.word	0xfffe0201
 80039b4:	1ffffc02 	.word	0x1ffffc02
 80039b8:	40012708 	.word	0x40012708
 80039bc:	ffc3ffff 	.word	0xffc3ffff

080039c0 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef *hadc, uint32_t Timeout)
{
 80039c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80039c2:	0004      	movs	r4, r0
 80039c4:	000d      	movs	r5, r1

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80039c6:	6946      	ldr	r6, [r0, #20]
 80039c8:	2e08      	cmp	r6, #8
 80039ca:	d004      	beq.n	80039d6 <HAL_ADC_PollForConversion+0x16>
    /* each conversion:                                                       */
    /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
    /* several ranks and polling for end of each conversion.                  */
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if ((hadc->Instance->CFGR1 & ADC_CFGR1_DMAEN) != 0UL)
 80039cc:	6803      	ldr	r3, [r0, #0]
 80039ce:	68db      	ldr	r3, [r3, #12]
 80039d0:	07db      	lsls	r3, r3, #31
 80039d2:	d419      	bmi.n	8003a08 <HAL_ADC_PollForConversion+0x48>

      return HAL_ERROR;
    }
    else
    {
      tmp_Flag_End = (ADC_FLAG_EOC);
 80039d4:	2604      	movs	r6, #4
    }
  }

  /* Get tick count */
  tickstart = HAL_GetTick();
 80039d6:	f7ff fea5 	bl	8003724 <HAL_GetTick>
 80039da:	0007      	movs	r7, r0

  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while ((hadc->Instance->ISR & tmp_Flag_End) == 0UL)
 80039dc:	6823      	ldr	r3, [r4, #0]
 80039de:	681a      	ldr	r2, [r3, #0]
 80039e0:	4216      	tst	r6, r2
 80039e2:	d117      	bne.n	8003a14 <HAL_ADC_PollForConversion+0x54>
  {
    /* Check if timeout is disabled (set to infinite wait) */
    if (Timeout != HAL_MAX_DELAY)
 80039e4:	1c6b      	adds	r3, r5, #1
 80039e6:	d0f9      	beq.n	80039dc <HAL_ADC_PollForConversion+0x1c>
    {
      if (((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0UL))
 80039e8:	f7ff fe9c 	bl	8003724 <HAL_GetTick>
 80039ec:	1bc0      	subs	r0, r0, r7
 80039ee:	42a8      	cmp	r0, r5
 80039f0:	d801      	bhi.n	80039f6 <HAL_ADC_PollForConversion+0x36>
 80039f2:	2d00      	cmp	r5, #0
 80039f4:	d1f2      	bne.n	80039dc <HAL_ADC_PollForConversion+0x1c>
      {
        /* Update ADC state machine to timeout */
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 80039f6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80039f8:	2204      	movs	r2, #4
 80039fa:	4313      	orrs	r3, r2
 80039fc:	65a3      	str	r3, [r4, #88]	; 0x58

        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 80039fe:	2354      	movs	r3, #84	; 0x54
 8003a00:	2200      	movs	r2, #0
 8003a02:	54e2      	strb	r2, [r4, r3]

        return HAL_TIMEOUT;
 8003a04:	2003      	movs	r0, #3
 8003a06:	e029      	b.n	8003a5c <HAL_ADC_PollForConversion+0x9c>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003a08:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8003a0a:	2220      	movs	r2, #32
 8003a0c:	4313      	orrs	r3, r2
 8003a0e:	6583      	str	r3, [r0, #88]	; 0x58
      return HAL_ERROR;
 8003a10:	2001      	movs	r0, #1
 8003a12:	e023      	b.n	8003a5c <HAL_ADC_PollForConversion+0x9c>
      }
    }
  }

  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8003a14:	6da1      	ldr	r1, [r4, #88]	; 0x58
 8003a16:	2280      	movs	r2, #128	; 0x80
 8003a18:	0092      	lsls	r2, r2, #2
 8003a1a:	430a      	orrs	r2, r1
 8003a1c:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CFGR1, ADC_CFGR1_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR1_EXTEN)) ? 1UL : 0UL);
 8003a1e:	68d9      	ldr	r1, [r3, #12]
 8003a20:	22c0      	movs	r2, #192	; 0xc0
 8003a22:	0112      	lsls	r2, r2, #4
 8003a24:	4211      	tst	r1, r2
 8003a26:	d113      	bne.n	8003a50 <HAL_ADC_PollForConversion+0x90>

  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if ((LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
      && (hadc->Init.ContinuousConvMode == DISABLE)
 8003a28:	7ea2      	ldrb	r2, [r4, #26]
 8003a2a:	2a00      	cmp	r2, #0
 8003a2c:	d110      	bne.n	8003a50 <HAL_ADC_PollForConversion+0x90>
     )
  {
    /* Check whether end of sequence is reached */
    if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8003a2e:	681a      	ldr	r2, [r3, #0]
 8003a30:	0712      	lsls	r2, r2, #28
 8003a32:	d50d      	bpl.n	8003a50 <HAL_ADC_PollForConversion+0x90>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8003a34:	689a      	ldr	r2, [r3, #8]
 8003a36:	0752      	lsls	r2, r2, #29
 8003a38:	d411      	bmi.n	8003a5e <HAL_ADC_PollForConversion+0x9e>
      {
        /* Disable ADC end of single conversion interrupt on group regular */
        /* Note: Overrun interrupt was enabled with EOC interrupt in          */
        /* HAL_Start_IT(), but is not disabled here because can be used       */
        /* by overrun IRQ process below.                                      */
        __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8003a3a:	685a      	ldr	r2, [r3, #4]
 8003a3c:	210c      	movs	r1, #12
 8003a3e:	438a      	bics	r2, r1
 8003a40:	605a      	str	r2, [r3, #4]

        /* Set ADC state */
        ADC_STATE_CLR_SET(hadc->State,
 8003a42:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003a44:	4a0b      	ldr	r2, [pc, #44]	; (8003a74 <HAL_ADC_PollForConversion+0xb4>)
 8003a46:	4013      	ands	r3, r2
 8003a48:	3204      	adds	r2, #4
 8003a4a:	32ff      	adds	r2, #255	; 0xff
 8003a4c:	4313      	orrs	r3, r2
 8003a4e:	65a3      	str	r3, [r4, #88]	; 0x58
  }

  /* Clear end of conversion flag of regular group if low power feature       */
  /* "LowPowerAutoWait " is disabled, to not interfere with this feature      */
  /* until data register is read using function HAL_ADC_GetValue().           */
  if (hadc->Init.LowPowerAutoWait == DISABLE)
 8003a50:	7e20      	ldrb	r0, [r4, #24]
 8003a52:	2800      	cmp	r0, #0
 8003a54:	d10c      	bne.n	8003a70 <HAL_ADC_PollForConversion+0xb0>
  {
    /* Clear regular group conversion flag */
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8003a56:	6823      	ldr	r3, [r4, #0]
 8003a58:	220c      	movs	r2, #12
 8003a5a:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8003a5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003a5e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003a60:	2220      	movs	r2, #32
 8003a62:	4313      	orrs	r3, r2
 8003a64:	65a3      	str	r3, [r4, #88]	; 0x58
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003a66:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8003a68:	3a1f      	subs	r2, #31
 8003a6a:	4313      	orrs	r3, r2
 8003a6c:	65e3      	str	r3, [r4, #92]	; 0x5c
 8003a6e:	e7ef      	b.n	8003a50 <HAL_ADC_PollForConversion+0x90>
  return HAL_OK;
 8003a70:	2000      	movs	r0, #0
 8003a72:	e7f3      	b.n	8003a5c <HAL_ADC_PollForConversion+0x9c>
 8003a74:	fffffefe 	.word	0xfffffefe

08003a78 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */

  /* Return ADC converted value */
  return hadc->Instance->DR;
 8003a78:	6803      	ldr	r3, [r0, #0]
 8003a7a:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 8003a7c:	4770      	bx	lr
	...

08003a80 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef *hadc, ADC_ChannelConfTypeDef *sConfig)
{
 8003a80:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003a82:	b083      	sub	sp, #12
 8003a84:	0004      	movs	r4, r0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmp_config_internal_channel;
  __IO uint32_t wait_loop_index = 0UL;
 8003a86:	2300      	movs	r3, #0
 8003a88:	9301      	str	r3, [sp, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_SAMPLING_TIME_COMMON(sConfig->SamplingTime));

  if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8003a8a:	6905      	ldr	r5, [r0, #16]

    assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 8003a8c:	3354      	adds	r3, #84	; 0x54
 8003a8e:	5cc3      	ldrb	r3, [r0, r3]
 8003a90:	2b01      	cmp	r3, #1
 8003a92:	d100      	bne.n	8003a96 <HAL_ADC_ConfigChannel+0x16>
 8003a94:	e122      	b.n	8003cdc <HAL_ADC_ConfigChannel+0x25c>
 8003a96:	2354      	movs	r3, #84	; 0x54
 8003a98:	2201      	movs	r2, #1
 8003a9a:	54c2      	strb	r2, [r0, r3]
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor       */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8003a9c:	6800      	ldr	r0, [r0, #0]
 8003a9e:	6883      	ldr	r3, [r0, #8]
 8003aa0:	3203      	adds	r2, #3
 8003aa2:	0016      	movs	r6, r2
 8003aa4:	401e      	ands	r6, r3
 8003aa6:	421a      	tst	r2, r3
 8003aa8:	d009      	beq.n	8003abe <HAL_ADC_ConfigChannel+0x3e>
  /* channel could be done on neither of the channel configuration structure  */
  /* parameters.                                                              */
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8003aaa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003aac:	321c      	adds	r2, #28
 8003aae:	4313      	orrs	r3, r2
 8003ab0:	65a3      	str	r3, [r4, #88]	; 0x58

    tmp_hal_status = HAL_ERROR;
 8003ab2:	2001      	movs	r0, #1
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003ab4:	2354      	movs	r3, #84	; 0x54
 8003ab6:	2200      	movs	r2, #0
 8003ab8:	54e2      	strb	r2, [r4, r3]

  /* Return function status */
  return tmp_hal_status;
}
 8003aba:	b003      	add	sp, #12
 8003abc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if (sConfig->Rank != ADC_RANK_NONE)
 8003abe:	684b      	ldr	r3, [r1, #4]
 8003ac0:	2b02      	cmp	r3, #2
 8003ac2:	d100      	bne.n	8003ac6 <HAL_ADC_ConfigChannel+0x46>
 8003ac4:	e0d6      	b.n	8003c74 <HAL_ADC_ConfigChannel+0x1f4>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8003ac6:	2280      	movs	r2, #128	; 0x80
 8003ac8:	0612      	lsls	r2, r2, #24
 8003aca:	4295      	cmp	r5, r2
 8003acc:	d026      	beq.n	8003b1c <HAL_ADC_ConfigChannel+0x9c>
 8003ace:	4a84      	ldr	r2, [pc, #528]	; (8003ce0 <HAL_ADC_ConfigChannel+0x260>)
 8003ad0:	4295      	cmp	r5, r2
 8003ad2:	d023      	beq.n	8003b1c <HAL_ADC_ConfigChannel+0x9c>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8003ad4:	221f      	movs	r2, #31
 8003ad6:	4013      	ands	r3, r2
 8003ad8:	3a10      	subs	r2, #16
 8003ada:	409a      	lsls	r2, r3
 8003adc:	6e25      	ldr	r5, [r4, #96]	; 0x60
 8003ade:	4395      	bics	r5, r2
 8003ae0:	002a      	movs	r2, r5
 8003ae2:	680d      	ldr	r5, [r1, #0]
 8003ae4:	026f      	lsls	r7, r5, #9
 8003ae6:	d12f      	bne.n	8003b48 <HAL_ADC_ConfigChannel+0xc8>
 8003ae8:	0ead      	lsrs	r5, r5, #26
 8003aea:	261f      	movs	r6, #31
 8003aec:	402e      	ands	r6, r5
 8003aee:	409e      	lsls	r6, r3
 8003af0:	4316      	orrs	r6, r2
 8003af2:	6626      	str	r6, [r4, #96]	; 0x60
        if (((sConfig->Rank >> 2UL) + 1UL) <= hadc->Init.NbrOfConversion)
 8003af4:	684d      	ldr	r5, [r1, #4]
 8003af6:	08ab      	lsrs	r3, r5, #2
 8003af8:	3301      	adds	r3, #1
 8003afa:	69e2      	ldr	r2, [r4, #28]
 8003afc:	4293      	cmp	r3, r2
 8003afe:	d813      	bhi.n	8003b28 <HAL_ADC_ConfigChannel+0xa8>
  MODIFY_REG(ADCx->CHSELR,
 8003b00:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8003b02:	231f      	movs	r3, #31
 8003b04:	401d      	ands	r5, r3
 8003b06:	3b10      	subs	r3, #16
 8003b08:	001e      	movs	r6, r3
 8003b0a:	40ae      	lsls	r6, r5
 8003b0c:	43b2      	bics	r2, r6
 8003b0e:	680e      	ldr	r6, [r1, #0]
 8003b10:	0eb6      	lsrs	r6, r6, #26
 8003b12:	4033      	ands	r3, r6
 8003b14:	40ab      	lsls	r3, r5
 8003b16:	4313      	orrs	r3, r2
 8003b18:	6283      	str	r3, [r0, #40]	; 0x28
}
 8003b1a:	e005      	b.n	8003b28 <HAL_ADC_ConfigChannel+0xa8>
  SET_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8003b1c:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8003b1e:	680b      	ldr	r3, [r1, #0]
 8003b20:	025b      	lsls	r3, r3, #9
 8003b22:	0a5b      	lsrs	r3, r3, #9
 8003b24:	4313      	orrs	r3, r2
 8003b26:	6283      	str	r3, [r0, #40]	; 0x28
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8003b28:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->SMPR,
 8003b2a:	6942      	ldr	r2, [r0, #20]
 8003b2c:	680b      	ldr	r3, [r1, #0]
 8003b2e:	021b      	lsls	r3, r3, #8
 8003b30:	439a      	bics	r2, r3
 8003b32:	688d      	ldr	r5, [r1, #8]
 8003b34:	402b      	ands	r3, r5
 8003b36:	4d6b      	ldr	r5, [pc, #428]	; (8003ce4 <HAL_ADC_ConfigChannel+0x264>)
 8003b38:	402b      	ands	r3, r5
 8003b3a:	4313      	orrs	r3, r2
 8003b3c:	6143      	str	r3, [r0, #20]
      if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8003b3e:	680b      	ldr	r3, [r1, #0]
 8003b40:	2b00      	cmp	r3, #0
 8003b42:	db5f      	blt.n	8003c04 <HAL_ADC_ConfigChannel+0x184>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003b44:	2000      	movs	r0, #0
 8003b46:	e7b5      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
        MODIFY_REG(hadc->ADCGroupRegularSequencerRanks,
 8003b48:	07ef      	lsls	r7, r5, #31
 8003b4a:	d4d0      	bmi.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003b4c:	07ae      	lsls	r6, r5, #30
 8003b4e:	d42f      	bmi.n	8003bb0 <HAL_ADC_ConfigChannel+0x130>
 8003b50:	076e      	lsls	r6, r5, #29
 8003b52:	d42f      	bmi.n	8003bb4 <HAL_ADC_ConfigChannel+0x134>
 8003b54:	072e      	lsls	r6, r5, #28
 8003b56:	d42f      	bmi.n	8003bb8 <HAL_ADC_ConfigChannel+0x138>
 8003b58:	06ee      	lsls	r6, r5, #27
 8003b5a:	d42f      	bmi.n	8003bbc <HAL_ADC_ConfigChannel+0x13c>
 8003b5c:	06ae      	lsls	r6, r5, #26
 8003b5e:	d42f      	bmi.n	8003bc0 <HAL_ADC_ConfigChannel+0x140>
 8003b60:	066e      	lsls	r6, r5, #25
 8003b62:	d42f      	bmi.n	8003bc4 <HAL_ADC_ConfigChannel+0x144>
 8003b64:	062e      	lsls	r6, r5, #24
 8003b66:	d42f      	bmi.n	8003bc8 <HAL_ADC_ConfigChannel+0x148>
 8003b68:	05ee      	lsls	r6, r5, #23
 8003b6a:	d42f      	bmi.n	8003bcc <HAL_ADC_ConfigChannel+0x14c>
 8003b6c:	05ae      	lsls	r6, r5, #22
 8003b6e:	d42f      	bmi.n	8003bd0 <HAL_ADC_ConfigChannel+0x150>
 8003b70:	056e      	lsls	r6, r5, #21
 8003b72:	d42f      	bmi.n	8003bd4 <HAL_ADC_ConfigChannel+0x154>
 8003b74:	052e      	lsls	r6, r5, #20
 8003b76:	d42f      	bmi.n	8003bd8 <HAL_ADC_ConfigChannel+0x158>
 8003b78:	04ee      	lsls	r6, r5, #19
 8003b7a:	d42f      	bmi.n	8003bdc <HAL_ADC_ConfigChannel+0x15c>
 8003b7c:	04ae      	lsls	r6, r5, #18
 8003b7e:	d42f      	bmi.n	8003be0 <HAL_ADC_ConfigChannel+0x160>
 8003b80:	046e      	lsls	r6, r5, #17
 8003b82:	d42f      	bmi.n	8003be4 <HAL_ADC_ConfigChannel+0x164>
 8003b84:	042e      	lsls	r6, r5, #16
 8003b86:	d42f      	bmi.n	8003be8 <HAL_ADC_ConfigChannel+0x168>
 8003b88:	03ee      	lsls	r6, r5, #15
 8003b8a:	d42f      	bmi.n	8003bec <HAL_ADC_ConfigChannel+0x16c>
 8003b8c:	03ae      	lsls	r6, r5, #14
 8003b8e:	d42f      	bmi.n	8003bf0 <HAL_ADC_ConfigChannel+0x170>
 8003b90:	036e      	lsls	r6, r5, #13
 8003b92:	d42f      	bmi.n	8003bf4 <HAL_ADC_ConfigChannel+0x174>
 8003b94:	032e      	lsls	r6, r5, #12
 8003b96:	d42f      	bmi.n	8003bf8 <HAL_ADC_ConfigChannel+0x178>
 8003b98:	02ee      	lsls	r6, r5, #11
 8003b9a:	d42f      	bmi.n	8003bfc <HAL_ADC_ConfigChannel+0x17c>
 8003b9c:	02ae      	lsls	r6, r5, #10
 8003b9e:	d42f      	bmi.n	8003c00 <HAL_ADC_ConfigChannel+0x180>
 8003ba0:	2780      	movs	r7, #128	; 0x80
 8003ba2:	03ff      	lsls	r7, r7, #15
 8003ba4:	002e      	movs	r6, r5
 8003ba6:	403e      	ands	r6, r7
 8003ba8:	423d      	tst	r5, r7
 8003baa:	d0a0      	beq.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bac:	2616      	movs	r6, #22
 8003bae:	e79e      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bb0:	2601      	movs	r6, #1
 8003bb2:	e79c      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bb4:	2602      	movs	r6, #2
 8003bb6:	e79a      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bb8:	2603      	movs	r6, #3
 8003bba:	e798      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bbc:	2604      	movs	r6, #4
 8003bbe:	e796      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bc0:	2605      	movs	r6, #5
 8003bc2:	e794      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bc4:	2606      	movs	r6, #6
 8003bc6:	e792      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bc8:	2607      	movs	r6, #7
 8003bca:	e790      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bcc:	2608      	movs	r6, #8
 8003bce:	e78e      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bd0:	2609      	movs	r6, #9
 8003bd2:	e78c      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bd4:	260a      	movs	r6, #10
 8003bd6:	e78a      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bd8:	260b      	movs	r6, #11
 8003bda:	e788      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bdc:	260c      	movs	r6, #12
 8003bde:	e786      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003be0:	260d      	movs	r6, #13
 8003be2:	e784      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003be4:	260e      	movs	r6, #14
 8003be6:	e782      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003be8:	260f      	movs	r6, #15
 8003bea:	e780      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bec:	2610      	movs	r6, #16
 8003bee:	e77e      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bf0:	2611      	movs	r6, #17
 8003bf2:	e77c      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bf4:	2612      	movs	r6, #18
 8003bf6:	e77a      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bf8:	2613      	movs	r6, #19
 8003bfa:	e778      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003bfc:	2614      	movs	r6, #20
 8003bfe:	e776      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
 8003c00:	2615      	movs	r6, #21
 8003c02:	e774      	b.n	8003aee <HAL_ADC_ConfigChannel+0x6e>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN));
 8003c04:	4a38      	ldr	r2, [pc, #224]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003c06:	6811      	ldr	r1, [r2, #0]
 8003c08:	22c0      	movs	r2, #192	; 0xc0
 8003c0a:	0412      	lsls	r2, r2, #16
 8003c0c:	400a      	ands	r2, r1
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8003c0e:	4837      	ldr	r0, [pc, #220]	; (8003cec <HAL_ADC_ConfigChannel+0x26c>)
 8003c10:	4283      	cmp	r3, r0
 8003c12:	d004      	beq.n	8003c1e <HAL_ADC_ConfigChannel+0x19e>
        else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) &&
 8003c14:	4836      	ldr	r0, [pc, #216]	; (8003cf0 <HAL_ADC_ConfigChannel+0x270>)
 8003c16:	4283      	cmp	r3, r0
 8003c18:	d01f      	beq.n	8003c5a <HAL_ADC_ConfigChannel+0x1da>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003c1a:	2000      	movs	r0, #0
 8003c1c:	e74a      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
        if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8003c1e:	0208      	lsls	r0, r1, #8
 8003c20:	d4f8      	bmi.n	8003c14 <HAL_ADC_ConfigChannel+0x194>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8003c22:	2380      	movs	r3, #128	; 0x80
 8003c24:	041b      	lsls	r3, r3, #16
 8003c26:	431a      	orrs	r2, r3
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN, PathInternal);
 8003c28:	492f      	ldr	r1, [pc, #188]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003c2a:	680b      	ldr	r3, [r1, #0]
 8003c2c:	4831      	ldr	r0, [pc, #196]	; (8003cf4 <HAL_ADC_ConfigChannel+0x274>)
 8003c2e:	4003      	ands	r3, r0
 8003c30:	431a      	orrs	r2, r3
 8003c32:	600a      	str	r2, [r1, #0]
          wait_loop_index = (((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL))) + 1UL);
 8003c34:	4b30      	ldr	r3, [pc, #192]	; (8003cf8 <HAL_ADC_ConfigChannel+0x278>)
 8003c36:	6818      	ldr	r0, [r3, #0]
 8003c38:	4930      	ldr	r1, [pc, #192]	; (8003cfc <HAL_ADC_ConfigChannel+0x27c>)
 8003c3a:	f7fc fa65 	bl	8000108 <__udivsi3>
 8003c3e:	0043      	lsls	r3, r0, #1
 8003c40:	181b      	adds	r3, r3, r0
 8003c42:	009b      	lsls	r3, r3, #2
 8003c44:	3301      	adds	r3, #1
 8003c46:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 8003c48:	e002      	b.n	8003c50 <HAL_ADC_ConfigChannel+0x1d0>
            wait_loop_index--;
 8003c4a:	9b01      	ldr	r3, [sp, #4]
 8003c4c:	3b01      	subs	r3, #1
 8003c4e:	9301      	str	r3, [sp, #4]
          while (wait_loop_index != 0UL)
 8003c50:	9b01      	ldr	r3, [sp, #4]
 8003c52:	2b00      	cmp	r3, #0
 8003c54:	d1f9      	bne.n	8003c4a <HAL_ADC_ConfigChannel+0x1ca>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003c56:	2000      	movs	r0, #0
 8003c58:	e72c      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
        else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) &&
 8003c5a:	024b      	lsls	r3, r1, #9
 8003c5c:	d43c      	bmi.n	8003cd8 <HAL_ADC_ConfigChannel+0x258>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8003c5e:	2380      	movs	r3, #128	; 0x80
 8003c60:	03db      	lsls	r3, r3, #15
 8003c62:	431a      	orrs	r2, r3
 8003c64:	4920      	ldr	r1, [pc, #128]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003c66:	680b      	ldr	r3, [r1, #0]
 8003c68:	4822      	ldr	r0, [pc, #136]	; (8003cf4 <HAL_ADC_ConfigChannel+0x274>)
 8003c6a:	4003      	ands	r3, r0
 8003c6c:	431a      	orrs	r2, r3
 8003c6e:	600a      	str	r2, [r1, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003c70:	2000      	movs	r0, #0
}
 8003c72:	e71f      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
      if ((hadc->Init.ScanConvMode == ADC_SCAN_SEQ_FIXED)       ||
 8003c74:	2380      	movs	r3, #128	; 0x80
 8003c76:	061b      	lsls	r3, r3, #24
 8003c78:	429d      	cmp	r5, r3
 8003c7a:	d002      	beq.n	8003c82 <HAL_ADC_ConfigChannel+0x202>
 8003c7c:	4b18      	ldr	r3, [pc, #96]	; (8003ce0 <HAL_ADC_ConfigChannel+0x260>)
 8003c7e:	429d      	cmp	r5, r3
 8003c80:	d105      	bne.n	8003c8e <HAL_ADC_ConfigChannel+0x20e>
  CLEAR_BIT(ADCx->CHSELR, (Channel & ADC_CHANNEL_ID_BITFIELD_MASK));
 8003c82:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8003c84:	680b      	ldr	r3, [r1, #0]
 8003c86:	025b      	lsls	r3, r3, #9
 8003c88:	0a5b      	lsrs	r3, r3, #9
 8003c8a:	439a      	bics	r2, r3
 8003c8c:	6282      	str	r2, [r0, #40]	; 0x28
      if (__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8003c8e:	680b      	ldr	r3, [r1, #0]
 8003c90:	2b00      	cmp	r3, #0
 8003c92:	db01      	blt.n	8003c98 <HAL_ADC_ConfigChannel+0x218>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003c94:	2000      	movs	r0, #0
 8003c96:	e70d      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN));
 8003c98:	4a13      	ldr	r2, [pc, #76]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003c9a:	6812      	ldr	r2, [r2, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8003c9c:	4913      	ldr	r1, [pc, #76]	; (8003cec <HAL_ADC_ConfigChannel+0x26c>)
 8003c9e:	428b      	cmp	r3, r1
 8003ca0:	d004      	beq.n	8003cac <HAL_ADC_ConfigChannel+0x22c>
        else if (sConfig->Channel == ADC_CHANNEL_VREFINT)
 8003ca2:	4913      	ldr	r1, [pc, #76]	; (8003cf0 <HAL_ADC_ConfigChannel+0x270>)
 8003ca4:	428b      	cmp	r3, r1
 8003ca6:	d00c      	beq.n	8003cc2 <HAL_ADC_ConfigChannel+0x242>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003ca8:	2000      	movs	r0, #0
 8003caa:	e703      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8003cac:	2380      	movs	r3, #128	; 0x80
 8003cae:	03db      	lsls	r3, r3, #15
 8003cb0:	401a      	ands	r2, r3
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN, PathInternal);
 8003cb2:	490d      	ldr	r1, [pc, #52]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003cb4:	680b      	ldr	r3, [r1, #0]
 8003cb6:	480f      	ldr	r0, [pc, #60]	; (8003cf4 <HAL_ADC_ConfigChannel+0x274>)
 8003cb8:	4003      	ands	r3, r0
 8003cba:	431a      	orrs	r2, r3
 8003cbc:	600a      	str	r2, [r1, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003cbe:	2000      	movs	r0, #0
}
 8003cc0:	e6f8      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
          LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance),
 8003cc2:	2380      	movs	r3, #128	; 0x80
 8003cc4:	041b      	lsls	r3, r3, #16
 8003cc6:	401a      	ands	r2, r3
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN, PathInternal);
 8003cc8:	4907      	ldr	r1, [pc, #28]	; (8003ce8 <HAL_ADC_ConfigChannel+0x268>)
 8003cca:	680b      	ldr	r3, [r1, #0]
 8003ccc:	4809      	ldr	r0, [pc, #36]	; (8003cf4 <HAL_ADC_ConfigChannel+0x274>)
 8003cce:	4003      	ands	r3, r0
 8003cd0:	431a      	orrs	r2, r3
 8003cd2:	600a      	str	r2, [r1, #0]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8003cd4:	2000      	movs	r0, #0
}
 8003cd6:	e6ed      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
 8003cd8:	2000      	movs	r0, #0
 8003cda:	e6eb      	b.n	8003ab4 <HAL_ADC_ConfigChannel+0x34>
  __HAL_LOCK(hadc);
 8003cdc:	2002      	movs	r0, #2
 8003cde:	e6ec      	b.n	8003aba <HAL_ADC_ConfigChannel+0x3a>
 8003ce0:	80000004 	.word	0x80000004
 8003ce4:	7fffff00 	.word	0x7fffff00
 8003ce8:	40012708 	.word	0x40012708
 8003cec:	a4000200 	.word	0xa4000200
 8003cf0:	a8000400 	.word	0xa8000400
 8003cf4:	ff3fffff 	.word	0xff3fffff
 8003cf8:	200001f4 	.word	0x200001f4
 8003cfc:	00030d40 	.word	0x00030d40

08003d00 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef *hadc)
{
 8003d00:	b530      	push	{r4, r5, lr}
 8003d02:	b083      	sub	sp, #12
 8003d04:	0004      	movs	r4, r0
  uint32_t tickstart;
  __IO uint32_t wait_loop_index = 0UL;
 8003d06:	2300      	movs	r3, #0
 8003d08:	9301      	str	r3, [sp, #4]

  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003d0a:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003d0c:	689a      	ldr	r2, [r3, #8]
 8003d0e:	07d2      	lsls	r2, r2, #31
 8003d10:	d44d      	bmi.n	8003dae <ADC_Enable+0xae>
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_ADSTP | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8003d12:	6899      	ldr	r1, [r3, #8]
 8003d14:	4a27      	ldr	r2, [pc, #156]	; (8003db4 <ADC_Enable+0xb4>)
 8003d16:	4211      	tst	r1, r2
 8003d18:	d111      	bne.n	8003d3e <ADC_Enable+0x3e>
  MODIFY_REG(ADCx->CR,
 8003d1a:	689a      	ldr	r2, [r3, #8]
 8003d1c:	4926      	ldr	r1, [pc, #152]	; (8003db8 <ADC_Enable+0xb8>)
 8003d1e:	400a      	ands	r2, r1
 8003d20:	2101      	movs	r1, #1
 8003d22:	430a      	orrs	r2, r1
 8003d24:	609a      	str	r2, [r3, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN));
 8003d26:	4b25      	ldr	r3, [pc, #148]	; (8003dbc <ADC_Enable+0xbc>)
 8003d28:	681b      	ldr	r3, [r3, #0]
    }

    /* Enable the ADC peripheral */
    LL_ADC_Enable(hadc->Instance);

    if ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) != 0UL)
 8003d2a:	021b      	lsls	r3, r3, #8
 8003d2c:	d517      	bpl.n	8003d5e <ADC_Enable+0x5e>
      /* Delay for temperature sensor buffer stabilization time */
      /* Wait loop initialization and execution */
      /* Note: Variable divided by 2 to compensate partially              */
      /*       CPU processing cycles, scaling in us split to not          */
      /*       exceed 32 bits register capacity and handle low frequency. */
      wait_loop_index = (((LL_ADC_DELAY_TEMPSENSOR_BUFFER_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL))) + 1UL);
 8003d2e:	4b24      	ldr	r3, [pc, #144]	; (8003dc0 <ADC_Enable+0xc0>)
 8003d30:	6818      	ldr	r0, [r3, #0]
 8003d32:	4924      	ldr	r1, [pc, #144]	; (8003dc4 <ADC_Enable+0xc4>)
 8003d34:	f7fc f9e8 	bl	8000108 <__udivsi3>
 8003d38:	3001      	adds	r0, #1
 8003d3a:	9001      	str	r0, [sp, #4]
      while (wait_loop_index != 0UL)
 8003d3c:	e00c      	b.n	8003d58 <ADC_Enable+0x58>
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003d3e:	6d83      	ldr	r3, [r0, #88]	; 0x58
 8003d40:	2210      	movs	r2, #16
 8003d42:	4313      	orrs	r3, r2
 8003d44:	6583      	str	r3, [r0, #88]	; 0x58
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003d46:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 8003d48:	3a0f      	subs	r2, #15
 8003d4a:	4313      	orrs	r3, r2
 8003d4c:	65c3      	str	r3, [r0, #92]	; 0x5c
      return HAL_ERROR;
 8003d4e:	2001      	movs	r0, #1
 8003d50:	e02e      	b.n	8003db0 <ADC_Enable+0xb0>
      {
        wait_loop_index--;
 8003d52:	9b01      	ldr	r3, [sp, #4]
 8003d54:	3b01      	subs	r3, #1
 8003d56:	9301      	str	r3, [sp, #4]
      while (wait_loop_index != 0UL)
 8003d58:	9b01      	ldr	r3, [sp, #4]
 8003d5a:	2b00      	cmp	r3, #0
 8003d5c:	d1f9      	bne.n	8003d52 <ADC_Enable+0x52>
      }
    }

    /* If low power mode AutoPowerOff is enabled, power-on/off phases are     */
    /* performed automatically by hardware and flag ADC ready is not set.     */
    if (hadc->Init.LowPowerAutoPowerOff != ENABLE)
 8003d5e:	7e63      	ldrb	r3, [r4, #25]
 8003d60:	2b01      	cmp	r3, #1
 8003d62:	d101      	bne.n	8003d68 <ADC_Enable+0x68>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8003d64:	2000      	movs	r0, #0
 8003d66:	e023      	b.n	8003db0 <ADC_Enable+0xb0>
      tickstart = HAL_GetTick();
 8003d68:	f7ff fcdc 	bl	8003724 <HAL_GetTick>
 8003d6c:	0005      	movs	r5, r0
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8003d6e:	e004      	b.n	8003d7a <ADC_Enable+0x7a>
        if ((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8003d70:	f7ff fcd8 	bl	8003724 <HAL_GetTick>
 8003d74:	1b40      	subs	r0, r0, r5
 8003d76:	2802      	cmp	r0, #2
 8003d78:	d80d      	bhi.n	8003d96 <ADC_Enable+0x96>
      while (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8003d7a:	6823      	ldr	r3, [r4, #0]
 8003d7c:	681a      	ldr	r2, [r3, #0]
 8003d7e:	07d2      	lsls	r2, r2, #31
 8003d80:	d413      	bmi.n	8003daa <ADC_Enable+0xaa>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003d82:	689a      	ldr	r2, [r3, #8]
 8003d84:	07d2      	lsls	r2, r2, #31
 8003d86:	d4f3      	bmi.n	8003d70 <ADC_Enable+0x70>
  MODIFY_REG(ADCx->CR,
 8003d88:	689a      	ldr	r2, [r3, #8]
 8003d8a:	490b      	ldr	r1, [pc, #44]	; (8003db8 <ADC_Enable+0xb8>)
 8003d8c:	400a      	ands	r2, r1
 8003d8e:	2101      	movs	r1, #1
 8003d90:	430a      	orrs	r2, r1
 8003d92:	609a      	str	r2, [r3, #8]
}
 8003d94:	e7ec      	b.n	8003d70 <ADC_Enable+0x70>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003d96:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003d98:	2210      	movs	r2, #16
 8003d9a:	4313      	orrs	r3, r2
 8003d9c:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003d9e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8003da0:	3a0f      	subs	r2, #15
 8003da2:	4313      	orrs	r3, r2
 8003da4:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 8003da6:	2001      	movs	r0, #1
 8003da8:	e002      	b.n	8003db0 <ADC_Enable+0xb0>
  return HAL_OK;
 8003daa:	2000      	movs	r0, #0
 8003dac:	e000      	b.n	8003db0 <ADC_Enable+0xb0>
 8003dae:	2000      	movs	r0, #0
}
 8003db0:	b003      	add	sp, #12
 8003db2:	bd30      	pop	{r4, r5, pc}
 8003db4:	80000017 	.word	0x80000017
 8003db8:	7fffffe8 	.word	0x7fffffe8
 8003dbc:	40012708 	.word	0x40012708
 8003dc0:	200001f4 	.word	0x200001f4
 8003dc4:	00030d40 	.word	0x00030d40

08003dc8 <HAL_ADC_Start>:
{
 8003dc8:	b510      	push	{r4, lr}
 8003dca:	0004      	movs	r4, r0
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 8003dcc:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8003dce:	689b      	ldr	r3, [r3, #8]
 8003dd0:	075b      	lsls	r3, r3, #29
 8003dd2:	d424      	bmi.n	8003e1e <HAL_ADC_Start+0x56>
    __HAL_LOCK(hadc);
 8003dd4:	2354      	movs	r3, #84	; 0x54
 8003dd6:	5cc3      	ldrb	r3, [r0, r3]
 8003dd8:	2b01      	cmp	r3, #1
 8003dda:	d022      	beq.n	8003e22 <HAL_ADC_Start+0x5a>
 8003ddc:	2354      	movs	r3, #84	; 0x54
 8003dde:	2201      	movs	r2, #1
 8003de0:	54c2      	strb	r2, [r0, r3]
    tmp_hal_status = ADC_Enable(hadc);
 8003de2:	f7ff ff8d 	bl	8003d00 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 8003de6:	2800      	cmp	r0, #0
 8003de8:	d115      	bne.n	8003e16 <HAL_ADC_Start+0x4e>
      ADC_STATE_CLR_SET(hadc->State,
 8003dea:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003dec:	4a0e      	ldr	r2, [pc, #56]	; (8003e28 <HAL_ADC_Start+0x60>)
 8003dee:	401a      	ands	r2, r3
 8003df0:	2380      	movs	r3, #128	; 0x80
 8003df2:	005b      	lsls	r3, r3, #1
 8003df4:	4313      	orrs	r3, r2
 8003df6:	65a3      	str	r3, [r4, #88]	; 0x58
      ADC_CLEAR_ERRORCODE(hadc);
 8003df8:	2300      	movs	r3, #0
 8003dfa:	65e3      	str	r3, [r4, #92]	; 0x5c
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8003dfc:	6822      	ldr	r2, [r4, #0]
 8003dfe:	211c      	movs	r1, #28
 8003e00:	6011      	str	r1, [r2, #0]
      __HAL_UNLOCK(hadc);
 8003e02:	2254      	movs	r2, #84	; 0x54
 8003e04:	54a3      	strb	r3, [r4, r2]
      LL_ADC_REG_StartConversion(hadc->Instance);
 8003e06:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8003e08:	6893      	ldr	r3, [r2, #8]
 8003e0a:	4908      	ldr	r1, [pc, #32]	; (8003e2c <HAL_ADC_Start+0x64>)
 8003e0c:	400b      	ands	r3, r1
 8003e0e:	2104      	movs	r1, #4
 8003e10:	430b      	orrs	r3, r1
 8003e12:	6093      	str	r3, [r2, #8]
}
 8003e14:	e004      	b.n	8003e20 <HAL_ADC_Start+0x58>
      __HAL_UNLOCK(hadc);
 8003e16:	2354      	movs	r3, #84	; 0x54
 8003e18:	2200      	movs	r2, #0
 8003e1a:	54e2      	strb	r2, [r4, r3]
 8003e1c:	e000      	b.n	8003e20 <HAL_ADC_Start+0x58>
    tmp_hal_status = HAL_BUSY;
 8003e1e:	2002      	movs	r0, #2
}
 8003e20:	bd10      	pop	{r4, pc}
    __HAL_LOCK(hadc);
 8003e22:	2002      	movs	r0, #2
 8003e24:	e7fc      	b.n	8003e20 <HAL_ADC_Start+0x58>
 8003e26:	46c0      	nop			; (mov r8, r8)
 8003e28:	fffff0fe 	.word	0xfffff0fe
 8003e2c:	7fffffe8 	.word	0x7fffffe8

08003e30 <ADC_Disable>:
  *         stopped.
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Disable(ADC_HandleTypeDef *hadc)
{
 8003e30:	b570      	push	{r4, r5, r6, lr}
 8003e32:	0004      	movs	r4, r0
  uint32_t tickstart;
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8003e34:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8003e36:	689a      	ldr	r2, [r3, #8]
 8003e38:	2102      	movs	r1, #2
 8003e3a:	0008      	movs	r0, r1
 8003e3c:	4010      	ands	r0, r2
 8003e3e:	4211      	tst	r1, r2
 8003e40:	d000      	beq.n	8003e44 <ADC_Disable+0x14>
 8003e42:	2001      	movs	r0, #1
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003e44:	689a      	ldr	r2, [r3, #8]
 8003e46:	07d2      	lsls	r2, r2, #31
 8003e48:	d531      	bpl.n	8003eae <ADC_Disable+0x7e>

  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if ((LL_ADC_IsEnabled(hadc->Instance) != 0UL)
      && (tmp_adc_is_disable_on_going == 0UL)
 8003e4a:	2800      	cmp	r0, #0
 8003e4c:	d131      	bne.n	8003eb2 <ADC_Disable+0x82>
     )
  {
    /* Check if conditions to disable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8003e4e:	6899      	ldr	r1, [r3, #8]
 8003e50:	2205      	movs	r2, #5
 8003e52:	400a      	ands	r2, r1
 8003e54:	2a01      	cmp	r2, #1
 8003e56:	d009      	beq.n	8003e6c <ADC_Disable+0x3c>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
    }
    else
    {
      /* Update ADC state machine to error */
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003e58:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003e5a:	2210      	movs	r2, #16
 8003e5c:	4313      	orrs	r3, r2
 8003e5e:	65a3      	str	r3, [r4, #88]	; 0x58

      /* Set ADC error code to ADC peripheral internal error */
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003e60:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8003e62:	3a0f      	subs	r2, #15
 8003e64:	4313      	orrs	r3, r2
 8003e66:	65e3      	str	r3, [r4, #92]	; 0x5c

      return HAL_ERROR;
 8003e68:	2001      	movs	r0, #1
 8003e6a:	e021      	b.n	8003eb0 <ADC_Disable+0x80>
  MODIFY_REG(ADCx->CR,
 8003e6c:	689a      	ldr	r2, [r3, #8]
 8003e6e:	4912      	ldr	r1, [pc, #72]	; (8003eb8 <ADC_Disable+0x88>)
 8003e70:	400a      	ands	r2, r1
 8003e72:	2102      	movs	r1, #2
 8003e74:	430a      	orrs	r2, r1
 8003e76:	609a      	str	r2, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8003e78:	6823      	ldr	r3, [r4, #0]
 8003e7a:	2203      	movs	r2, #3
 8003e7c:	601a      	str	r2, [r3, #0]
    }

    /* Wait for ADC effectively disabled */
    /* Get tick count */
    tickstart = HAL_GetTick();
 8003e7e:	f7ff fc51 	bl	8003724 <HAL_GetTick>
 8003e82:	0005      	movs	r5, r0

    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8003e84:	6823      	ldr	r3, [r4, #0]
 8003e86:	689b      	ldr	r3, [r3, #8]
 8003e88:	07db      	lsls	r3, r3, #31
 8003e8a:	d50e      	bpl.n	8003eaa <ADC_Disable+0x7a>
    {
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8003e8c:	f7ff fc4a 	bl	8003724 <HAL_GetTick>
 8003e90:	1b40      	subs	r0, r0, r5
 8003e92:	2802      	cmp	r0, #2
 8003e94:	d9f6      	bls.n	8003e84 <ADC_Disable+0x54>
      {
        /* Update ADC state machine to error */
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003e96:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003e98:	2210      	movs	r2, #16
 8003e9a:	4313      	orrs	r3, r2
 8003e9c:	65a3      	str	r3, [r4, #88]	; 0x58

        /* Set ADC error code to ADC peripheral internal error */
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003e9e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8003ea0:	3a0f      	subs	r2, #15
 8003ea2:	4313      	orrs	r3, r2
 8003ea4:	65e3      	str	r3, [r4, #92]	; 0x5c

        return HAL_ERROR;
 8003ea6:	2001      	movs	r0, #1
 8003ea8:	e002      	b.n	8003eb0 <ADC_Disable+0x80>
      }
    }
  }

  /* Return HAL status */
  return HAL_OK;
 8003eaa:	2000      	movs	r0, #0
 8003eac:	e000      	b.n	8003eb0 <ADC_Disable+0x80>
 8003eae:	2000      	movs	r0, #0
}
 8003eb0:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 8003eb2:	2000      	movs	r0, #0
 8003eb4:	e7fc      	b.n	8003eb0 <ADC_Disable+0x80>
 8003eb6:	46c0      	nop			; (mov r8, r8)
 8003eb8:	7fffffe8 	.word	0x7fffffe8

08003ebc <HAL_ADCEx_Calibration_Start>:
  *         HAL_ADC_GetValue() (value on 7 bits: from DR[6;0]).
  * @param  hadc       ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc)
{
 8003ebc:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003ebe:	b083      	sub	sp, #12
 8003ec0:	0004      	movs	r4, r0
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;
 8003ec2:	2300      	movs	r3, #0
 8003ec4:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));

  /* Process locked */
  __HAL_LOCK(hadc);
 8003ec6:	3354      	adds	r3, #84	; 0x54
 8003ec8:	5cc3      	ldrb	r3, [r0, r3]
 8003eca:	2b01      	cmp	r3, #1
 8003ecc:	d100      	bne.n	8003ed0 <HAL_ADCEx_Calibration_Start+0x14>
 8003ece:	e086      	b.n	8003fde <HAL_ADCEx_Calibration_Start+0x122>
 8003ed0:	2601      	movs	r6, #1
 8003ed2:	2354      	movs	r3, #84	; 0x54
 8003ed4:	54c6      	strb	r6, [r0, r3]

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 8003ed6:	f7ff ffab 	bl	8003e30 <ADC_Disable>
 8003eda:	0005      	movs	r5, r0

  /* Check if ADC is effectively disabled */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
 8003edc:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003ede:	689a      	ldr	r2, [r3, #8]
 8003ee0:	0031      	movs	r1, r6
 8003ee2:	4011      	ands	r1, r2
 8003ee4:	4216      	tst	r6, r2
 8003ee6:	d009      	beq.n	8003efc <HAL_ADCEx_Calibration_Start+0x40>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003ee8:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003eea:	2210      	movs	r2, #16
 8003eec:	4313      	orrs	r3, r2
 8003eee:	65a3      	str	r3, [r4, #88]	; 0x58
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8003ef0:	2354      	movs	r3, #84	; 0x54
 8003ef2:	2200      	movs	r2, #0
 8003ef4:	54e2      	strb	r2, [r4, r3]

  /* Return function status */
  return tmp_hal_status;
}
 8003ef6:	0028      	movs	r0, r5
 8003ef8:	b003      	add	sp, #12
 8003efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    ADC_STATE_CLR_SET(hadc->State,
 8003efc:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8003efe:	4839      	ldr	r0, [pc, #228]	; (8003fe4 <HAL_ADCEx_Calibration_Start+0x128>)
 8003f00:	4002      	ands	r2, r0
 8003f02:	3006      	adds	r0, #6
 8003f04:	30ff      	adds	r0, #255	; 0xff
 8003f06:	4302      	orrs	r2, r0
 8003f08:	65a2      	str	r2, [r4, #88]	; 0x58
    backup_setting_adc_dma_transfer = READ_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8003f0a:	68de      	ldr	r6, [r3, #12]
 8003f0c:	3001      	adds	r0, #1
 8003f0e:	4006      	ands	r6, r0
    CLEAR_BIT(hadc->Instance->CFGR1, ADC_CFGR1_DMAEN | ADC_CFGR1_DMACFG);
 8003f10:	68da      	ldr	r2, [r3, #12]
 8003f12:	4382      	bics	r2, r0
 8003f14:	60da      	str	r2, [r3, #12]
  uint32_t calibration_factor_accumulated = 0;
 8003f16:	0008      	movs	r0, r1
    for (calibration_index = 0UL; calibration_index < 8UL; calibration_index++)
 8003f18:	e005      	b.n	8003f26 <HAL_ADCEx_Calibration_Start+0x6a>
  return (uint32_t)(READ_BIT(ADCx->CALFACT, ADC_CALFACT_CALFACT));
 8003f1a:	22b4      	movs	r2, #180	; 0xb4
 8003f1c:	589a      	ldr	r2, [r3, r2]
 8003f1e:	237f      	movs	r3, #127	; 0x7f
 8003f20:	4013      	ands	r3, r2
      calibration_factor_accumulated += LL_ADC_GetCalibrationFactor(hadc->Instance);
 8003f22:	18c0      	adds	r0, r0, r3
    for (calibration_index = 0UL; calibration_index < 8UL; calibration_index++)
 8003f24:	3101      	adds	r1, #1
 8003f26:	2907      	cmp	r1, #7
 8003f28:	d81e      	bhi.n	8003f68 <HAL_ADCEx_Calibration_Start+0xac>
      LL_ADC_StartCalibration(hadc->Instance);
 8003f2a:	6827      	ldr	r7, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8003f2c:	68bb      	ldr	r3, [r7, #8]
 8003f2e:	4a2e      	ldr	r2, [pc, #184]	; (8003fe8 <HAL_ADCEx_Calibration_Start+0x12c>)
 8003f30:	401a      	ands	r2, r3
 8003f32:	2380      	movs	r3, #128	; 0x80
 8003f34:	061b      	lsls	r3, r3, #24
 8003f36:	4313      	orrs	r3, r2
 8003f38:	60bb      	str	r3, [r7, #8]
      while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 8003f3a:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 8003f3c:	689a      	ldr	r2, [r3, #8]
 8003f3e:	2a00      	cmp	r2, #0
 8003f40:	daeb      	bge.n	8003f1a <HAL_ADCEx_Calibration_Start+0x5e>
        wait_loop_index++;
 8003f42:	9b01      	ldr	r3, [sp, #4]
 8003f44:	3301      	adds	r3, #1
 8003f46:	9301      	str	r3, [sp, #4]
        if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8003f48:	9a01      	ldr	r2, [sp, #4]
 8003f4a:	23ae      	movs	r3, #174	; 0xae
 8003f4c:	029b      	lsls	r3, r3, #10
 8003f4e:	429a      	cmp	r2, r3
 8003f50:	d3f3      	bcc.n	8003f3a <HAL_ADCEx_Calibration_Start+0x7e>
          ADC_STATE_CLR_SET(hadc->State,
 8003f52:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003f54:	2212      	movs	r2, #18
 8003f56:	4393      	bics	r3, r2
 8003f58:	3a02      	subs	r2, #2
 8003f5a:	4313      	orrs	r3, r2
 8003f5c:	65a3      	str	r3, [r4, #88]	; 0x58
          __HAL_UNLOCK(hadc);
 8003f5e:	2354      	movs	r3, #84	; 0x54
 8003f60:	2200      	movs	r2, #0
 8003f62:	54e2      	strb	r2, [r4, r3]
          return HAL_ERROR;
 8003f64:	2501      	movs	r5, #1
 8003f66:	e7c6      	b.n	8003ef6 <HAL_ADCEx_Calibration_Start+0x3a>
    calibration_factor_accumulated /= calibration_index;
 8003f68:	f7fc f8ce 	bl	8000108 <__udivsi3>
    LL_ADC_Enable(hadc->Instance);
 8003f6c:	6823      	ldr	r3, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8003f6e:	689a      	ldr	r2, [r3, #8]
 8003f70:	4f1d      	ldr	r7, [pc, #116]	; (8003fe8 <HAL_ADCEx_Calibration_Start+0x12c>)
 8003f72:	403a      	ands	r2, r7
 8003f74:	2101      	movs	r1, #1
 8003f76:	430a      	orrs	r2, r1
 8003f78:	609a      	str	r2, [r3, #8]
  MODIFY_REG(ADCx->CALFACT,
 8003f7a:	23b4      	movs	r3, #180	; 0xb4
 8003f7c:	6822      	ldr	r2, [r4, #0]
 8003f7e:	58d2      	ldr	r2, [r2, r3]
 8003f80:	317e      	adds	r1, #126	; 0x7e
 8003f82:	438a      	bics	r2, r1
 8003f84:	4310      	orrs	r0, r2
 8003f86:	6822      	ldr	r2, [r4, #0]
 8003f88:	50d0      	str	r0, [r2, r3]
    LL_ADC_Disable(hadc->Instance);
 8003f8a:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8003f8c:	6893      	ldr	r3, [r2, #8]
 8003f8e:	403b      	ands	r3, r7
 8003f90:	397d      	subs	r1, #125	; 0x7d
 8003f92:	430b      	orrs	r3, r1
 8003f94:	6093      	str	r3, [r2, #8]
    tickstart = HAL_GetTick();
 8003f96:	f7ff fbc5 	bl	8003724 <HAL_GetTick>
 8003f9a:	0007      	movs	r7, r0
    while (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8003f9c:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8003f9e:	689a      	ldr	r2, [r3, #8]
 8003fa0:	07d2      	lsls	r2, r2, #31
 8003fa2:	d409      	bmi.n	8003fb8 <HAL_ADCEx_Calibration_Start+0xfc>
    SET_BIT(hadc->Instance->CFGR1, backup_setting_adc_dma_transfer);
 8003fa4:	68da      	ldr	r2, [r3, #12]
 8003fa6:	4316      	orrs	r6, r2
 8003fa8:	60de      	str	r6, [r3, #12]
    ADC_STATE_CLR_SET(hadc->State,
 8003faa:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003fac:	2203      	movs	r2, #3
 8003fae:	4393      	bics	r3, r2
 8003fb0:	3a02      	subs	r2, #2
 8003fb2:	4313      	orrs	r3, r2
 8003fb4:	65a3      	str	r3, [r4, #88]	; 0x58
 8003fb6:	e79b      	b.n	8003ef0 <HAL_ADCEx_Calibration_Start+0x34>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8003fb8:	f7ff fbb4 	bl	8003724 <HAL_GetTick>
 8003fbc:	1bc0      	subs	r0, r0, r7
 8003fbe:	2802      	cmp	r0, #2
 8003fc0:	d9ec      	bls.n	8003f9c <HAL_ADCEx_Calibration_Start+0xe0>
        if (LL_ADC_IsEnabled(hadc->Instance) != 0UL)
 8003fc2:	6823      	ldr	r3, [r4, #0]
 8003fc4:	689b      	ldr	r3, [r3, #8]
 8003fc6:	07db      	lsls	r3, r3, #31
 8003fc8:	d5e8      	bpl.n	8003f9c <HAL_ADCEx_Calibration_Start+0xe0>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8003fca:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003fcc:	2210      	movs	r2, #16
 8003fce:	4313      	orrs	r3, r2
 8003fd0:	65a3      	str	r3, [r4, #88]	; 0x58
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8003fd2:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8003fd4:	3a0f      	subs	r2, #15
 8003fd6:	4313      	orrs	r3, r2
 8003fd8:	65e3      	str	r3, [r4, #92]	; 0x5c
          return HAL_ERROR;
 8003fda:	2501      	movs	r5, #1
 8003fdc:	e78b      	b.n	8003ef6 <HAL_ADCEx_Calibration_Start+0x3a>
  __HAL_LOCK(hadc);
 8003fde:	2502      	movs	r5, #2
 8003fe0:	e789      	b.n	8003ef6 <HAL_ADCEx_Calibration_Start+0x3a>
 8003fe2:	46c0      	nop			; (mov r8, r8)
 8003fe4:	fffffefd 	.word	0xfffffefd
 8003fe8:	7fffffe8 	.word	0x7fffffe8

08003fec <HAL_NVIC_SetPriority>:
  *         with stm32c0xx devices, this parameter is a dummy value and it is ignored, because
  *         no subpriority supported in Cortex M0+ based products.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8003fec:	b570      	push	{r4, r5, r6, lr}
  if ((int32_t)(IRQn) >= 0)
 8003fee:	2800      	cmp	r0, #0
 8003ff0:	db11      	blt.n	8004016 <HAL_NVIC_SetPriority+0x2a>
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003ff2:	0883      	lsrs	r3, r0, #2
 8003ff4:	4e13      	ldr	r6, [pc, #76]	; (8004044 <HAL_NVIC_SetPriority+0x58>)
 8003ff6:	33c0      	adds	r3, #192	; 0xc0
 8003ff8:	009b      	lsls	r3, r3, #2
 8003ffa:	599d      	ldr	r5, [r3, r6]
 8003ffc:	2403      	movs	r4, #3
 8003ffe:	4020      	ands	r0, r4
 8004000:	00c0      	lsls	r0, r0, #3
 8004002:	22ff      	movs	r2, #255	; 0xff
 8004004:	0014      	movs	r4, r2
 8004006:	4084      	lsls	r4, r0
 8004008:	43a5      	bics	r5, r4
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 800400a:	0189      	lsls	r1, r1, #6
 800400c:	400a      	ands	r2, r1
 800400e:	4082      	lsls	r2, r0
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004010:	432a      	orrs	r2, r5
 8004012:	519a      	str	r2, [r3, r6]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(SubPriority);
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn, PreemptPriority);
}
 8004014:	bd70      	pop	{r4, r5, r6, pc}
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004016:	230f      	movs	r3, #15
 8004018:	4003      	ands	r3, r0
 800401a:	3b08      	subs	r3, #8
 800401c:	089b      	lsrs	r3, r3, #2
 800401e:	3306      	adds	r3, #6
 8004020:	009b      	lsls	r3, r3, #2
 8004022:	4a09      	ldr	r2, [pc, #36]	; (8004048 <HAL_NVIC_SetPriority+0x5c>)
 8004024:	4694      	mov	ip, r2
 8004026:	4463      	add	r3, ip
 8004028:	685c      	ldr	r4, [r3, #4]
 800402a:	2203      	movs	r2, #3
 800402c:	4010      	ands	r0, r2
 800402e:	00c0      	lsls	r0, r0, #3
 8004030:	32fc      	adds	r2, #252	; 0xfc
 8004032:	0015      	movs	r5, r2
 8004034:	4085      	lsls	r5, r0
 8004036:	43ac      	bics	r4, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 8004038:	0189      	lsls	r1, r1, #6
 800403a:	400a      	ands	r2, r1
 800403c:	4082      	lsls	r2, r0
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800403e:	4322      	orrs	r2, r4
 8004040:	605a      	str	r2, [r3, #4]
 8004042:	e7e7      	b.n	8004014 <HAL_NVIC_SetPriority+0x28>
 8004044:	e000e100 	.word	0xe000e100
 8004048:	e000ed00 	.word	0xe000ed00

0800404c <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 800404c:	2800      	cmp	r0, #0
 800404e:	db05      	blt.n	800405c <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8004050:	231f      	movs	r3, #31
 8004052:	4018      	ands	r0, r3
 8004054:	3b1e      	subs	r3, #30
 8004056:	4083      	lsls	r3, r0
 8004058:	4a01      	ldr	r2, [pc, #4]	; (8004060 <HAL_NVIC_EnableIRQ+0x14>)
 800405a:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800405c:	4770      	bx	lr
 800405e:	46c0      	nop			; (mov r8, r8)
 8004060:	e000e100 	.word	0xe000e100

08004064 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8004064:	2800      	cmp	r0, #0
 8004066:	db0a      	blt.n	800407e <HAL_NVIC_DisableIRQ+0x1a>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8004068:	231f      	movs	r3, #31
 800406a:	4018      	ands	r0, r3
 800406c:	3b1e      	subs	r3, #30
 800406e:	4083      	lsls	r3, r0
 8004070:	4903      	ldr	r1, [pc, #12]	; (8004080 <HAL_NVIC_DisableIRQ+0x1c>)
 8004072:	2280      	movs	r2, #128	; 0x80
 8004074:	508b      	str	r3, [r1, r2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8004076:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800407a:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 800407e:	4770      	bx	lr
 8004080:	e000e100 	.word	0xe000e100

08004084 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8004084:	3801      	subs	r0, #1
 8004086:	2380      	movs	r3, #128	; 0x80
 8004088:	045b      	lsls	r3, r3, #17
 800408a:	4298      	cmp	r0, r3
 800408c:	d20f      	bcs.n	80040ae <HAL_SYSTICK_Config+0x2a>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800408e:	4a09      	ldr	r2, [pc, #36]	; (80040b4 <HAL_SYSTICK_Config+0x30>)
 8004090:	6050      	str	r0, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8004092:	4809      	ldr	r0, [pc, #36]	; (80040b8 <HAL_SYSTICK_Config+0x34>)
 8004094:	6a03      	ldr	r3, [r0, #32]
 8004096:	021b      	lsls	r3, r3, #8
 8004098:	0a1b      	lsrs	r3, r3, #8
 800409a:	21c0      	movs	r1, #192	; 0xc0
 800409c:	0609      	lsls	r1, r1, #24
 800409e:	430b      	orrs	r3, r1
 80040a0:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80040a2:	2300      	movs	r3, #0
 80040a4:	6093      	str	r3, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80040a6:	3307      	adds	r3, #7
 80040a8:	6013      	str	r3, [r2, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80040aa:	2000      	movs	r0, #0
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
  return SysTick_Config(TicksNumb);
}
 80040ac:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80040ae:	2001      	movs	r0, #1
  return SysTick_Config(TicksNumb);
 80040b0:	e7fc      	b.n	80040ac <HAL_SYSTICK_Config+0x28>
 80040b2:	46c0      	nop			; (mov r8, r8)
 80040b4:	e000e010 	.word	0xe000e010
 80040b8:	e000ed00 	.word	0xe000ed00

080040bc <HAL_GPIO_Init>:
  * @param  pGPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *pGPIO_Init)
{
 80040bc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80040be:	46d6      	mov	lr, sl
 80040c0:	464f      	mov	r7, r9
 80040c2:	4646      	mov	r6, r8
 80040c4:	b5c0      	push	{r6, r7, lr}
  uint32_t tmp;
  uint32_t iocurrent;
  uint32_t position = 0U;
 80040c6:	2300      	movs	r3, #0
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(pGPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(pGPIO_Init->Mode));

  /* Configure the port pins */
  while (((pGPIO_Init->Pin) >> position) != 0U)
 80040c8:	e03b      	b.n	8004142 <HAL_GPIO_Init+0x86>
      /* Configure the External Interrupt or event for the current IO */
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        tmp = EXTI->EXTICR[position >> 2U];
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 80040ca:	2504      	movs	r5, #4
 80040cc:	e000      	b.n	80040d0 <HAL_GPIO_Init+0x14>
 80040ce:	2500      	movs	r5, #0
 80040d0:	40a5      	lsls	r5, r4
 80040d2:	002c      	movs	r4, r5
 80040d4:	433c      	orrs	r4, r7
        EXTI->EXTICR[position >> 2U] = tmp;
 80040d6:	4d63      	ldr	r5, [pc, #396]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 80040d8:	3218      	adds	r2, #24
 80040da:	0092      	lsls	r2, r2, #2
 80040dc:	5154      	str	r4, [r2, r5]

        /* Clear EXTI line configuration */
        tmp = EXTI->IMR1;
 80040de:	2280      	movs	r2, #128	; 0x80
 80040e0:	58ac      	ldr	r4, [r5, r2]
        tmp &= ~((uint32_t)iocurrent);
 80040e2:	464a      	mov	r2, r9
 80040e4:	43d2      	mvns	r2, r2
 80040e6:	0025      	movs	r5, r4
 80040e8:	464e      	mov	r6, r9
 80040ea:	43b5      	bics	r5, r6
        if ((pGPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80040ec:	684e      	ldr	r6, [r1, #4]
 80040ee:	03f6      	lsls	r6, r6, #15
 80040f0:	d502      	bpl.n	80040f8 <HAL_GPIO_Init+0x3c>
        {
          tmp |= iocurrent;
 80040f2:	464d      	mov	r5, r9
 80040f4:	432c      	orrs	r4, r5
 80040f6:	0025      	movs	r5, r4
        }
        EXTI->IMR1 = tmp;
 80040f8:	4c5a      	ldr	r4, [pc, #360]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 80040fa:	2780      	movs	r7, #128	; 0x80
 80040fc:	51e5      	str	r5, [r4, r7]

        tmp = EXTI->EMR1;
 80040fe:	2584      	movs	r5, #132	; 0x84
 8004100:	5964      	ldr	r4, [r4, r5]
        tmp &= ~((uint32_t)iocurrent);
 8004102:	0025      	movs	r5, r4
 8004104:	4015      	ands	r5, r2
        if ((pGPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8004106:	684e      	ldr	r6, [r1, #4]
 8004108:	03b6      	lsls	r6, r6, #14
 800410a:	d502      	bpl.n	8004112 <HAL_GPIO_Init+0x56>
        {
          tmp |= iocurrent;
 800410c:	464d      	mov	r5, r9
 800410e:	432c      	orrs	r4, r5
 8004110:	0025      	movs	r5, r4
        }
        EXTI->EMR1 = tmp;
 8004112:	4c54      	ldr	r4, [pc, #336]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 8004114:	2784      	movs	r7, #132	; 0x84
 8004116:	51e5      	str	r5, [r4, r7]

        /* Clear Rising Falling edge configuration */
        tmp = EXTI->RTSR1;
 8004118:	6824      	ldr	r4, [r4, #0]
        tmp &= ~((uint32_t)iocurrent);
 800411a:	0025      	movs	r5, r4
 800411c:	4015      	ands	r5, r2
        if ((pGPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800411e:	684e      	ldr	r6, [r1, #4]
 8004120:	02f6      	lsls	r6, r6, #11
 8004122:	d502      	bpl.n	800412a <HAL_GPIO_Init+0x6e>
        {
          tmp |= iocurrent;
 8004124:	464d      	mov	r5, r9
 8004126:	432c      	orrs	r4, r5
 8004128:	0025      	movs	r5, r4
        }
        EXTI->RTSR1 = tmp;
 800412a:	4c4e      	ldr	r4, [pc, #312]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 800412c:	6025      	str	r5, [r4, #0]

        tmp = EXTI->FTSR1;
 800412e:	6864      	ldr	r4, [r4, #4]
        tmp &= ~((uint32_t)iocurrent);
 8004130:	4022      	ands	r2, r4
        if ((pGPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8004132:	684d      	ldr	r5, [r1, #4]
 8004134:	02ad      	lsls	r5, r5, #10
 8004136:	d501      	bpl.n	800413c <HAL_GPIO_Init+0x80>
        {
          tmp |= iocurrent;
 8004138:	464a      	mov	r2, r9
 800413a:	4322      	orrs	r2, r4
        }
        EXTI->FTSR1 = tmp;
 800413c:	4c49      	ldr	r4, [pc, #292]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 800413e:	6062      	str	r2, [r4, #4]
      }
    }

    position++;
 8004140:	3301      	adds	r3, #1
  while (((pGPIO_Init->Pin) >> position) != 0U)
 8004142:	680c      	ldr	r4, [r1, #0]
 8004144:	0022      	movs	r2, r4
 8004146:	40da      	lsrs	r2, r3
 8004148:	d100      	bne.n	800414c <HAL_GPIO_Init+0x90>
 800414a:	e086      	b.n	800425a <HAL_GPIO_Init+0x19e>
    iocurrent = (pGPIO_Init->Pin) & (1UL << position);
 800414c:	2201      	movs	r2, #1
 800414e:	409a      	lsls	r2, r3
 8004150:	0026      	movs	r6, r4
 8004152:	4016      	ands	r6, r2
 8004154:	46b1      	mov	r9, r6
    if (iocurrent != 0U)
 8004156:	4214      	tst	r4, r2
 8004158:	d0f2      	beq.n	8004140 <HAL_GPIO_Init+0x84>
      if ((pGPIO_Init->Mode == GPIO_MODE_AF_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 800415a:	684c      	ldr	r4, [r1, #4]
 800415c:	2c02      	cmp	r4, #2
 800415e:	d001      	beq.n	8004164 <HAL_GPIO_Init+0xa8>
 8004160:	2c12      	cmp	r4, #18
 8004162:	d118      	bne.n	8004196 <HAL_GPIO_Init+0xda>
        tmp = GPIOx->AFR[position >> 3U];
 8004164:	08dd      	lsrs	r5, r3, #3
 8004166:	3508      	adds	r5, #8
 8004168:	00ad      	lsls	r5, r5, #2
 800416a:	582c      	ldr	r4, [r5, r0]
 800416c:	46a4      	mov	ip, r4
        tmp &= ~(0xFUL << ((position & 0x07U) * 4U)) ;
 800416e:	2707      	movs	r7, #7
 8004170:	401f      	ands	r7, r3
 8004172:	00bf      	lsls	r7, r7, #2
 8004174:	240f      	movs	r4, #15
 8004176:	46a2      	mov	sl, r4
 8004178:	0026      	movs	r6, r4
 800417a:	40be      	lsls	r6, r7
 800417c:	46b0      	mov	r8, r6
 800417e:	4666      	mov	r6, ip
 8004180:	4644      	mov	r4, r8
 8004182:	43a6      	bics	r6, r4
 8004184:	46b4      	mov	ip, r6
        tmp |= ((pGPIO_Init->Alternate & 0x0FUL) << ((position & 0x07U) * 4U));
 8004186:	690c      	ldr	r4, [r1, #16]
 8004188:	4656      	mov	r6, sl
 800418a:	4026      	ands	r6, r4
 800418c:	0034      	movs	r4, r6
 800418e:	40bc      	lsls	r4, r7
 8004190:	4666      	mov	r6, ip
 8004192:	4334      	orrs	r4, r6
        GPIOx->AFR[position >> 3U] = tmp;
 8004194:	502c      	str	r4, [r5, r0]
      tmp = GPIOx->MODER;
 8004196:	6804      	ldr	r4, [r0, #0]
 8004198:	46a4      	mov	ip, r4
      tmp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800419a:	005d      	lsls	r5, r3, #1
 800419c:	2403      	movs	r4, #3
 800419e:	46a2      	mov	sl, r4
 80041a0:	0027      	movs	r7, r4
 80041a2:	40af      	lsls	r7, r5
 80041a4:	46b8      	mov	r8, r7
 80041a6:	43ff      	mvns	r7, r7
 80041a8:	4666      	mov	r6, ip
 80041aa:	4644      	mov	r4, r8
 80041ac:	43a6      	bics	r6, r4
 80041ae:	46b4      	mov	ip, r6
      tmp |= ((pGPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 80041b0:	684c      	ldr	r4, [r1, #4]
 80041b2:	4656      	mov	r6, sl
 80041b4:	4026      	ands	r6, r4
 80041b6:	0034      	movs	r4, r6
 80041b8:	40ac      	lsls	r4, r5
 80041ba:	4666      	mov	r6, ip
 80041bc:	4334      	orrs	r4, r6
      GPIOx->MODER = tmp;
 80041be:	6004      	str	r4, [r0, #0]
      if ((pGPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (pGPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80041c0:	684c      	ldr	r4, [r1, #4]
 80041c2:	1e66      	subs	r6, r4, #1
 80041c4:	2e01      	cmp	r6, #1
 80041c6:	d903      	bls.n	80041d0 <HAL_GPIO_Init+0x114>
 80041c8:	2c11      	cmp	r4, #17
 80041ca:	d001      	beq.n	80041d0 <HAL_GPIO_Init+0x114>
          (pGPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (pGPIO_Init->Mode == GPIO_MODE_AF_OD))
 80041cc:	2c12      	cmp	r4, #18
 80041ce:	d112      	bne.n	80041f6 <HAL_GPIO_Init+0x13a>
        tmp = GPIOx->OSPEEDR;
 80041d0:	6884      	ldr	r4, [r0, #8]
        tmp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80041d2:	403c      	ands	r4, r7
 80041d4:	46a4      	mov	ip, r4
        tmp |= (pGPIO_Init->Speed << (position * 2U));
 80041d6:	68cc      	ldr	r4, [r1, #12]
 80041d8:	40ac      	lsls	r4, r5
 80041da:	4666      	mov	r6, ip
 80041dc:	4334      	orrs	r4, r6
        GPIOx->OSPEEDR = tmp;
 80041de:	6084      	str	r4, [r0, #8]
        tmp = GPIOx->OTYPER;
 80041e0:	6844      	ldr	r4, [r0, #4]
        tmp &= ~(GPIO_OTYPER_OT0 << position) ;
 80041e2:	4394      	bics	r4, r2
        tmp |= (((pGPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80041e4:	684a      	ldr	r2, [r1, #4]
 80041e6:	0912      	lsrs	r2, r2, #4
 80041e8:	4694      	mov	ip, r2
 80041ea:	2201      	movs	r2, #1
 80041ec:	4666      	mov	r6, ip
 80041ee:	4032      	ands	r2, r6
 80041f0:	409a      	lsls	r2, r3
 80041f2:	4322      	orrs	r2, r4
        GPIOx->OTYPER = tmp;
 80041f4:	6042      	str	r2, [r0, #4]
      if (pGPIO_Init->Mode != GPIO_MODE_ANALOG)
 80041f6:	684a      	ldr	r2, [r1, #4]
 80041f8:	2a03      	cmp	r2, #3
 80041fa:	d005      	beq.n	8004208 <HAL_GPIO_Init+0x14c>
        tmp = GPIOx->PUPDR;
 80041fc:	68c2      	ldr	r2, [r0, #12]
        tmp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 80041fe:	403a      	ands	r2, r7
        tmp |= ((pGPIO_Init->Pull) << (position * 2U));
 8004200:	688f      	ldr	r7, [r1, #8]
 8004202:	40af      	lsls	r7, r5
 8004204:	4317      	orrs	r7, r2
        GPIOx->PUPDR = tmp;
 8004206:	60c7      	str	r7, [r0, #12]
      if ((pGPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8004208:	684a      	ldr	r2, [r1, #4]
 800420a:	00d2      	lsls	r2, r2, #3
 800420c:	d598      	bpl.n	8004140 <HAL_GPIO_Init+0x84>
        tmp = EXTI->EXTICR[position >> 2U];
 800420e:	089a      	lsrs	r2, r3, #2
 8004210:	0014      	movs	r4, r2
 8004212:	3418      	adds	r4, #24
 8004214:	00a4      	lsls	r4, r4, #2
 8004216:	4d13      	ldr	r5, [pc, #76]	; (8004264 <HAL_GPIO_Init+0x1a8>)
 8004218:	5967      	ldr	r7, [r4, r5]
        tmp &= ~((0x0FUL) << (8U * (position & 0x03U)));
 800421a:	2503      	movs	r5, #3
 800421c:	401d      	ands	r5, r3
 800421e:	00ec      	lsls	r4, r5, #3
 8004220:	250f      	movs	r5, #15
 8004222:	40a5      	lsls	r5, r4
 8004224:	43af      	bics	r7, r5
        tmp |= (GPIO_GET_INDEX(GPIOx) << (8U * (position & 0x03U)));
 8004226:	25a0      	movs	r5, #160	; 0xa0
 8004228:	05ed      	lsls	r5, r5, #23
 800422a:	42a8      	cmp	r0, r5
 800422c:	d100      	bne.n	8004230 <HAL_GPIO_Init+0x174>
 800422e:	e74e      	b.n	80040ce <HAL_GPIO_Init+0x12>
 8004230:	4d0d      	ldr	r5, [pc, #52]	; (8004268 <HAL_GPIO_Init+0x1ac>)
 8004232:	42a8      	cmp	r0, r5
 8004234:	d00b      	beq.n	800424e <HAL_GPIO_Init+0x192>
 8004236:	4d0d      	ldr	r5, [pc, #52]	; (800426c <HAL_GPIO_Init+0x1b0>)
 8004238:	42a8      	cmp	r0, r5
 800423a:	d00a      	beq.n	8004252 <HAL_GPIO_Init+0x196>
 800423c:	4d0c      	ldr	r5, [pc, #48]	; (8004270 <HAL_GPIO_Init+0x1b4>)
 800423e:	42a8      	cmp	r0, r5
 8004240:	d009      	beq.n	8004256 <HAL_GPIO_Init+0x19a>
 8004242:	4d0c      	ldr	r5, [pc, #48]	; (8004274 <HAL_GPIO_Init+0x1b8>)
 8004244:	42a8      	cmp	r0, r5
 8004246:	d100      	bne.n	800424a <HAL_GPIO_Init+0x18e>
 8004248:	e73f      	b.n	80040ca <HAL_GPIO_Init+0xe>
 800424a:	2505      	movs	r5, #5
 800424c:	e740      	b.n	80040d0 <HAL_GPIO_Init+0x14>
 800424e:	2501      	movs	r5, #1
 8004250:	e73e      	b.n	80040d0 <HAL_GPIO_Init+0x14>
 8004252:	2502      	movs	r5, #2
 8004254:	e73c      	b.n	80040d0 <HAL_GPIO_Init+0x14>
 8004256:	2503      	movs	r5, #3
 8004258:	e73a      	b.n	80040d0 <HAL_GPIO_Init+0x14>
  }
}
 800425a:	bce0      	pop	{r5, r6, r7}
 800425c:	46ba      	mov	sl, r7
 800425e:	46b1      	mov	r9, r6
 8004260:	46a8      	mov	r8, r5
 8004262:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004264:	40021800 	.word	0x40021800
 8004268:	50000400 	.word	0x50000400
 800426c:	50000800 	.word	0x50000800
 8004270:	50000c00 	.word	0x50000c00
 8004274:	50001400 	.word	0x50001400

08004278 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8004278:	2a00      	cmp	r2, #0
 800427a:	d001      	beq.n	8004280 <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 800427c:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 800427e:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8004280:	6281      	str	r1, [r0, #40]	; 0x28
}
 8004282:	e7fc      	b.n	800427e <HAL_GPIO_WritePin+0x6>

08004284 <HAL_GPIO_EXTI_Rising_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Rising_Callback could be implemented in the user file
   */
}
 8004284:	4770      	bx	lr

08004286 <HAL_GPIO_EXTI_Falling_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Falling_Callback could be implemented in the user file
   */
}
 8004286:	4770      	bx	lr

08004288 <HAL_GPIO_EXTI_IRQHandler>:
{
 8004288:	b510      	push	{r4, lr}
 800428a:	0004      	movs	r4, r0
  if (__HAL_GPIO_EXTI_GET_RISING_IT(GPIO_Pin) != 0U)
 800428c:	4b09      	ldr	r3, [pc, #36]	; (80042b4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 800428e:	68db      	ldr	r3, [r3, #12]
 8004290:	4218      	tst	r0, r3
 8004292:	d104      	bne.n	800429e <HAL_GPIO_EXTI_IRQHandler+0x16>
  if (__HAL_GPIO_EXTI_GET_FALLING_IT(GPIO_Pin) != 0U)
 8004294:	4b07      	ldr	r3, [pc, #28]	; (80042b4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8004296:	691b      	ldr	r3, [r3, #16]
 8004298:	4223      	tst	r3, r4
 800429a:	d105      	bne.n	80042a8 <HAL_GPIO_EXTI_IRQHandler+0x20>
}
 800429c:	bd10      	pop	{r4, pc}
    __HAL_GPIO_EXTI_CLEAR_RISING_IT(GPIO_Pin);
 800429e:	4b05      	ldr	r3, [pc, #20]	; (80042b4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 80042a0:	60d8      	str	r0, [r3, #12]
    HAL_GPIO_EXTI_Rising_Callback(GPIO_Pin);
 80042a2:	f7ff ffef 	bl	8004284 <HAL_GPIO_EXTI_Rising_Callback>
 80042a6:	e7f5      	b.n	8004294 <HAL_GPIO_EXTI_IRQHandler+0xc>
    __HAL_GPIO_EXTI_CLEAR_FALLING_IT(GPIO_Pin);
 80042a8:	4b02      	ldr	r3, [pc, #8]	; (80042b4 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 80042aa:	611c      	str	r4, [r3, #16]
    HAL_GPIO_EXTI_Falling_Callback(GPIO_Pin);
 80042ac:	0020      	movs	r0, r4
 80042ae:	f7ff ffea 	bl	8004286 <HAL_GPIO_EXTI_Falling_Callback>
}
 80042b2:	e7f3      	b.n	800429c <HAL_GPIO_EXTI_IRQHandler+0x14>
 80042b4:	40021800 	.word	0x40021800

080042b8 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to LSE Off
  *         first and then to LSE On or LSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80042b8:	b570      	push	{r4, r5, r6, lr}
 80042ba:	1e04      	subs	r4, r0, #0
  uint32_t tickstart;
  uint32_t temp_sysclksrc;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 80042bc:	d100      	bne.n	80042c0 <HAL_RCC_OscConfig+0x8>
 80042be:	e149      	b.n	8004554 <HAL_RCC_OscConfig+0x29c>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80042c0:	6803      	ldr	r3, [r0, #0]
 80042c2:	07db      	lsls	r3, r3, #31
 80042c4:	d530      	bpl.n	8004328 <HAL_RCC_OscConfig+0x70>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80042c6:	4bab      	ldr	r3, [pc, #684]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80042c8:	689a      	ldr	r2, [r3, #8]
 80042ca:	2338      	movs	r3, #56	; 0x38
 80042cc:	4013      	ands	r3, r2

    /* When the HSE is used as system clock in these cases it is not allowed to be disabled */
    if (temp_sysclksrc == RCC_CFGR_SWS_HSE)
 80042ce:	2b08      	cmp	r3, #8
 80042d0:	d022      	beq.n	8004318 <HAL_RCC_OscConfig+0x60>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80042d2:	6843      	ldr	r3, [r0, #4]
 80042d4:	2280      	movs	r2, #128	; 0x80
 80042d6:	0252      	lsls	r2, r2, #9
 80042d8:	4293      	cmp	r3, r2
 80042da:	d072      	beq.n	80043c2 <HAL_RCC_OscConfig+0x10a>
 80042dc:	22a0      	movs	r2, #160	; 0xa0
 80042de:	02d2      	lsls	r2, r2, #11
 80042e0:	4293      	cmp	r3, r2
 80042e2:	d075      	beq.n	80043d0 <HAL_RCC_OscConfig+0x118>
 80042e4:	4ba3      	ldr	r3, [pc, #652]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80042e6:	681a      	ldr	r2, [r3, #0]
 80042e8:	49a3      	ldr	r1, [pc, #652]	; (8004578 <HAL_RCC_OscConfig+0x2c0>)
 80042ea:	400a      	ands	r2, r1
 80042ec:	601a      	str	r2, [r3, #0]
 80042ee:	681a      	ldr	r2, [r3, #0]
 80042f0:	49a2      	ldr	r1, [pc, #648]	; (800457c <HAL_RCC_OscConfig+0x2c4>)
 80042f2:	400a      	ands	r2, r1
 80042f4:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 80042f6:	6863      	ldr	r3, [r4, #4]
 80042f8:	2b00      	cmp	r3, #0
 80042fa:	d075      	beq.n	80043e8 <HAL_RCC_OscConfig+0x130>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80042fc:	f7ff fa12 	bl	8003724 <HAL_GetTick>
 8004300:	0005      	movs	r5, r0

        /* Wait till HSE is ready */
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8004302:	4b9c      	ldr	r3, [pc, #624]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004304:	681b      	ldr	r3, [r3, #0]
 8004306:	039b      	lsls	r3, r3, #14
 8004308:	d40e      	bmi.n	8004328 <HAL_RCC_OscConfig+0x70>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800430a:	f7ff fa0b 	bl	8003724 <HAL_GetTick>
 800430e:	1b40      	subs	r0, r0, r5
 8004310:	2864      	cmp	r0, #100	; 0x64
 8004312:	d9f6      	bls.n	8004302 <HAL_RCC_OscConfig+0x4a>
          {
            return HAL_TIMEOUT;
 8004314:	2003      	movs	r0, #3
 8004316:	e128      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8004318:	4b96      	ldr	r3, [pc, #600]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800431a:	681b      	ldr	r3, [r3, #0]
 800431c:	039b      	lsls	r3, r3, #14
 800431e:	d503      	bpl.n	8004328 <HAL_RCC_OscConfig+0x70>
 8004320:	6843      	ldr	r3, [r0, #4]
 8004322:	2b00      	cmp	r3, #0
 8004324:	d100      	bne.n	8004328 <HAL_RCC_OscConfig+0x70>
 8004326:	e117      	b.n	8004558 <HAL_RCC_OscConfig+0x2a0>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8004328:	6823      	ldr	r3, [r4, #0]
 800432a:	079b      	lsls	r3, r3, #30
 800432c:	d529      	bpl.n	8004382 <HAL_RCC_OscConfig+0xca>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    assert_param(IS_RCC_HSIDIV(RCC_OscInitStruct->HSIDiv));

    /* Check if HSI48 is used as system clock  */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800432e:	4b91      	ldr	r3, [pc, #580]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004330:	689b      	ldr	r3, [r3, #8]
 8004332:	2238      	movs	r2, #56	; 0x38

    if (temp_sysclksrc == RCC_CFGR_SWS_HSI)
 8004334:	421a      	tst	r2, r3
 8004336:	d165      	bne.n	8004404 <HAL_RCC_OscConfig+0x14c>
    {
      /* When HSI is used as system clock it can not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8004338:	4b8e      	ldr	r3, [pc, #568]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800433a:	681b      	ldr	r3, [r3, #0]
 800433c:	055b      	lsls	r3, r3, #21
 800433e:	d503      	bpl.n	8004348 <HAL_RCC_OscConfig+0x90>
 8004340:	68e3      	ldr	r3, [r4, #12]
 8004342:	2b00      	cmp	r3, #0
 8004344:	d100      	bne.n	8004348 <HAL_RCC_OscConfig+0x90>
 8004346:	e109      	b.n	800455c <HAL_RCC_OscConfig+0x2a4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8004348:	4b8a      	ldr	r3, [pc, #552]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800434a:	685a      	ldr	r2, [r3, #4]
 800434c:	498c      	ldr	r1, [pc, #560]	; (8004580 <HAL_RCC_OscConfig+0x2c8>)
 800434e:	400a      	ands	r2, r1
 8004350:	6961      	ldr	r1, [r4, #20]
 8004352:	0209      	lsls	r1, r1, #8
 8004354:	430a      	orrs	r2, r1
 8004356:	605a      	str	r2, [r3, #4]

        if (temp_sysclksrc == RCC_CFGR_SWS_HSI)
        {
          /* Adjust the HSI48 division factor */
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 8004358:	681a      	ldr	r2, [r3, #0]
 800435a:	498a      	ldr	r1, [pc, #552]	; (8004584 <HAL_RCC_OscConfig+0x2cc>)
 800435c:	400a      	ands	r2, r1
 800435e:	6921      	ldr	r1, [r4, #16]
 8004360:	430a      	orrs	r2, r1
 8004362:	601a      	str	r2, [r3, #0]

          /* Update the SystemCoreClock global variable with HSISYS value  */
          SystemCoreClock = (HSI_VALUE / (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos)));
 8004364:	681b      	ldr	r3, [r3, #0]
 8004366:	0adb      	lsrs	r3, r3, #11
 8004368:	2207      	movs	r2, #7
 800436a:	401a      	ands	r2, r3
 800436c:	4b86      	ldr	r3, [pc, #536]	; (8004588 <HAL_RCC_OscConfig+0x2d0>)
 800436e:	40d3      	lsrs	r3, r2
 8004370:	4a86      	ldr	r2, [pc, #536]	; (800458c <HAL_RCC_OscConfig+0x2d4>)
 8004372:	6013      	str	r3, [r2, #0]
        }

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8004374:	4b86      	ldr	r3, [pc, #536]	; (8004590 <HAL_RCC_OscConfig+0x2d8>)
 8004376:	6818      	ldr	r0, [r3, #0]
 8004378:	f7ff f990 	bl	800369c <HAL_InitTick>
 800437c:	2800      	cmp	r0, #0
 800437e:	d000      	beq.n	8004382 <HAL_RCC_OscConfig+0xca>
 8004380:	e0ee      	b.n	8004560 <HAL_RCC_OscConfig+0x2a8>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004382:	6823      	ldr	r3, [r4, #0]
 8004384:	071b      	lsls	r3, r3, #28
 8004386:	d57d      	bpl.n	8004484 <HAL_RCC_OscConfig+0x1cc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check if LSI is used as system clock */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 8004388:	4b7a      	ldr	r3, [pc, #488]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800438a:	689a      	ldr	r2, [r3, #8]
 800438c:	2338      	movs	r3, #56	; 0x38
 800438e:	4013      	ands	r3, r2
 8004390:	2b18      	cmp	r3, #24
 8004392:	d070      	beq.n	8004476 <HAL_RCC_OscConfig+0x1be>
      }
    }
    else
    {
      /* Check the LSI State */
      if (RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8004394:	69a3      	ldr	r3, [r4, #24]
 8004396:	2b00      	cmp	r3, #0
 8004398:	d100      	bne.n	800439c <HAL_RCC_OscConfig+0xe4>
 800439a:	e09c      	b.n	80044d6 <HAL_RCC_OscConfig+0x21e>
      {
        /* Enable the Internal Low Speed oscillator (LSI). */
        __HAL_RCC_LSI_ENABLE();
 800439c:	4a75      	ldr	r2, [pc, #468]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800439e:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80043a0:	2101      	movs	r1, #1
 80043a2:	430b      	orrs	r3, r1
 80043a4:	6613      	str	r3, [r2, #96]	; 0x60

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80043a6:	f7ff f9bd 	bl	8003724 <HAL_GetTick>
 80043aa:	0005      	movs	r5, r0

        /* Wait till LSI is ready */
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) == 0U)
 80043ac:	4b71      	ldr	r3, [pc, #452]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80043ae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80043b0:	079b      	lsls	r3, r3, #30
 80043b2:	d467      	bmi.n	8004484 <HAL_RCC_OscConfig+0x1cc>
        {
          if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80043b4:	f7ff f9b6 	bl	8003724 <HAL_GetTick>
 80043b8:	1b40      	subs	r0, r0, r5
 80043ba:	2802      	cmp	r0, #2
 80043bc:	d9f6      	bls.n	80043ac <HAL_RCC_OscConfig+0xf4>
          {
            return HAL_TIMEOUT;
 80043be:	2003      	movs	r0, #3
 80043c0:	e0d3      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80043c2:	4a6c      	ldr	r2, [pc, #432]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80043c4:	6811      	ldr	r1, [r2, #0]
 80043c6:	2380      	movs	r3, #128	; 0x80
 80043c8:	025b      	lsls	r3, r3, #9
 80043ca:	430b      	orrs	r3, r1
 80043cc:	6013      	str	r3, [r2, #0]
 80043ce:	e792      	b.n	80042f6 <HAL_RCC_OscConfig+0x3e>
 80043d0:	4b68      	ldr	r3, [pc, #416]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80043d2:	6819      	ldr	r1, [r3, #0]
 80043d4:	2280      	movs	r2, #128	; 0x80
 80043d6:	02d2      	lsls	r2, r2, #11
 80043d8:	430a      	orrs	r2, r1
 80043da:	601a      	str	r2, [r3, #0]
 80043dc:	6819      	ldr	r1, [r3, #0]
 80043de:	2280      	movs	r2, #128	; 0x80
 80043e0:	0252      	lsls	r2, r2, #9
 80043e2:	430a      	orrs	r2, r1
 80043e4:	601a      	str	r2, [r3, #0]
 80043e6:	e786      	b.n	80042f6 <HAL_RCC_OscConfig+0x3e>
        tickstart = HAL_GetTick();
 80043e8:	f7ff f99c 	bl	8003724 <HAL_GetTick>
 80043ec:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 80043ee:	4b61      	ldr	r3, [pc, #388]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80043f0:	681b      	ldr	r3, [r3, #0]
 80043f2:	039b      	lsls	r3, r3, #14
 80043f4:	d598      	bpl.n	8004328 <HAL_RCC_OscConfig+0x70>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 80043f6:	f7ff f995 	bl	8003724 <HAL_GetTick>
 80043fa:	1b40      	subs	r0, r0, r5
 80043fc:	2864      	cmp	r0, #100	; 0x64
 80043fe:	d9f6      	bls.n	80043ee <HAL_RCC_OscConfig+0x136>
            return HAL_TIMEOUT;
 8004400:	2003      	movs	r0, #3
 8004402:	e0b2      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8004404:	68e3      	ldr	r3, [r4, #12]
 8004406:	2b00      	cmp	r3, #0
 8004408:	d022      	beq.n	8004450 <HAL_RCC_OscConfig+0x198>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIDiv);
 800440a:	4a5a      	ldr	r2, [pc, #360]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800440c:	6813      	ldr	r3, [r2, #0]
 800440e:	495d      	ldr	r1, [pc, #372]	; (8004584 <HAL_RCC_OscConfig+0x2cc>)
 8004410:	400b      	ands	r3, r1
 8004412:	6921      	ldr	r1, [r4, #16]
 8004414:	430b      	orrs	r3, r1
 8004416:	6013      	str	r3, [r2, #0]
        __HAL_RCC_HSI_ENABLE();
 8004418:	6811      	ldr	r1, [r2, #0]
 800441a:	2380      	movs	r3, #128	; 0x80
 800441c:	005b      	lsls	r3, r3, #1
 800441e:	430b      	orrs	r3, r1
 8004420:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8004422:	f7ff f97f 	bl	8003724 <HAL_GetTick>
 8004426:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8004428:	4b52      	ldr	r3, [pc, #328]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800442a:	681b      	ldr	r3, [r3, #0]
 800442c:	055b      	lsls	r3, r3, #21
 800442e:	d406      	bmi.n	800443e <HAL_RCC_OscConfig+0x186>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004430:	f7ff f978 	bl	8003724 <HAL_GetTick>
 8004434:	1b40      	subs	r0, r0, r5
 8004436:	2802      	cmp	r0, #2
 8004438:	d9f6      	bls.n	8004428 <HAL_RCC_OscConfig+0x170>
            return HAL_TIMEOUT;
 800443a:	2003      	movs	r0, #3
 800443c:	e095      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800443e:	494d      	ldr	r1, [pc, #308]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004440:	684b      	ldr	r3, [r1, #4]
 8004442:	4a4f      	ldr	r2, [pc, #316]	; (8004580 <HAL_RCC_OscConfig+0x2c8>)
 8004444:	4013      	ands	r3, r2
 8004446:	6962      	ldr	r2, [r4, #20]
 8004448:	0212      	lsls	r2, r2, #8
 800444a:	4313      	orrs	r3, r2
 800444c:	604b      	str	r3, [r1, #4]
 800444e:	e798      	b.n	8004382 <HAL_RCC_OscConfig+0xca>
        __HAL_RCC_HSI_DISABLE();
 8004450:	4a48      	ldr	r2, [pc, #288]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004452:	6813      	ldr	r3, [r2, #0]
 8004454:	494f      	ldr	r1, [pc, #316]	; (8004594 <HAL_RCC_OscConfig+0x2dc>)
 8004456:	400b      	ands	r3, r1
 8004458:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 800445a:	f7ff f963 	bl	8003724 <HAL_GetTick>
 800445e:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8004460:	4b44      	ldr	r3, [pc, #272]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004462:	681b      	ldr	r3, [r3, #0]
 8004464:	055b      	lsls	r3, r3, #21
 8004466:	d58c      	bpl.n	8004382 <HAL_RCC_OscConfig+0xca>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8004468:	f7ff f95c 	bl	8003724 <HAL_GetTick>
 800446c:	1b40      	subs	r0, r0, r5
 800446e:	2802      	cmp	r0, #2
 8004470:	d9f6      	bls.n	8004460 <HAL_RCC_OscConfig+0x1a8>
            return HAL_TIMEOUT;
 8004472:	2003      	movs	r0, #3
 8004474:	e079      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      if ((((RCC->CSR2) & RCC_CSR2_LSIRDY) != 0U) && (RCC_OscInitStruct->LSIState == RCC_LSI_OFF))
 8004476:	4b3f      	ldr	r3, [pc, #252]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004478:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800447a:	079b      	lsls	r3, r3, #30
 800447c:	d502      	bpl.n	8004484 <HAL_RCC_OscConfig+0x1cc>
 800447e:	69a3      	ldr	r3, [r4, #24]
 8004480:	2b00      	cmp	r3, #0
 8004482:	d06f      	beq.n	8004564 <HAL_RCC_OscConfig+0x2ac>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004484:	6823      	ldr	r3, [r4, #0]
 8004486:	075b      	lsls	r3, r3, #29
 8004488:	d56e      	bpl.n	8004568 <HAL_RCC_OscConfig+0x2b0>

    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* When the LSE is used as system clock, it is not allowed disable it */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 800448a:	4b3a      	ldr	r3, [pc, #232]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800448c:	689a      	ldr	r2, [r3, #8]
 800448e:	2338      	movs	r3, #56	; 0x38
 8004490:	4013      	ands	r3, r2
 8004492:	2b20      	cmp	r3, #32
 8004494:	d032      	beq.n	80044fc <HAL_RCC_OscConfig+0x244>
    }
    else
    {
      /* Update LSE configuration in RTC Domain control register    */
      /* Set the new LSE configuration -----------------------------------------*/
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004496:	68a3      	ldr	r3, [r4, #8]
 8004498:	2b01      	cmp	r3, #1
 800449a:	d038      	beq.n	800450e <HAL_RCC_OscConfig+0x256>
 800449c:	2b05      	cmp	r3, #5
 800449e:	d03c      	beq.n	800451a <HAL_RCC_OscConfig+0x262>
 80044a0:	4b34      	ldr	r3, [pc, #208]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80044a2:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80044a4:	2101      	movs	r1, #1
 80044a6:	438a      	bics	r2, r1
 80044a8:	65da      	str	r2, [r3, #92]	; 0x5c
 80044aa:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 80044ac:	3103      	adds	r1, #3
 80044ae:	438a      	bics	r2, r1
 80044b0:	65da      	str	r2, [r3, #92]	; 0x5c

      /* Check the LSE State */
      if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80044b2:	68a3      	ldr	r3, [r4, #8]
 80044b4:	2b00      	cmp	r3, #0
 80044b6:	d03c      	beq.n	8004532 <HAL_RCC_OscConfig+0x27a>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80044b8:	f7ff f934 	bl	8003724 <HAL_GetTick>
 80044bc:	0004      	movs	r4, r0

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == 0U)
 80044be:	4b2d      	ldr	r3, [pc, #180]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80044c0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80044c2:	079b      	lsls	r3, r3, #30
 80044c4:	d433      	bmi.n	800452e <HAL_RCC_OscConfig+0x276>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80044c6:	f7ff f92d 	bl	8003724 <HAL_GetTick>
 80044ca:	1b00      	subs	r0, r0, r4
 80044cc:	4b32      	ldr	r3, [pc, #200]	; (8004598 <HAL_RCC_OscConfig+0x2e0>)
 80044ce:	4298      	cmp	r0, r3
 80044d0:	d9f5      	bls.n	80044be <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 80044d2:	2003      	movs	r0, #3
 80044d4:	e049      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        __HAL_RCC_LSI_DISABLE();
 80044d6:	4a27      	ldr	r2, [pc, #156]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80044d8:	6e13      	ldr	r3, [r2, #96]	; 0x60
 80044da:	2101      	movs	r1, #1
 80044dc:	438b      	bics	r3, r1
 80044de:	6613      	str	r3, [r2, #96]	; 0x60
        tickstart = HAL_GetTick();
 80044e0:	f7ff f920 	bl	8003724 <HAL_GetTick>
 80044e4:	0005      	movs	r5, r0
        while (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) != 0U)
 80044e6:	4b23      	ldr	r3, [pc, #140]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80044e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80044ea:	079b      	lsls	r3, r3, #30
 80044ec:	d5ca      	bpl.n	8004484 <HAL_RCC_OscConfig+0x1cc>
          if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 80044ee:	f7ff f919 	bl	8003724 <HAL_GetTick>
 80044f2:	1b40      	subs	r0, r0, r5
 80044f4:	2802      	cmp	r0, #2
 80044f6:	d9f6      	bls.n	80044e6 <HAL_RCC_OscConfig+0x22e>
            return HAL_TIMEOUT;
 80044f8:	2003      	movs	r0, #3
 80044fa:	e036      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      if ((((RCC->CSR1) & RCC_CSR1_LSERDY) != 0U) && (RCC_OscInitStruct->LSEState == RCC_LSE_OFF))
 80044fc:	4b1d      	ldr	r3, [pc, #116]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 80044fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004500:	079b      	lsls	r3, r3, #30
 8004502:	d533      	bpl.n	800456c <HAL_RCC_OscConfig+0x2b4>
 8004504:	68a3      	ldr	r3, [r4, #8]
 8004506:	2b00      	cmp	r3, #0
 8004508:	d032      	beq.n	8004570 <HAL_RCC_OscConfig+0x2b8>
      {
        __HAL_RCC_PWR_CLK_DISABLE();
      }
    }
  }
  return HAL_OK;
 800450a:	2000      	movs	r0, #0
 800450c:	e02d      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
      __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800450e:	4a19      	ldr	r2, [pc, #100]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 8004510:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 8004512:	2101      	movs	r1, #1
 8004514:	430b      	orrs	r3, r1
 8004516:	65d3      	str	r3, [r2, #92]	; 0x5c
 8004518:	e7cb      	b.n	80044b2 <HAL_RCC_OscConfig+0x1fa>
 800451a:	4b16      	ldr	r3, [pc, #88]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800451c:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800451e:	2104      	movs	r1, #4
 8004520:	430a      	orrs	r2, r1
 8004522:	65da      	str	r2, [r3, #92]	; 0x5c
 8004524:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 8004526:	3903      	subs	r1, #3
 8004528:	430a      	orrs	r2, r1
 800452a:	65da      	str	r2, [r3, #92]	; 0x5c
 800452c:	e7c1      	b.n	80044b2 <HAL_RCC_OscConfig+0x1fa>
  return HAL_OK;
 800452e:	2000      	movs	r0, #0
 8004530:	e01b      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        tickstart = HAL_GetTick();
 8004532:	f7ff f8f7 	bl	8003724 <HAL_GetTick>
 8004536:	0004      	movs	r4, r0
        while (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) != 0U)
 8004538:	4b0e      	ldr	r3, [pc, #56]	; (8004574 <HAL_RCC_OscConfig+0x2bc>)
 800453a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800453c:	079b      	lsls	r3, r3, #30
 800453e:	d507      	bpl.n	8004550 <HAL_RCC_OscConfig+0x298>
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8004540:	f7ff f8f0 	bl	8003724 <HAL_GetTick>
 8004544:	1b00      	subs	r0, r0, r4
 8004546:	4b14      	ldr	r3, [pc, #80]	; (8004598 <HAL_RCC_OscConfig+0x2e0>)
 8004548:	4298      	cmp	r0, r3
 800454a:	d9f5      	bls.n	8004538 <HAL_RCC_OscConfig+0x280>
            return HAL_TIMEOUT;
 800454c:	2003      	movs	r0, #3
 800454e:	e00c      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
  return HAL_OK;
 8004550:	2000      	movs	r0, #0
 8004552:	e00a      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
    return HAL_ERROR;
 8004554:	2001      	movs	r0, #1
 8004556:	e008      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        return HAL_ERROR;
 8004558:	2001      	movs	r0, #1
 800455a:	e006      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        return HAL_ERROR;
 800455c:	2001      	movs	r0, #1
 800455e:	e004      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
          return HAL_ERROR;
 8004560:	2001      	movs	r0, #1
 8004562:	e002      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        return HAL_ERROR;
 8004564:	2001      	movs	r0, #1
 8004566:	e000      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
  return HAL_OK;
 8004568:	2000      	movs	r0, #0
}
 800456a:	bd70      	pop	{r4, r5, r6, pc}
  return HAL_OK;
 800456c:	2000      	movs	r0, #0
 800456e:	e7fc      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
        return HAL_ERROR;
 8004570:	2001      	movs	r0, #1
 8004572:	e7fa      	b.n	800456a <HAL_RCC_OscConfig+0x2b2>
 8004574:	40021000 	.word	0x40021000
 8004578:	fffeffff 	.word	0xfffeffff
 800457c:	fffbffff 	.word	0xfffbffff
 8004580:	ffff80ff 	.word	0xffff80ff
 8004584:	ffffc7ff 	.word	0xffffc7ff
 8004588:	02dc6c00 	.word	0x02dc6c00
 800458c:	200001f4 	.word	0x200001f4
 8004590:	200001fc 	.word	0x200001fc
 8004594:	fffffeff 	.word	0xfffffeff
 8004598:	00001388 	.word	0x00001388

0800459c <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t hsidiv;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 800459c:	4b14      	ldr	r3, [pc, #80]	; (80045f0 <HAL_RCC_GetSysClockFreq+0x54>)
 800459e:	689b      	ldr	r3, [r3, #8]
 80045a0:	2238      	movs	r2, #56	; 0x38
 80045a2:	421a      	tst	r2, r3
 80045a4:	d107      	bne.n	80045b6 <HAL_RCC_GetSysClockFreq+0x1a>
  {
    /* HSISYS can be derived for HSI48 */
    hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 80045a6:	4b12      	ldr	r3, [pc, #72]	; (80045f0 <HAL_RCC_GetSysClockFreq+0x54>)
 80045a8:	681a      	ldr	r2, [r3, #0]
 80045aa:	0ad2      	lsrs	r2, r2, #11
 80045ac:	2307      	movs	r3, #7
 80045ae:	4013      	ands	r3, r2

    /* HSI used as system clock source */
    sysclockfreq = (HSI_VALUE / hsidiv);
 80045b0:	4810      	ldr	r0, [pc, #64]	; (80045f4 <HAL_RCC_GetSysClockFreq+0x58>)
 80045b2:	40d8      	lsrs	r0, r3
  {
    sysclockfreq = 0U;
  }

  return sysclockfreq;
}
 80045b4:	4770      	bx	lr
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 80045b6:	4b0e      	ldr	r3, [pc, #56]	; (80045f0 <HAL_RCC_GetSysClockFreq+0x54>)
 80045b8:	689a      	ldr	r2, [r3, #8]
 80045ba:	2338      	movs	r3, #56	; 0x38
 80045bc:	4013      	ands	r3, r2
 80045be:	2b08      	cmp	r3, #8
 80045c0:	d010      	beq.n	80045e4 <HAL_RCC_GetSysClockFreq+0x48>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSE)
 80045c2:	4b0b      	ldr	r3, [pc, #44]	; (80045f0 <HAL_RCC_GetSysClockFreq+0x54>)
 80045c4:	689a      	ldr	r2, [r3, #8]
 80045c6:	2338      	movs	r3, #56	; 0x38
 80045c8:	4013      	ands	r3, r2
 80045ca:	2b20      	cmp	r3, #32
 80045cc:	d00c      	beq.n	80045e8 <HAL_RCC_GetSysClockFreq+0x4c>
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_LSI)
 80045ce:	4b08      	ldr	r3, [pc, #32]	; (80045f0 <HAL_RCC_GetSysClockFreq+0x54>)
 80045d0:	689a      	ldr	r2, [r3, #8]
 80045d2:	2338      	movs	r3, #56	; 0x38
 80045d4:	4013      	ands	r3, r2
 80045d6:	2b18      	cmp	r3, #24
 80045d8:	d001      	beq.n	80045de <HAL_RCC_GetSysClockFreq+0x42>
    sysclockfreq = 0U;
 80045da:	2000      	movs	r0, #0
  return sysclockfreq;
 80045dc:	e7ea      	b.n	80045b4 <HAL_RCC_GetSysClockFreq+0x18>
    sysclockfreq = LSI_VALUE;
 80045de:	20fa      	movs	r0, #250	; 0xfa
 80045e0:	01c0      	lsls	r0, r0, #7
 80045e2:	e7e7      	b.n	80045b4 <HAL_RCC_GetSysClockFreq+0x18>
    sysclockfreq = HSE_VALUE;
 80045e4:	4804      	ldr	r0, [pc, #16]	; (80045f8 <HAL_RCC_GetSysClockFreq+0x5c>)
 80045e6:	e7e5      	b.n	80045b4 <HAL_RCC_GetSysClockFreq+0x18>
    sysclockfreq = LSE_VALUE;
 80045e8:	2080      	movs	r0, #128	; 0x80
 80045ea:	0200      	lsls	r0, r0, #8
 80045ec:	e7e2      	b.n	80045b4 <HAL_RCC_GetSysClockFreq+0x18>
 80045ee:	46c0      	nop			; (mov r8, r8)
 80045f0:	40021000 	.word	0x40021000
 80045f4:	02dc6c00 	.word	0x02dc6c00
 80045f8:	007a1200 	.word	0x007a1200

080045fc <HAL_RCC_ClockConfig>:
{
 80045fc:	b570      	push	{r4, r5, r6, lr}
 80045fe:	0004      	movs	r4, r0
 8004600:	000d      	movs	r5, r1
  if (RCC_ClkInitStruct == NULL)
 8004602:	2800      	cmp	r0, #0
 8004604:	d100      	bne.n	8004608 <HAL_RCC_ClockConfig+0xc>
 8004606:	e0aa      	b.n	800475e <HAL_RCC_ClockConfig+0x162>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8004608:	4b57      	ldr	r3, [pc, #348]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 800460a:	681a      	ldr	r2, [r3, #0]
 800460c:	2307      	movs	r3, #7
 800460e:	4013      	ands	r3, r2
 8004610:	428b      	cmp	r3, r1
 8004612:	d328      	bcc.n	8004666 <HAL_RCC_ClockConfig+0x6a>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8004614:	6823      	ldr	r3, [r4, #0]
 8004616:	079a      	lsls	r2, r3, #30
 8004618:	d510      	bpl.n	800463c <HAL_RCC_ClockConfig+0x40>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800461a:	075b      	lsls	r3, r3, #29
 800461c:	d507      	bpl.n	800462e <HAL_RCC_ClockConfig+0x32>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 800461e:	4953      	ldr	r1, [pc, #332]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 8004620:	688b      	ldr	r3, [r1, #8]
 8004622:	4a53      	ldr	r2, [pc, #332]	; (8004770 <HAL_RCC_ClockConfig+0x174>)
 8004624:	401a      	ands	r2, r3
 8004626:	23b0      	movs	r3, #176	; 0xb0
 8004628:	011b      	lsls	r3, r3, #4
 800462a:	4313      	orrs	r3, r2
 800462c:	608b      	str	r3, [r1, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800462e:	4a4f      	ldr	r2, [pc, #316]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 8004630:	6893      	ldr	r3, [r2, #8]
 8004632:	4950      	ldr	r1, [pc, #320]	; (8004774 <HAL_RCC_ClockConfig+0x178>)
 8004634:	400b      	ands	r3, r1
 8004636:	68e1      	ldr	r1, [r4, #12]
 8004638:	430b      	orrs	r3, r1
 800463a:	6093      	str	r3, [r2, #8]
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 800463c:	6823      	ldr	r3, [r4, #0]
 800463e:	07db      	lsls	r3, r3, #31
 8004640:	d552      	bpl.n	80046e8 <HAL_RCC_ClockConfig+0xec>
    MODIFY_REG(RCC->CR, RCC_CR_SYSDIV, RCC_ClkInitStruct->SYSCLKDivider);
 8004642:	4a4a      	ldr	r2, [pc, #296]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 8004644:	6813      	ldr	r3, [r2, #0]
 8004646:	211c      	movs	r1, #28
 8004648:	438b      	bics	r3, r1
 800464a:	68a1      	ldr	r1, [r4, #8]
 800464c:	430b      	orrs	r3, r1
 800464e:	6013      	str	r3, [r2, #0]
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004650:	6863      	ldr	r3, [r4, #4]
 8004652:	2b01      	cmp	r3, #1
 8004654:	d01e      	beq.n	8004694 <HAL_RCC_ClockConfig+0x98>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSI)
 8004656:	2b00      	cmp	r3, #0
 8004658:	d138      	bne.n	80046cc <HAL_RCC_ClockConfig+0xd0>
      if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 800465a:	4a44      	ldr	r2, [pc, #272]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 800465c:	6812      	ldr	r2, [r2, #0]
 800465e:	0552      	lsls	r2, r2, #21
 8004660:	d41b      	bmi.n	800469a <HAL_RCC_ClockConfig+0x9e>
        return HAL_ERROR;
 8004662:	2001      	movs	r0, #1
 8004664:	e063      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004666:	4a40      	ldr	r2, [pc, #256]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 8004668:	6813      	ldr	r3, [r2, #0]
 800466a:	2107      	movs	r1, #7
 800466c:	438b      	bics	r3, r1
 800466e:	432b      	orrs	r3, r5
 8004670:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8004672:	f7ff f857 	bl	8003724 <HAL_GetTick>
 8004676:	0006      	movs	r6, r0
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8004678:	4b3b      	ldr	r3, [pc, #236]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 800467a:	681a      	ldr	r2, [r3, #0]
 800467c:	2307      	movs	r3, #7
 800467e:	4013      	ands	r3, r2
 8004680:	42ab      	cmp	r3, r5
 8004682:	d0c7      	beq.n	8004614 <HAL_RCC_ClockConfig+0x18>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004684:	f7ff f84e 	bl	8003724 <HAL_GetTick>
 8004688:	1b80      	subs	r0, r0, r6
 800468a:	4a3b      	ldr	r2, [pc, #236]	; (8004778 <HAL_RCC_ClockConfig+0x17c>)
 800468c:	4290      	cmp	r0, r2
 800468e:	d9f3      	bls.n	8004678 <HAL_RCC_ClockConfig+0x7c>
        return HAL_TIMEOUT;
 8004690:	2003      	movs	r0, #3
 8004692:	e04c      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
      if (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8004694:	6812      	ldr	r2, [r2, #0]
 8004696:	0392      	lsls	r2, r2, #14
 8004698:	d563      	bpl.n	8004762 <HAL_RCC_ClockConfig+0x166>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 800469a:	4934      	ldr	r1, [pc, #208]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 800469c:	688a      	ldr	r2, [r1, #8]
 800469e:	2007      	movs	r0, #7
 80046a0:	4382      	bics	r2, r0
 80046a2:	4313      	orrs	r3, r2
 80046a4:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 80046a6:	f7ff f83d 	bl	8003724 <HAL_GetTick>
 80046aa:	0006      	movs	r6, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80046ac:	4b2f      	ldr	r3, [pc, #188]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 80046ae:	689b      	ldr	r3, [r3, #8]
 80046b0:	2238      	movs	r2, #56	; 0x38
 80046b2:	401a      	ands	r2, r3
 80046b4:	6863      	ldr	r3, [r4, #4]
 80046b6:	00db      	lsls	r3, r3, #3
 80046b8:	429a      	cmp	r2, r3
 80046ba:	d015      	beq.n	80046e8 <HAL_RCC_ClockConfig+0xec>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80046bc:	f7ff f832 	bl	8003724 <HAL_GetTick>
 80046c0:	1b80      	subs	r0, r0, r6
 80046c2:	4b2d      	ldr	r3, [pc, #180]	; (8004778 <HAL_RCC_ClockConfig+0x17c>)
 80046c4:	4298      	cmp	r0, r3
 80046c6:	d9f1      	bls.n	80046ac <HAL_RCC_ClockConfig+0xb0>
        return HAL_TIMEOUT;
 80046c8:	2003      	movs	r0, #3
 80046ca:	e030      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_LSI)
 80046cc:	2b03      	cmp	r3, #3
 80046ce:	d005      	beq.n	80046dc <HAL_RCC_ClockConfig+0xe0>
      if (READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == 0U)
 80046d0:	4a26      	ldr	r2, [pc, #152]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 80046d2:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
 80046d4:	0792      	lsls	r2, r2, #30
 80046d6:	d4e0      	bmi.n	800469a <HAL_RCC_ClockConfig+0x9e>
        return HAL_ERROR;
 80046d8:	2001      	movs	r0, #1
 80046da:	e028      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
      if (READ_BIT(RCC->CSR2, RCC_CSR2_LSIRDY) == 0U)
 80046dc:	4a23      	ldr	r2, [pc, #140]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 80046de:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80046e0:	0792      	lsls	r2, r2, #30
 80046e2:	d4da      	bmi.n	800469a <HAL_RCC_ClockConfig+0x9e>
        return HAL_ERROR;
 80046e4:	2001      	movs	r0, #1
 80046e6:	e022      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80046e8:	4b1f      	ldr	r3, [pc, #124]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 80046ea:	681a      	ldr	r2, [r3, #0]
 80046ec:	2307      	movs	r3, #7
 80046ee:	4013      	ands	r3, r2
 80046f0:	42ab      	cmp	r3, r5
 80046f2:	d81d      	bhi.n	8004730 <HAL_RCC_ClockConfig+0x134>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80046f4:	6823      	ldr	r3, [r4, #0]
 80046f6:	075b      	lsls	r3, r3, #29
 80046f8:	d506      	bpl.n	8004708 <HAL_RCC_ClockConfig+0x10c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 80046fa:	4a1c      	ldr	r2, [pc, #112]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 80046fc:	6893      	ldr	r3, [r2, #8]
 80046fe:	491f      	ldr	r1, [pc, #124]	; (800477c <HAL_RCC_ClockConfig+0x180>)
 8004700:	400b      	ands	r3, r1
 8004702:	6921      	ldr	r1, [r4, #16]
 8004704:	430b      	orrs	r3, r1
 8004706:	6093      	str	r3, [r2, #8]
  SystemCoreClock = (HAL_RCC_GetSysClockFreq() >> ((AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]) & 0x1FU));
 8004708:	f7ff ff48 	bl	800459c <HAL_RCC_GetSysClockFreq>
 800470c:	4b17      	ldr	r3, [pc, #92]	; (800476c <HAL_RCC_ClockConfig+0x170>)
 800470e:	689a      	ldr	r2, [r3, #8]
 8004710:	0a12      	lsrs	r2, r2, #8
 8004712:	230f      	movs	r3, #15
 8004714:	4013      	ands	r3, r2
 8004716:	009b      	lsls	r3, r3, #2
 8004718:	4a19      	ldr	r2, [pc, #100]	; (8004780 <HAL_RCC_ClockConfig+0x184>)
 800471a:	589a      	ldr	r2, [r3, r2]
 800471c:	231f      	movs	r3, #31
 800471e:	4013      	ands	r3, r2
 8004720:	40d8      	lsrs	r0, r3
 8004722:	4b18      	ldr	r3, [pc, #96]	; (8004784 <HAL_RCC_ClockConfig+0x188>)
 8004724:	6018      	str	r0, [r3, #0]
  return HAL_InitTick(uwTickPrio);
 8004726:	4b18      	ldr	r3, [pc, #96]	; (8004788 <HAL_RCC_ClockConfig+0x18c>)
 8004728:	6818      	ldr	r0, [r3, #0]
 800472a:	f7fe ffb7 	bl	800369c <HAL_InitTick>
}
 800472e:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004730:	4a0d      	ldr	r2, [pc, #52]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 8004732:	6813      	ldr	r3, [r2, #0]
 8004734:	2107      	movs	r1, #7
 8004736:	438b      	bics	r3, r1
 8004738:	432b      	orrs	r3, r5
 800473a:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 800473c:	f7fe fff2 	bl	8003724 <HAL_GetTick>
 8004740:	0006      	movs	r6, r0
    while ((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8004742:	4b09      	ldr	r3, [pc, #36]	; (8004768 <HAL_RCC_ClockConfig+0x16c>)
 8004744:	681a      	ldr	r2, [r3, #0]
 8004746:	2307      	movs	r3, #7
 8004748:	4013      	ands	r3, r2
 800474a:	42ab      	cmp	r3, r5
 800474c:	d0d2      	beq.n	80046f4 <HAL_RCC_ClockConfig+0xf8>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800474e:	f7fe ffe9 	bl	8003724 <HAL_GetTick>
 8004752:	1b80      	subs	r0, r0, r6
 8004754:	4b08      	ldr	r3, [pc, #32]	; (8004778 <HAL_RCC_ClockConfig+0x17c>)
 8004756:	4298      	cmp	r0, r3
 8004758:	d9f3      	bls.n	8004742 <HAL_RCC_ClockConfig+0x146>
        return HAL_TIMEOUT;
 800475a:	2003      	movs	r0, #3
 800475c:	e7e7      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
    return HAL_ERROR;
 800475e:	2001      	movs	r0, #1
 8004760:	e7e5      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
        return HAL_ERROR;
 8004762:	2001      	movs	r0, #1
 8004764:	e7e3      	b.n	800472e <HAL_RCC_ClockConfig+0x132>
 8004766:	46c0      	nop			; (mov r8, r8)
 8004768:	40022000 	.word	0x40022000
 800476c:	40021000 	.word	0x40021000
 8004770:	ffff84ff 	.word	0xffff84ff
 8004774:	fffff0ff 	.word	0xfffff0ff
 8004778:	00001388 	.word	0x00001388
 800477c:	ffff8fff 	.word	0xffff8fff
 8004780:	08006500 	.word	0x08006500
 8004784:	200001f4 	.word	0x200001f4
 8004788:	200001fc 	.word	0x200001fc

0800478c <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800478c:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800478e:	6a03      	ldr	r3, [r0, #32]
 8004790:	2201      	movs	r2, #1
 8004792:	4393      	bics	r3, r2
 8004794:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004796:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004798:	6842      	ldr	r2, [r0, #4]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 800479a:	6984      	ldr	r4, [r0, #24]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800479c:	4d15      	ldr	r5, [pc, #84]	; (80047f4 <TIM_OC1_SetConfig+0x68>)
 800479e:	402c      	ands	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 80047a0:	680d      	ldr	r5, [r1, #0]
 80047a2:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 80047a4:	2502      	movs	r5, #2
 80047a6:	43ab      	bics	r3, r5
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 80047a8:	688d      	ldr	r5, [r1, #8]
 80047aa:	432b      	orrs	r3, r5

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 80047ac:	4d12      	ldr	r5, [pc, #72]	; (80047f8 <TIM_OC1_SetConfig+0x6c>)
 80047ae:	42a8      	cmp	r0, r5
 80047b0:	d005      	beq.n	80047be <TIM_OC1_SetConfig+0x32>
 80047b2:	4d12      	ldr	r5, [pc, #72]	; (80047fc <TIM_OC1_SetConfig+0x70>)
 80047b4:	42a8      	cmp	r0, r5
 80047b6:	d002      	beq.n	80047be <TIM_OC1_SetConfig+0x32>
 80047b8:	4d11      	ldr	r5, [pc, #68]	; (8004800 <TIM_OC1_SetConfig+0x74>)
 80047ba:	42a8      	cmp	r0, r5
 80047bc:	d105      	bne.n	80047ca <TIM_OC1_SetConfig+0x3e>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 80047be:	2508      	movs	r5, #8
 80047c0:	43ab      	bics	r3, r5
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 80047c2:	68cd      	ldr	r5, [r1, #12]
 80047c4:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 80047c6:	2504      	movs	r5, #4
 80047c8:	43ab      	bics	r3, r5
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80047ca:	4d0b      	ldr	r5, [pc, #44]	; (80047f8 <TIM_OC1_SetConfig+0x6c>)
 80047cc:	42a8      	cmp	r0, r5
 80047ce:	d005      	beq.n	80047dc <TIM_OC1_SetConfig+0x50>
 80047d0:	4d0a      	ldr	r5, [pc, #40]	; (80047fc <TIM_OC1_SetConfig+0x70>)
 80047d2:	42a8      	cmp	r0, r5
 80047d4:	d002      	beq.n	80047dc <TIM_OC1_SetConfig+0x50>
 80047d6:	4d0a      	ldr	r5, [pc, #40]	; (8004800 <TIM_OC1_SetConfig+0x74>)
 80047d8:	42a8      	cmp	r0, r5
 80047da:	d105      	bne.n	80047e8 <TIM_OC1_SetConfig+0x5c>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 80047dc:	4d09      	ldr	r5, [pc, #36]	; (8004804 <TIM_OC1_SetConfig+0x78>)
 80047de:	402a      	ands	r2, r5
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 80047e0:	694d      	ldr	r5, [r1, #20]
 80047e2:	432a      	orrs	r2, r5
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 80047e4:	698d      	ldr	r5, [r1, #24]
 80047e6:	432a      	orrs	r2, r5
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80047e8:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 80047ea:	6184      	str	r4, [r0, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 80047ec:	684a      	ldr	r2, [r1, #4]
 80047ee:	6342      	str	r2, [r0, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80047f0:	6203      	str	r3, [r0, #32]
}
 80047f2:	bd30      	pop	{r4, r5, pc}
 80047f4:	fffeff8c 	.word	0xfffeff8c
 80047f8:	40012c00 	.word	0x40012c00
 80047fc:	40014400 	.word	0x40014400
 8004800:	40014800 	.word	0x40014800
 8004804:	fffffcff 	.word	0xfffffcff

08004808 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8004808:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800480a:	6a03      	ldr	r3, [r0, #32]
 800480c:	4a18      	ldr	r2, [pc, #96]	; (8004870 <TIM_OC3_SetConfig+0x68>)
 800480e:	4013      	ands	r3, r2
 8004810:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004812:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004814:	6844      	ldr	r4, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004816:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8004818:	4d16      	ldr	r5, [pc, #88]	; (8004874 <TIM_OC3_SetConfig+0x6c>)
 800481a:	402a      	ands	r2, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 800481c:	680e      	ldr	r6, [r1, #0]
 800481e:	4316      	orrs	r6, r2

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8004820:	4a15      	ldr	r2, [pc, #84]	; (8004878 <TIM_OC3_SetConfig+0x70>)
 8004822:	4013      	ands	r3, r2
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8004824:	688a      	ldr	r2, [r1, #8]
 8004826:	0212      	lsls	r2, r2, #8
 8004828:	4313      	orrs	r3, r2

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800482a:	4a14      	ldr	r2, [pc, #80]	; (800487c <TIM_OC3_SetConfig+0x74>)
 800482c:	4290      	cmp	r0, r2
 800482e:	d016      	beq.n	800485e <TIM_OC3_SetConfig+0x56>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004830:	4a12      	ldr	r2, [pc, #72]	; (800487c <TIM_OC3_SetConfig+0x74>)
 8004832:	4290      	cmp	r0, r2
 8004834:	d005      	beq.n	8004842 <TIM_OC3_SetConfig+0x3a>
 8004836:	4a12      	ldr	r2, [pc, #72]	; (8004880 <TIM_OC3_SetConfig+0x78>)
 8004838:	4290      	cmp	r0, r2
 800483a:	d002      	beq.n	8004842 <TIM_OC3_SetConfig+0x3a>
 800483c:	4a11      	ldr	r2, [pc, #68]	; (8004884 <TIM_OC3_SetConfig+0x7c>)
 800483e:	4290      	cmp	r0, r2
 8004840:	d107      	bne.n	8004852 <TIM_OC3_SetConfig+0x4a>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8004842:	4a11      	ldr	r2, [pc, #68]	; (8004888 <TIM_OC3_SetConfig+0x80>)
 8004844:	4022      	ands	r2, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8004846:	694c      	ldr	r4, [r1, #20]
 8004848:	0124      	lsls	r4, r4, #4
 800484a:	4314      	orrs	r4, r2
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800484c:	698a      	ldr	r2, [r1, #24]
 800484e:	0115      	lsls	r5, r2, #4
 8004850:	432c      	orrs	r4, r5
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004852:	6044      	str	r4, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004854:	61c6      	str	r6, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8004856:	684a      	ldr	r2, [r1, #4]
 8004858:	63c2      	str	r2, [r0, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800485a:	6203      	str	r3, [r0, #32]
}
 800485c:	bd70      	pop	{r4, r5, r6, pc}
    tmpccer &= ~TIM_CCER_CC3NP;
 800485e:	4a0b      	ldr	r2, [pc, #44]	; (800488c <TIM_OC3_SetConfig+0x84>)
 8004860:	401a      	ands	r2, r3
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8004862:	68cb      	ldr	r3, [r1, #12]
 8004864:	021b      	lsls	r3, r3, #8
 8004866:	4313      	orrs	r3, r2
    tmpccer &= ~TIM_CCER_CC3NE;
 8004868:	4a09      	ldr	r2, [pc, #36]	; (8004890 <TIM_OC3_SetConfig+0x88>)
 800486a:	4013      	ands	r3, r2
 800486c:	e7e0      	b.n	8004830 <TIM_OC3_SetConfig+0x28>
 800486e:	46c0      	nop			; (mov r8, r8)
 8004870:	fffffeff 	.word	0xfffffeff
 8004874:	fffeff8c 	.word	0xfffeff8c
 8004878:	fffffdff 	.word	0xfffffdff
 800487c:	40012c00 	.word	0x40012c00
 8004880:	40014400 	.word	0x40014400
 8004884:	40014800 	.word	0x40014800
 8004888:	ffffcfff 	.word	0xffffcfff
 800488c:	fffff7ff 	.word	0xfffff7ff
 8004890:	fffffbff 	.word	0xfffffbff

08004894 <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8004894:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004896:	6a03      	ldr	r3, [r0, #32]
 8004898:	4a11      	ldr	r2, [pc, #68]	; (80048e0 <TIM_OC4_SetConfig+0x4c>)
 800489a:	4013      	ands	r3, r2
 800489c:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800489e:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 80048a0:	6845      	ldr	r5, [r0, #4]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 80048a2:	69c2      	ldr	r2, [r0, #28]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 80048a4:	4c0f      	ldr	r4, [pc, #60]	; (80048e4 <TIM_OC4_SetConfig+0x50>)
 80048a6:	4022      	ands	r2, r4

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 80048a8:	680c      	ldr	r4, [r1, #0]
 80048aa:	0224      	lsls	r4, r4, #8
 80048ac:	4322      	orrs	r2, r4

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 80048ae:	4c0e      	ldr	r4, [pc, #56]	; (80048e8 <TIM_OC4_SetConfig+0x54>)
 80048b0:	401c      	ands	r4, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 80048b2:	688b      	ldr	r3, [r1, #8]
 80048b4:	031b      	lsls	r3, r3, #12
 80048b6:	4323      	orrs	r3, r4

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 80048b8:	4c0c      	ldr	r4, [pc, #48]	; (80048ec <TIM_OC4_SetConfig+0x58>)
 80048ba:	42a0      	cmp	r0, r4
 80048bc:	d005      	beq.n	80048ca <TIM_OC4_SetConfig+0x36>
 80048be:	4c0c      	ldr	r4, [pc, #48]	; (80048f0 <TIM_OC4_SetConfig+0x5c>)
 80048c0:	42a0      	cmp	r0, r4
 80048c2:	d002      	beq.n	80048ca <TIM_OC4_SetConfig+0x36>
 80048c4:	4c0b      	ldr	r4, [pc, #44]	; (80048f4 <TIM_OC4_SetConfig+0x60>)
 80048c6:	42a0      	cmp	r0, r4
 80048c8:	d104      	bne.n	80048d4 <TIM_OC4_SetConfig+0x40>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 80048ca:	4c0b      	ldr	r4, [pc, #44]	; (80048f8 <TIM_OC4_SetConfig+0x64>)
 80048cc:	4025      	ands	r5, r4

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 80048ce:	694c      	ldr	r4, [r1, #20]
 80048d0:	01a4      	lsls	r4, r4, #6
 80048d2:	4325      	orrs	r5, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80048d4:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 80048d6:	61c2      	str	r2, [r0, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 80048d8:	684a      	ldr	r2, [r1, #4]
 80048da:	6402      	str	r2, [r0, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80048dc:	6203      	str	r3, [r0, #32]
}
 80048de:	bd30      	pop	{r4, r5, pc}
 80048e0:	ffffefff 	.word	0xffffefff
 80048e4:	feff8cff 	.word	0xfeff8cff
 80048e8:	ffffdfff 	.word	0xffffdfff
 80048ec:	40012c00 	.word	0x40012c00
 80048f0:	40014400 	.word	0x40014400
 80048f4:	40014800 	.word	0x40014800
 80048f8:	ffffbfff 	.word	0xffffbfff

080048fc <TIM_OC5_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 80048fc:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 80048fe:	6a03      	ldr	r3, [r0, #32]
 8004900:	4a11      	ldr	r2, [pc, #68]	; (8004948 <TIM_OC5_SetConfig+0x4c>)
 8004902:	4013      	ands	r3, r2
 8004904:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004906:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004908:	6842      	ldr	r2, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800490a:	6d44      	ldr	r4, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800490c:	4d0f      	ldr	r5, [pc, #60]	; (800494c <TIM_OC5_SetConfig+0x50>)
 800490e:	402c      	ands	r4, r5
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8004910:	680d      	ldr	r5, [r1, #0]
 8004912:	432c      	orrs	r4, r5

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 8004914:	4d0e      	ldr	r5, [pc, #56]	; (8004950 <TIM_OC5_SetConfig+0x54>)
 8004916:	401d      	ands	r5, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8004918:	688b      	ldr	r3, [r1, #8]
 800491a:	041b      	lsls	r3, r3, #16
 800491c:	432b      	orrs	r3, r5

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800491e:	4d0d      	ldr	r5, [pc, #52]	; (8004954 <TIM_OC5_SetConfig+0x58>)
 8004920:	42a8      	cmp	r0, r5
 8004922:	d005      	beq.n	8004930 <TIM_OC5_SetConfig+0x34>
 8004924:	4d0c      	ldr	r5, [pc, #48]	; (8004958 <TIM_OC5_SetConfig+0x5c>)
 8004926:	42a8      	cmp	r0, r5
 8004928:	d002      	beq.n	8004930 <TIM_OC5_SetConfig+0x34>
 800492a:	4d0c      	ldr	r5, [pc, #48]	; (800495c <TIM_OC5_SetConfig+0x60>)
 800492c:	42a8      	cmp	r0, r5
 800492e:	d104      	bne.n	800493a <TIM_OC5_SetConfig+0x3e>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8004930:	4d05      	ldr	r5, [pc, #20]	; (8004948 <TIM_OC5_SetConfig+0x4c>)
 8004932:	402a      	ands	r2, r5
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8004934:	694d      	ldr	r5, [r1, #20]
 8004936:	022d      	lsls	r5, r5, #8
 8004938:	432a      	orrs	r2, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800493a:	6042      	str	r2, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 800493c:	6544      	str	r4, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 800493e:	684a      	ldr	r2, [r1, #4]
 8004940:	6582      	str	r2, [r0, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004942:	6203      	str	r3, [r0, #32]
}
 8004944:	bd30      	pop	{r4, r5, pc}
 8004946:	46c0      	nop			; (mov r8, r8)
 8004948:	fffeffff 	.word	0xfffeffff
 800494c:	fffeff8f 	.word	0xfffeff8f
 8004950:	fffdffff 	.word	0xfffdffff
 8004954:	40012c00 	.word	0x40012c00
 8004958:	40014400 	.word	0x40014400
 800495c:	40014800 	.word	0x40014800

08004960 <TIM_OC6_SetConfig>:
  * @param  OC_Config The output configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8004960:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8004962:	6a03      	ldr	r3, [r0, #32]
 8004964:	4a11      	ldr	r2, [pc, #68]	; (80049ac <TIM_OC6_SetConfig+0x4c>)
 8004966:	4013      	ands	r3, r2
 8004968:	6203      	str	r3, [r0, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800496a:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 800496c:	6845      	ldr	r5, [r0, #4]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 800496e:	6d42      	ldr	r2, [r0, #84]	; 0x54

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8004970:	4c0f      	ldr	r4, [pc, #60]	; (80049b0 <TIM_OC6_SetConfig+0x50>)
 8004972:	4022      	ands	r2, r4
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004974:	680c      	ldr	r4, [r1, #0]
 8004976:	0224      	lsls	r4, r4, #8
 8004978:	4322      	orrs	r2, r4

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800497a:	4c0e      	ldr	r4, [pc, #56]	; (80049b4 <TIM_OC6_SetConfig+0x54>)
 800497c:	401c      	ands	r4, r3
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800497e:	688b      	ldr	r3, [r1, #8]
 8004980:	051b      	lsls	r3, r3, #20
 8004982:	4323      	orrs	r3, r4

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004984:	4c0c      	ldr	r4, [pc, #48]	; (80049b8 <TIM_OC6_SetConfig+0x58>)
 8004986:	42a0      	cmp	r0, r4
 8004988:	d005      	beq.n	8004996 <TIM_OC6_SetConfig+0x36>
 800498a:	4c0c      	ldr	r4, [pc, #48]	; (80049bc <TIM_OC6_SetConfig+0x5c>)
 800498c:	42a0      	cmp	r0, r4
 800498e:	d002      	beq.n	8004996 <TIM_OC6_SetConfig+0x36>
 8004990:	4c0b      	ldr	r4, [pc, #44]	; (80049c0 <TIM_OC6_SetConfig+0x60>)
 8004992:	42a0      	cmp	r0, r4
 8004994:	d104      	bne.n	80049a0 <TIM_OC6_SetConfig+0x40>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8004996:	4c0b      	ldr	r4, [pc, #44]	; (80049c4 <TIM_OC6_SetConfig+0x64>)
 8004998:	4025      	ands	r5, r4
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800499a:	694c      	ldr	r4, [r1, #20]
 800499c:	02a4      	lsls	r4, r4, #10
 800499e:	4325      	orrs	r5, r4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 80049a0:	6045      	str	r5, [r0, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 80049a2:	6542      	str	r2, [r0, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 80049a4:	684a      	ldr	r2, [r1, #4]
 80049a6:	65c2      	str	r2, [r0, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80049a8:	6203      	str	r3, [r0, #32]
}
 80049aa:	bd30      	pop	{r4, r5, pc}
 80049ac:	ffefffff 	.word	0xffefffff
 80049b0:	feff8fff 	.word	0xfeff8fff
 80049b4:	ffdfffff 	.word	0xffdfffff
 80049b8:	40012c00 	.word	0x40012c00
 80049bc:	40014400 	.word	0x40014400
 80049c0:	40014800 	.word	0x40014800
 80049c4:	fffbffff 	.word	0xfffbffff

080049c8 <TIM_TI2_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 80049c8:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 80049ca:	6a04      	ldr	r4, [r0, #32]
 80049cc:	2510      	movs	r5, #16
 80049ce:	43ac      	bics	r4, r5
 80049d0:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 80049d2:	6985      	ldr	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 80049d4:	6a04      	ldr	r4, [r0, #32]

  /* Select the Input */
  tmpccmr1 &= ~TIM_CCMR1_CC2S;
 80049d6:	4e08      	ldr	r6, [pc, #32]	; (80049f8 <TIM_TI2_SetConfig+0x30>)
 80049d8:	4035      	ands	r5, r6
  tmpccmr1 |= (TIM_ICSelection << 8U);
 80049da:	0212      	lsls	r2, r2, #8
 80049dc:	432a      	orrs	r2, r5

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 80049de:	4d07      	ldr	r5, [pc, #28]	; (80049fc <TIM_TI2_SetConfig+0x34>)
 80049e0:	402a      	ands	r2, r5
  tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
 80049e2:	071b      	lsls	r3, r3, #28
 80049e4:	0c1b      	lsrs	r3, r3, #16
 80049e6:	4313      	orrs	r3, r2

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80049e8:	22a0      	movs	r2, #160	; 0xa0
 80049ea:	4394      	bics	r4, r2
  tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
 80049ec:	0109      	lsls	r1, r1, #4
 80049ee:	400a      	ands	r2, r1
 80049f0:	4322      	orrs	r2, r4

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 80049f2:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 80049f4:	6202      	str	r2, [r0, #32]
}
 80049f6:	bd70      	pop	{r4, r5, r6, pc}
 80049f8:	fffffcff 	.word	0xfffffcff
 80049fc:	ffff0fff 	.word	0xffff0fff

08004a00 <TIM_TI3_SetConfig>:
  *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be
  *        protected against un-initialized filter and polarity values.
  */
static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 8004a00:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8004a02:	6a05      	ldr	r5, [r0, #32]
 8004a04:	4c0b      	ldr	r4, [pc, #44]	; (8004a34 <TIM_TI3_SetConfig+0x34>)
 8004a06:	4025      	ands	r5, r4
 8004a08:	6205      	str	r5, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8004a0a:	69c4      	ldr	r4, [r0, #28]
  tmpccer = TIMx->CCER;
 8004a0c:	6a05      	ldr	r5, [r0, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC3S;
 8004a0e:	2603      	movs	r6, #3
 8004a10:	43b4      	bics	r4, r6
  tmpccmr2 |= TIM_ICSelection;
 8004a12:	4314      	orrs	r4, r2

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC3F;
 8004a14:	22f0      	movs	r2, #240	; 0xf0
 8004a16:	4394      	bics	r4, r2
  tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
 8004a18:	011a      	lsls	r2, r3, #4
 8004a1a:	23ff      	movs	r3, #255	; 0xff
 8004a1c:	4013      	ands	r3, r2
 8004a1e:	431c      	orrs	r4, r3

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8004a20:	4b05      	ldr	r3, [pc, #20]	; (8004a38 <TIM_TI3_SetConfig+0x38>)
 8004a22:	401d      	ands	r5, r3
  tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P | TIM_CCER_CC3NP));
 8004a24:	0209      	lsls	r1, r1, #8
 8004a26:	23a0      	movs	r3, #160	; 0xa0
 8004a28:	011b      	lsls	r3, r3, #4
 8004a2a:	4019      	ands	r1, r3
 8004a2c:	4329      	orrs	r1, r5

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8004a2e:	61c4      	str	r4, [r0, #28]
  TIMx->CCER = tmpccer;
 8004a30:	6201      	str	r1, [r0, #32]
}
 8004a32:	bd70      	pop	{r4, r5, r6, pc}
 8004a34:	fffffeff 	.word	0xfffffeff
 8004a38:	fffff5ff 	.word	0xfffff5ff

08004a3c <TIM_TI4_SetConfig>:
  *        protected against un-initialized filter and polarity values.
  * @retval None
  */
static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
                              uint32_t TIM_ICFilter)
{
 8004a3c:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpccmr2;
  uint32_t tmpccer;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8004a3e:	6a04      	ldr	r4, [r0, #32]
 8004a40:	4d0b      	ldr	r5, [pc, #44]	; (8004a70 <TIM_TI4_SetConfig+0x34>)
 8004a42:	402c      	ands	r4, r5
 8004a44:	6204      	str	r4, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8004a46:	69c5      	ldr	r5, [r0, #28]
  tmpccer = TIMx->CCER;
 8004a48:	6a04      	ldr	r4, [r0, #32]

  /* Select the Input */
  tmpccmr2 &= ~TIM_CCMR2_CC4S;
 8004a4a:	4e0a      	ldr	r6, [pc, #40]	; (8004a74 <TIM_TI4_SetConfig+0x38>)
 8004a4c:	4035      	ands	r5, r6
  tmpccmr2 |= (TIM_ICSelection << 8U);
 8004a4e:	0212      	lsls	r2, r2, #8
 8004a50:	432a      	orrs	r2, r5

  /* Set the filter */
  tmpccmr2 &= ~TIM_CCMR2_IC4F;
 8004a52:	4d09      	ldr	r5, [pc, #36]	; (8004a78 <TIM_TI4_SetConfig+0x3c>)
 8004a54:	402a      	ands	r2, r5
  tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
 8004a56:	071b      	lsls	r3, r3, #28
 8004a58:	0c1b      	lsrs	r3, r3, #16
 8004a5a:	4313      	orrs	r3, r2

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8004a5c:	4a07      	ldr	r2, [pc, #28]	; (8004a7c <TIM_TI4_SetConfig+0x40>)
 8004a5e:	4014      	ands	r4, r2
  tmpccer |= ((TIM_ICPolarity << 12U) & (TIM_CCER_CC4P | TIM_CCER_CC4NP));
 8004a60:	0309      	lsls	r1, r1, #12
 8004a62:	22a0      	movs	r2, #160	; 0xa0
 8004a64:	0212      	lsls	r2, r2, #8
 8004a66:	4011      	ands	r1, r2
 8004a68:	4321      	orrs	r1, r4

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8004a6a:	61c3      	str	r3, [r0, #28]
  TIMx->CCER = tmpccer ;
 8004a6c:	6201      	str	r1, [r0, #32]
}
 8004a6e:	bd70      	pop	{r4, r5, r6, pc}
 8004a70:	ffffefff 	.word	0xffffefff
 8004a74:	fffffcff 	.word	0xfffffcff
 8004a78:	ffff0fff 	.word	0xffff0fff
 8004a7c:	ffff5fff 	.word	0xffff5fff

08004a80 <HAL_TIM_PWM_MspInit>:
}
 8004a80:	4770      	bx	lr

08004a82 <HAL_TIM_IC_MspInit>:
}
 8004a82:	4770      	bx	lr

08004a84 <HAL_TIM_ReadCapturedValue>:
  switch (Channel)
 8004a84:	2908      	cmp	r1, #8
 8004a86:	d013      	beq.n	8004ab0 <HAL_TIM_ReadCapturedValue+0x2c>
 8004a88:	d808      	bhi.n	8004a9c <HAL_TIM_ReadCapturedValue+0x18>
 8004a8a:	2900      	cmp	r1, #0
 8004a8c:	d00d      	beq.n	8004aaa <HAL_TIM_ReadCapturedValue+0x26>
 8004a8e:	2904      	cmp	r1, #4
 8004a90:	d102      	bne.n	8004a98 <HAL_TIM_ReadCapturedValue+0x14>
      tmpreg =   htim->Instance->CCR2;
 8004a92:	6803      	ldr	r3, [r0, #0]
 8004a94:	6b98      	ldr	r0, [r3, #56]	; 0x38
      break;
 8004a96:	e007      	b.n	8004aa8 <HAL_TIM_ReadCapturedValue+0x24>
  switch (Channel)
 8004a98:	2000      	movs	r0, #0
 8004a9a:	e005      	b.n	8004aa8 <HAL_TIM_ReadCapturedValue+0x24>
 8004a9c:	290c      	cmp	r1, #12
 8004a9e:	d102      	bne.n	8004aa6 <HAL_TIM_ReadCapturedValue+0x22>
      tmpreg =   htim->Instance->CCR4;
 8004aa0:	6803      	ldr	r3, [r0, #0]
 8004aa2:	6c18      	ldr	r0, [r3, #64]	; 0x40
  return tmpreg;
 8004aa4:	e000      	b.n	8004aa8 <HAL_TIM_ReadCapturedValue+0x24>
  switch (Channel)
 8004aa6:	2000      	movs	r0, #0
}
 8004aa8:	4770      	bx	lr
      tmpreg =  htim->Instance->CCR1;
 8004aaa:	6803      	ldr	r3, [r0, #0]
 8004aac:	6b58      	ldr	r0, [r3, #52]	; 0x34
      break;
 8004aae:	e7fb      	b.n	8004aa8 <HAL_TIM_ReadCapturedValue+0x24>
      tmpreg =   htim->Instance->CCR3;
 8004ab0:	6803      	ldr	r3, [r0, #0]
 8004ab2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
      break;
 8004ab4:	e7f8      	b.n	8004aa8 <HAL_TIM_ReadCapturedValue+0x24>
	...

08004ab8 <TIM_Base_SetConfig>:
  tmpcr1 = TIMx->CR1;
 8004ab8:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8004aba:	4a1a      	ldr	r2, [pc, #104]	; (8004b24 <TIM_Base_SetConfig+0x6c>)
 8004abc:	4290      	cmp	r0, r2
 8004abe:	d002      	beq.n	8004ac6 <TIM_Base_SetConfig+0xe>
 8004ac0:	4a19      	ldr	r2, [pc, #100]	; (8004b28 <TIM_Base_SetConfig+0x70>)
 8004ac2:	4290      	cmp	r0, r2
 8004ac4:	d103      	bne.n	8004ace <TIM_Base_SetConfig+0x16>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004ac6:	2270      	movs	r2, #112	; 0x70
 8004ac8:	4393      	bics	r3, r2
    tmpcr1 |= Structure->CounterMode;
 8004aca:	684a      	ldr	r2, [r1, #4]
 8004acc:	4313      	orrs	r3, r2
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8004ace:	4a15      	ldr	r2, [pc, #84]	; (8004b24 <TIM_Base_SetConfig+0x6c>)
 8004ad0:	4290      	cmp	r0, r2
 8004ad2:	d00b      	beq.n	8004aec <TIM_Base_SetConfig+0x34>
 8004ad4:	4a14      	ldr	r2, [pc, #80]	; (8004b28 <TIM_Base_SetConfig+0x70>)
 8004ad6:	4290      	cmp	r0, r2
 8004ad8:	d008      	beq.n	8004aec <TIM_Base_SetConfig+0x34>
 8004ada:	4a14      	ldr	r2, [pc, #80]	; (8004b2c <TIM_Base_SetConfig+0x74>)
 8004adc:	4290      	cmp	r0, r2
 8004ade:	d005      	beq.n	8004aec <TIM_Base_SetConfig+0x34>
 8004ae0:	4a13      	ldr	r2, [pc, #76]	; (8004b30 <TIM_Base_SetConfig+0x78>)
 8004ae2:	4290      	cmp	r0, r2
 8004ae4:	d002      	beq.n	8004aec <TIM_Base_SetConfig+0x34>
 8004ae6:	4a13      	ldr	r2, [pc, #76]	; (8004b34 <TIM_Base_SetConfig+0x7c>)
 8004ae8:	4290      	cmp	r0, r2
 8004aea:	d103      	bne.n	8004af4 <TIM_Base_SetConfig+0x3c>
    tmpcr1 &= ~TIM_CR1_CKD;
 8004aec:	4a12      	ldr	r2, [pc, #72]	; (8004b38 <TIM_Base_SetConfig+0x80>)
 8004aee:	4013      	ands	r3, r2
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8004af0:	68ca      	ldr	r2, [r1, #12]
 8004af2:	4313      	orrs	r3, r2
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8004af4:	2280      	movs	r2, #128	; 0x80
 8004af6:	4393      	bics	r3, r2
 8004af8:	694a      	ldr	r2, [r1, #20]
 8004afa:	4313      	orrs	r3, r2
  TIMx->CR1 = tmpcr1;
 8004afc:	6003      	str	r3, [r0, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8004afe:	688b      	ldr	r3, [r1, #8]
 8004b00:	62c3      	str	r3, [r0, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 8004b02:	680b      	ldr	r3, [r1, #0]
 8004b04:	6283      	str	r3, [r0, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8004b06:	4b07      	ldr	r3, [pc, #28]	; (8004b24 <TIM_Base_SetConfig+0x6c>)
 8004b08:	4298      	cmp	r0, r3
 8004b0a:	d005      	beq.n	8004b18 <TIM_Base_SetConfig+0x60>
 8004b0c:	4b08      	ldr	r3, [pc, #32]	; (8004b30 <TIM_Base_SetConfig+0x78>)
 8004b0e:	4298      	cmp	r0, r3
 8004b10:	d002      	beq.n	8004b18 <TIM_Base_SetConfig+0x60>
 8004b12:	4b08      	ldr	r3, [pc, #32]	; (8004b34 <TIM_Base_SetConfig+0x7c>)
 8004b14:	4298      	cmp	r0, r3
 8004b16:	d101      	bne.n	8004b1c <TIM_Base_SetConfig+0x64>
    TIMx->RCR = Structure->RepetitionCounter;
 8004b18:	690b      	ldr	r3, [r1, #16]
 8004b1a:	6303      	str	r3, [r0, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 8004b1c:	2301      	movs	r3, #1
 8004b1e:	6143      	str	r3, [r0, #20]
}
 8004b20:	4770      	bx	lr
 8004b22:	46c0      	nop			; (mov r8, r8)
 8004b24:	40012c00 	.word	0x40012c00
 8004b28:	40000400 	.word	0x40000400
 8004b2c:	40002000 	.word	0x40002000
 8004b30:	40014400 	.word	0x40014400
 8004b34:	40014800 	.word	0x40014800
 8004b38:	fffffcff 	.word	0xfffffcff

08004b3c <HAL_TIM_PWM_Init>:
{
 8004b3c:	b570      	push	{r4, r5, r6, lr}
 8004b3e:	1e04      	subs	r4, r0, #0
  if (htim == NULL)
 8004b40:	d02a      	beq.n	8004b98 <HAL_TIM_PWM_Init+0x5c>
  if (htim->State == HAL_TIM_STATE_RESET)
 8004b42:	233d      	movs	r3, #61	; 0x3d
 8004b44:	5cc3      	ldrb	r3, [r0, r3]
 8004b46:	2b00      	cmp	r3, #0
 8004b48:	d020      	beq.n	8004b8c <HAL_TIM_PWM_Init+0x50>
  htim->State = HAL_TIM_STATE_BUSY;
 8004b4a:	253d      	movs	r5, #61	; 0x3d
 8004b4c:	2302      	movs	r3, #2
 8004b4e:	5563      	strb	r3, [r4, r5]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8004b50:	0021      	movs	r1, r4
 8004b52:	c901      	ldmia	r1!, {r0}
 8004b54:	f7ff ffb0 	bl	8004ab8 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8004b58:	2301      	movs	r3, #1
 8004b5a:	2248      	movs	r2, #72	; 0x48
 8004b5c:	54a3      	strb	r3, [r4, r2]
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004b5e:	3a0a      	subs	r2, #10
 8004b60:	54a3      	strb	r3, [r4, r2]
 8004b62:	3201      	adds	r2, #1
 8004b64:	54a3      	strb	r3, [r4, r2]
 8004b66:	3201      	adds	r2, #1
 8004b68:	54a3      	strb	r3, [r4, r2]
 8004b6a:	3201      	adds	r2, #1
 8004b6c:	54a3      	strb	r3, [r4, r2]
 8004b6e:	3201      	adds	r2, #1
 8004b70:	54a3      	strb	r3, [r4, r2]
 8004b72:	3201      	adds	r2, #1
 8004b74:	54a3      	strb	r3, [r4, r2]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004b76:	3201      	adds	r2, #1
 8004b78:	54a3      	strb	r3, [r4, r2]
 8004b7a:	3201      	adds	r2, #1
 8004b7c:	54a3      	strb	r3, [r4, r2]
 8004b7e:	3201      	adds	r2, #1
 8004b80:	54a3      	strb	r3, [r4, r2]
 8004b82:	3201      	adds	r2, #1
 8004b84:	54a3      	strb	r3, [r4, r2]
  htim->State = HAL_TIM_STATE_READY;
 8004b86:	5563      	strb	r3, [r4, r5]
  return HAL_OK;
 8004b88:	2000      	movs	r0, #0
}
 8004b8a:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 8004b8c:	333c      	adds	r3, #60	; 0x3c
 8004b8e:	2200      	movs	r2, #0
 8004b90:	54c2      	strb	r2, [r0, r3]
    HAL_TIM_PWM_MspInit(htim);
 8004b92:	f7ff ff75 	bl	8004a80 <HAL_TIM_PWM_MspInit>
 8004b96:	e7d8      	b.n	8004b4a <HAL_TIM_PWM_Init+0xe>
    return HAL_ERROR;
 8004b98:	2001      	movs	r0, #1
 8004b9a:	e7f6      	b.n	8004b8a <HAL_TIM_PWM_Init+0x4e>

08004b9c <HAL_TIM_IC_Init>:
{
 8004b9c:	b570      	push	{r4, r5, r6, lr}
 8004b9e:	1e04      	subs	r4, r0, #0
  if (htim == NULL)
 8004ba0:	d02a      	beq.n	8004bf8 <HAL_TIM_IC_Init+0x5c>
  if (htim->State == HAL_TIM_STATE_RESET)
 8004ba2:	233d      	movs	r3, #61	; 0x3d
 8004ba4:	5cc3      	ldrb	r3, [r0, r3]
 8004ba6:	2b00      	cmp	r3, #0
 8004ba8:	d020      	beq.n	8004bec <HAL_TIM_IC_Init+0x50>
  htim->State = HAL_TIM_STATE_BUSY;
 8004baa:	253d      	movs	r5, #61	; 0x3d
 8004bac:	2302      	movs	r3, #2
 8004bae:	5563      	strb	r3, [r4, r5]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8004bb0:	0021      	movs	r1, r4
 8004bb2:	c901      	ldmia	r1!, {r0}
 8004bb4:	f7ff ff80 	bl	8004ab8 <TIM_Base_SetConfig>
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8004bb8:	2301      	movs	r3, #1
 8004bba:	2248      	movs	r2, #72	; 0x48
 8004bbc:	54a3      	strb	r3, [r4, r2]
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004bbe:	3a0a      	subs	r2, #10
 8004bc0:	54a3      	strb	r3, [r4, r2]
 8004bc2:	3201      	adds	r2, #1
 8004bc4:	54a3      	strb	r3, [r4, r2]
 8004bc6:	3201      	adds	r2, #1
 8004bc8:	54a3      	strb	r3, [r4, r2]
 8004bca:	3201      	adds	r2, #1
 8004bcc:	54a3      	strb	r3, [r4, r2]
 8004bce:	3201      	adds	r2, #1
 8004bd0:	54a3      	strb	r3, [r4, r2]
 8004bd2:	3201      	adds	r2, #1
 8004bd4:	54a3      	strb	r3, [r4, r2]
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8004bd6:	3201      	adds	r2, #1
 8004bd8:	54a3      	strb	r3, [r4, r2]
 8004bda:	3201      	adds	r2, #1
 8004bdc:	54a3      	strb	r3, [r4, r2]
 8004bde:	3201      	adds	r2, #1
 8004be0:	54a3      	strb	r3, [r4, r2]
 8004be2:	3201      	adds	r2, #1
 8004be4:	54a3      	strb	r3, [r4, r2]
  htim->State = HAL_TIM_STATE_READY;
 8004be6:	5563      	strb	r3, [r4, r5]
  return HAL_OK;
 8004be8:	2000      	movs	r0, #0
}
 8004bea:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 8004bec:	333c      	adds	r3, #60	; 0x3c
 8004bee:	2200      	movs	r2, #0
 8004bf0:	54c2      	strb	r2, [r0, r3]
    HAL_TIM_IC_MspInit(htim);
 8004bf2:	f7ff ff46 	bl	8004a82 <HAL_TIM_IC_MspInit>
 8004bf6:	e7d8      	b.n	8004baa <HAL_TIM_IC_Init+0xe>
    return HAL_ERROR;
 8004bf8:	2001      	movs	r0, #1
 8004bfa:	e7f6      	b.n	8004bea <HAL_TIM_IC_Init+0x4e>

08004bfc <TIM_OC2_SetConfig>:
{
 8004bfc:	b530      	push	{r4, r5, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8004bfe:	6a03      	ldr	r3, [r0, #32]
 8004c00:	2210      	movs	r2, #16
 8004c02:	4393      	bics	r3, r2
 8004c04:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 8004c06:	6a03      	ldr	r3, [r0, #32]
  tmpcr2 =  TIMx->CR2;
 8004c08:	6845      	ldr	r5, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 8004c0a:	6984      	ldr	r4, [r0, #24]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8004c0c:	4a16      	ldr	r2, [pc, #88]	; (8004c68 <TIM_OC2_SetConfig+0x6c>)
 8004c0e:	4014      	ands	r4, r2
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8004c10:	680a      	ldr	r2, [r1, #0]
 8004c12:	0212      	lsls	r2, r2, #8
 8004c14:	4314      	orrs	r4, r2
  tmpccer &= ~TIM_CCER_CC2P;
 8004c16:	2220      	movs	r2, #32
 8004c18:	4393      	bics	r3, r2
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8004c1a:	688a      	ldr	r2, [r1, #8]
 8004c1c:	0112      	lsls	r2, r2, #4
 8004c1e:	4313      	orrs	r3, r2
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8004c20:	4a12      	ldr	r2, [pc, #72]	; (8004c6c <TIM_OC2_SetConfig+0x70>)
 8004c22:	4290      	cmp	r0, r2
 8004c24:	d016      	beq.n	8004c54 <TIM_OC2_SetConfig+0x58>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8004c26:	4a11      	ldr	r2, [pc, #68]	; (8004c6c <TIM_OC2_SetConfig+0x70>)
 8004c28:	4290      	cmp	r0, r2
 8004c2a:	d005      	beq.n	8004c38 <TIM_OC2_SetConfig+0x3c>
 8004c2c:	4a10      	ldr	r2, [pc, #64]	; (8004c70 <TIM_OC2_SetConfig+0x74>)
 8004c2e:	4290      	cmp	r0, r2
 8004c30:	d002      	beq.n	8004c38 <TIM_OC2_SetConfig+0x3c>
 8004c32:	4a10      	ldr	r2, [pc, #64]	; (8004c74 <TIM_OC2_SetConfig+0x78>)
 8004c34:	4290      	cmp	r0, r2
 8004c36:	d107      	bne.n	8004c48 <TIM_OC2_SetConfig+0x4c>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8004c38:	4a0f      	ldr	r2, [pc, #60]	; (8004c78 <TIM_OC2_SetConfig+0x7c>)
 8004c3a:	402a      	ands	r2, r5
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8004c3c:	694d      	ldr	r5, [r1, #20]
 8004c3e:	00ad      	lsls	r5, r5, #2
 8004c40:	4315      	orrs	r5, r2
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8004c42:	698a      	ldr	r2, [r1, #24]
 8004c44:	0092      	lsls	r2, r2, #2
 8004c46:	4315      	orrs	r5, r2
  TIMx->CR2 = tmpcr2;
 8004c48:	6045      	str	r5, [r0, #4]
  TIMx->CCMR1 = tmpccmrx;
 8004c4a:	6184      	str	r4, [r0, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 8004c4c:	684a      	ldr	r2, [r1, #4]
 8004c4e:	6382      	str	r2, [r0, #56]	; 0x38
  TIMx->CCER = tmpccer;
 8004c50:	6203      	str	r3, [r0, #32]
}
 8004c52:	bd30      	pop	{r4, r5, pc}
    tmpccer &= ~TIM_CCER_CC2NP;
 8004c54:	2280      	movs	r2, #128	; 0x80
 8004c56:	4393      	bics	r3, r2
 8004c58:	001a      	movs	r2, r3
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8004c5a:	68cb      	ldr	r3, [r1, #12]
 8004c5c:	011b      	lsls	r3, r3, #4
 8004c5e:	4313      	orrs	r3, r2
    tmpccer &= ~TIM_CCER_CC2NE;
 8004c60:	2240      	movs	r2, #64	; 0x40
 8004c62:	4393      	bics	r3, r2
 8004c64:	e7df      	b.n	8004c26 <TIM_OC2_SetConfig+0x2a>
 8004c66:	46c0      	nop			; (mov r8, r8)
 8004c68:	feff8cff 	.word	0xfeff8cff
 8004c6c:	40012c00 	.word	0x40012c00
 8004c70:	40014400 	.word	0x40014400
 8004c74:	40014800 	.word	0x40014800
 8004c78:	fffff3ff 	.word	0xfffff3ff

08004c7c <HAL_TIM_PWM_ConfigChannel>:
{
 8004c7c:	b570      	push	{r4, r5, r6, lr}
 8004c7e:	0004      	movs	r4, r0
 8004c80:	000d      	movs	r5, r1
  __HAL_LOCK(htim);
 8004c82:	233c      	movs	r3, #60	; 0x3c
 8004c84:	5cc3      	ldrb	r3, [r0, r3]
 8004c86:	2b01      	cmp	r3, #1
 8004c88:	d100      	bne.n	8004c8c <HAL_TIM_PWM_ConfigChannel+0x10>
 8004c8a:	e092      	b.n	8004db2 <HAL_TIM_PWM_ConfigChannel+0x136>
 8004c8c:	233c      	movs	r3, #60	; 0x3c
 8004c8e:	2101      	movs	r1, #1
 8004c90:	54c1      	strb	r1, [r0, r3]
  switch (Channel)
 8004c92:	2a14      	cmp	r2, #20
 8004c94:	d900      	bls.n	8004c98 <HAL_TIM_PWM_ConfigChannel+0x1c>
 8004c96:	e087      	b.n	8004da8 <HAL_TIM_PWM_ConfigChannel+0x12c>
 8004c98:	0092      	lsls	r2, r2, #2
 8004c9a:	4b47      	ldr	r3, [pc, #284]	; (8004db8 <HAL_TIM_PWM_ConfigChannel+0x13c>)
 8004c9c:	589b      	ldr	r3, [r3, r2]
 8004c9e:	469f      	mov	pc, r3
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8004ca0:	0029      	movs	r1, r5
 8004ca2:	6800      	ldr	r0, [r0, #0]
 8004ca4:	f7ff fd72 	bl	800478c <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8004ca8:	6822      	ldr	r2, [r4, #0]
 8004caa:	6993      	ldr	r3, [r2, #24]
 8004cac:	2108      	movs	r1, #8
 8004cae:	430b      	orrs	r3, r1
 8004cb0:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8004cb2:	6822      	ldr	r2, [r4, #0]
 8004cb4:	6993      	ldr	r3, [r2, #24]
 8004cb6:	3904      	subs	r1, #4
 8004cb8:	438b      	bics	r3, r1
 8004cba:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8004cbc:	6822      	ldr	r2, [r4, #0]
 8004cbe:	6993      	ldr	r3, [r2, #24]
 8004cc0:	6929      	ldr	r1, [r5, #16]
 8004cc2:	430b      	orrs	r3, r1
 8004cc4:	6193      	str	r3, [r2, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004cc6:	2000      	movs	r0, #0
      break;
 8004cc8:	e06f      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8004cca:	0029      	movs	r1, r5
 8004ccc:	6800      	ldr	r0, [r0, #0]
 8004cce:	f7ff ff95 	bl	8004bfc <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8004cd2:	6822      	ldr	r2, [r4, #0]
 8004cd4:	6991      	ldr	r1, [r2, #24]
 8004cd6:	2380      	movs	r3, #128	; 0x80
 8004cd8:	011b      	lsls	r3, r3, #4
 8004cda:	430b      	orrs	r3, r1
 8004cdc:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 8004cde:	6822      	ldr	r2, [r4, #0]
 8004ce0:	6993      	ldr	r3, [r2, #24]
 8004ce2:	4936      	ldr	r1, [pc, #216]	; (8004dbc <HAL_TIM_PWM_ConfigChannel+0x140>)
 8004ce4:	400b      	ands	r3, r1
 8004ce6:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 8004ce8:	6821      	ldr	r1, [r4, #0]
 8004cea:	698b      	ldr	r3, [r1, #24]
 8004cec:	692a      	ldr	r2, [r5, #16]
 8004cee:	0212      	lsls	r2, r2, #8
 8004cf0:	4313      	orrs	r3, r2
 8004cf2:	618b      	str	r3, [r1, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004cf4:	2000      	movs	r0, #0
      break;
 8004cf6:	e058      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 8004cf8:	0029      	movs	r1, r5
 8004cfa:	6800      	ldr	r0, [r0, #0]
 8004cfc:	f7ff fd84 	bl	8004808 <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 8004d00:	6822      	ldr	r2, [r4, #0]
 8004d02:	69d3      	ldr	r3, [r2, #28]
 8004d04:	2108      	movs	r1, #8
 8004d06:	430b      	orrs	r3, r1
 8004d08:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 8004d0a:	6822      	ldr	r2, [r4, #0]
 8004d0c:	69d3      	ldr	r3, [r2, #28]
 8004d0e:	3904      	subs	r1, #4
 8004d10:	438b      	bics	r3, r1
 8004d12:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 8004d14:	6822      	ldr	r2, [r4, #0]
 8004d16:	69d3      	ldr	r3, [r2, #28]
 8004d18:	6929      	ldr	r1, [r5, #16]
 8004d1a:	430b      	orrs	r3, r1
 8004d1c:	61d3      	str	r3, [r2, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004d1e:	2000      	movs	r0, #0
      break;
 8004d20:	e043      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8004d22:	0029      	movs	r1, r5
 8004d24:	6800      	ldr	r0, [r0, #0]
 8004d26:	f7ff fdb5 	bl	8004894 <TIM_OC4_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8004d2a:	6822      	ldr	r2, [r4, #0]
 8004d2c:	69d1      	ldr	r1, [r2, #28]
 8004d2e:	2380      	movs	r3, #128	; 0x80
 8004d30:	011b      	lsls	r3, r3, #4
 8004d32:	430b      	orrs	r3, r1
 8004d34:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8004d36:	6822      	ldr	r2, [r4, #0]
 8004d38:	69d3      	ldr	r3, [r2, #28]
 8004d3a:	4920      	ldr	r1, [pc, #128]	; (8004dbc <HAL_TIM_PWM_ConfigChannel+0x140>)
 8004d3c:	400b      	ands	r3, r1
 8004d3e:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8004d40:	6821      	ldr	r1, [r4, #0]
 8004d42:	69cb      	ldr	r3, [r1, #28]
 8004d44:	692a      	ldr	r2, [r5, #16]
 8004d46:	0212      	lsls	r2, r2, #8
 8004d48:	4313      	orrs	r3, r2
 8004d4a:	61cb      	str	r3, [r1, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004d4c:	2000      	movs	r0, #0
      break;
 8004d4e:	e02c      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8004d50:	0029      	movs	r1, r5
 8004d52:	6800      	ldr	r0, [r0, #0]
 8004d54:	f7ff fdd2 	bl	80048fc <TIM_OC5_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8004d58:	6822      	ldr	r2, [r4, #0]
 8004d5a:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004d5c:	2108      	movs	r1, #8
 8004d5e:	430b      	orrs	r3, r1
 8004d60:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8004d62:	6822      	ldr	r2, [r4, #0]
 8004d64:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004d66:	3904      	subs	r1, #4
 8004d68:	438b      	bics	r3, r1
 8004d6a:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8004d6c:	6822      	ldr	r2, [r4, #0]
 8004d6e:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004d70:	6929      	ldr	r1, [r5, #16]
 8004d72:	430b      	orrs	r3, r1
 8004d74:	6553      	str	r3, [r2, #84]	; 0x54
  HAL_StatusTypeDef status = HAL_OK;
 8004d76:	2000      	movs	r0, #0
      break;
 8004d78:	e017      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8004d7a:	0029      	movs	r1, r5
 8004d7c:	6800      	ldr	r0, [r0, #0]
 8004d7e:	f7ff fdef 	bl	8004960 <TIM_OC6_SetConfig>
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8004d82:	6822      	ldr	r2, [r4, #0]
 8004d84:	6d51      	ldr	r1, [r2, #84]	; 0x54
 8004d86:	2380      	movs	r3, #128	; 0x80
 8004d88:	011b      	lsls	r3, r3, #4
 8004d8a:	430b      	orrs	r3, r1
 8004d8c:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 8004d8e:	6822      	ldr	r2, [r4, #0]
 8004d90:	6d53      	ldr	r3, [r2, #84]	; 0x54
 8004d92:	490a      	ldr	r1, [pc, #40]	; (8004dbc <HAL_TIM_PWM_ConfigChannel+0x140>)
 8004d94:	400b      	ands	r3, r1
 8004d96:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 8004d98:	6821      	ldr	r1, [r4, #0]
 8004d9a:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 8004d9c:	692a      	ldr	r2, [r5, #16]
 8004d9e:	0212      	lsls	r2, r2, #8
 8004da0:	4313      	orrs	r3, r2
 8004da2:	654b      	str	r3, [r1, #84]	; 0x54
  HAL_StatusTypeDef status = HAL_OK;
 8004da4:	2000      	movs	r0, #0
      break;
 8004da6:	e000      	b.n	8004daa <HAL_TIM_PWM_ConfigChannel+0x12e>
  switch (Channel)
 8004da8:	2001      	movs	r0, #1
  __HAL_UNLOCK(htim);
 8004daa:	233c      	movs	r3, #60	; 0x3c
 8004dac:	2200      	movs	r2, #0
 8004dae:	54e2      	strb	r2, [r4, r3]
}
 8004db0:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_LOCK(htim);
 8004db2:	2002      	movs	r0, #2
 8004db4:	e7fc      	b.n	8004db0 <HAL_TIM_PWM_ConfigChannel+0x134>
 8004db6:	46c0      	nop			; (mov r8, r8)
 8004db8:	08006560 	.word	0x08006560
 8004dbc:	fffffbff 	.word	0xfffffbff

08004dc0 <TIM_TI1_SetConfig>:
{
 8004dc0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004dc2:	0017      	movs	r7, r2
 8004dc4:	001d      	movs	r5, r3
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8004dc6:	6a03      	ldr	r3, [r0, #32]
 8004dc8:	2201      	movs	r2, #1
 8004dca:	4393      	bics	r3, r2
 8004dcc:	6203      	str	r3, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004dce:	6982      	ldr	r2, [r0, #24]
  tmpccer = TIMx->CCER;
 8004dd0:	6a06      	ldr	r6, [r0, #32]
  if (IS_TIM_CC2_INSTANCE(TIMx) != RESET)
 8004dd2:	4b0c      	ldr	r3, [pc, #48]	; (8004e04 <TIM_TI1_SetConfig+0x44>)
 8004dd4:	4298      	cmp	r0, r3
 8004dd6:	d005      	beq.n	8004de4 <TIM_TI1_SetConfig+0x24>
 8004dd8:	4b0b      	ldr	r3, [pc, #44]	; (8004e08 <TIM_TI1_SetConfig+0x48>)
 8004dda:	4298      	cmp	r0, r3
 8004ddc:	d002      	beq.n	8004de4 <TIM_TI1_SetConfig+0x24>
    tmpccmr1 |= TIM_CCMR1_CC1S_0;
 8004dde:	2301      	movs	r3, #1
 8004de0:	431a      	orrs	r2, r3
 8004de2:	e002      	b.n	8004dea <TIM_TI1_SetConfig+0x2a>
    tmpccmr1 &= ~TIM_CCMR1_CC1S;
 8004de4:	2303      	movs	r3, #3
 8004de6:	439a      	bics	r2, r3
    tmpccmr1 |= TIM_ICSelection;
 8004de8:	433a      	orrs	r2, r7
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8004dea:	23f0      	movs	r3, #240	; 0xf0
 8004dec:	439a      	bics	r2, r3
  tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
 8004dee:	012d      	lsls	r5, r5, #4
 8004df0:	24ff      	movs	r4, #255	; 0xff
 8004df2:	402c      	ands	r4, r5
 8004df4:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8004df6:	3be6      	subs	r3, #230	; 0xe6
 8004df8:	439e      	bics	r6, r3
  tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
 8004dfa:	400b      	ands	r3, r1
 8004dfc:	4333      	orrs	r3, r6
  TIMx->CCMR1 = tmpccmr1;
 8004dfe:	6182      	str	r2, [r0, #24]
  TIMx->CCER = tmpccer;
 8004e00:	6203      	str	r3, [r0, #32]
}
 8004e02:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004e04:	40012c00 	.word	0x40012c00
 8004e08:	40000400 	.word	0x40000400

08004e0c <HAL_TIM_IC_ConfigChannel>:
{
 8004e0c:	b570      	push	{r4, r5, r6, lr}
 8004e0e:	0004      	movs	r4, r0
 8004e10:	000d      	movs	r5, r1
  __HAL_LOCK(htim);
 8004e12:	233c      	movs	r3, #60	; 0x3c
 8004e14:	5cc3      	ldrb	r3, [r0, r3]
 8004e16:	2b01      	cmp	r3, #1
 8004e18:	d059      	beq.n	8004ece <HAL_TIM_IC_ConfigChannel+0xc2>
 8004e1a:	233c      	movs	r3, #60	; 0x3c
 8004e1c:	2101      	movs	r1, #1
 8004e1e:	54c1      	strb	r1, [r0, r3]
  if (Channel == TIM_CHANNEL_1)
 8004e20:	2a00      	cmp	r2, #0
 8004e22:	d00a      	beq.n	8004e3a <HAL_TIM_IC_ConfigChannel+0x2e>
  else if (Channel == TIM_CHANNEL_2)
 8004e24:	2a04      	cmp	r2, #4
 8004e26:	d01a      	beq.n	8004e5e <HAL_TIM_IC_ConfigChannel+0x52>
  else if (Channel == TIM_CHANNEL_3)
 8004e28:	2a08      	cmp	r2, #8
 8004e2a:	d02b      	beq.n	8004e84 <HAL_TIM_IC_ConfigChannel+0x78>
  else if (Channel == TIM_CHANNEL_4)
 8004e2c:	2a0c      	cmp	r2, #12
 8004e2e:	d03b      	beq.n	8004ea8 <HAL_TIM_IC_ConfigChannel+0x9c>
    status = HAL_ERROR;
 8004e30:	2001      	movs	r0, #1
  __HAL_UNLOCK(htim);
 8004e32:	233c      	movs	r3, #60	; 0x3c
 8004e34:	2200      	movs	r2, #0
 8004e36:	54e2      	strb	r2, [r4, r3]
}
 8004e38:	bd70      	pop	{r4, r5, r6, pc}
    TIM_TI1_SetConfig(htim->Instance,
 8004e3a:	68eb      	ldr	r3, [r5, #12]
 8004e3c:	686a      	ldr	r2, [r5, #4]
 8004e3e:	6829      	ldr	r1, [r5, #0]
 8004e40:	6800      	ldr	r0, [r0, #0]
 8004e42:	f7ff ffbd 	bl	8004dc0 <TIM_TI1_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
 8004e46:	6822      	ldr	r2, [r4, #0]
 8004e48:	6993      	ldr	r3, [r2, #24]
 8004e4a:	210c      	movs	r1, #12
 8004e4c:	438b      	bics	r3, r1
 8004e4e:	6193      	str	r3, [r2, #24]
    htim->Instance->CCMR1 |= sConfig->ICPrescaler;
 8004e50:	6822      	ldr	r2, [r4, #0]
 8004e52:	6993      	ldr	r3, [r2, #24]
 8004e54:	68a9      	ldr	r1, [r5, #8]
 8004e56:	430b      	orrs	r3, r1
 8004e58:	6193      	str	r3, [r2, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004e5a:	2000      	movs	r0, #0
 8004e5c:	e7e9      	b.n	8004e32 <HAL_TIM_IC_ConfigChannel+0x26>
    TIM_TI2_SetConfig(htim->Instance,
 8004e5e:	68eb      	ldr	r3, [r5, #12]
 8004e60:	686a      	ldr	r2, [r5, #4]
 8004e62:	6829      	ldr	r1, [r5, #0]
 8004e64:	6800      	ldr	r0, [r0, #0]
 8004e66:	f7ff fdaf 	bl	80049c8 <TIM_TI2_SetConfig>
    htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
 8004e6a:	6822      	ldr	r2, [r4, #0]
 8004e6c:	6993      	ldr	r3, [r2, #24]
 8004e6e:	4919      	ldr	r1, [pc, #100]	; (8004ed4 <HAL_TIM_IC_ConfigChannel+0xc8>)
 8004e70:	400b      	ands	r3, r1
 8004e72:	6193      	str	r3, [r2, #24]
    htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
 8004e74:	6821      	ldr	r1, [r4, #0]
 8004e76:	698b      	ldr	r3, [r1, #24]
 8004e78:	68aa      	ldr	r2, [r5, #8]
 8004e7a:	0212      	lsls	r2, r2, #8
 8004e7c:	4313      	orrs	r3, r2
 8004e7e:	618b      	str	r3, [r1, #24]
  HAL_StatusTypeDef status = HAL_OK;
 8004e80:	2000      	movs	r0, #0
 8004e82:	e7d6      	b.n	8004e32 <HAL_TIM_IC_ConfigChannel+0x26>
    TIM_TI3_SetConfig(htim->Instance,
 8004e84:	68eb      	ldr	r3, [r5, #12]
 8004e86:	686a      	ldr	r2, [r5, #4]
 8004e88:	6829      	ldr	r1, [r5, #0]
 8004e8a:	6800      	ldr	r0, [r0, #0]
 8004e8c:	f7ff fdb8 	bl	8004a00 <TIM_TI3_SetConfig>
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
 8004e90:	6822      	ldr	r2, [r4, #0]
 8004e92:	69d3      	ldr	r3, [r2, #28]
 8004e94:	210c      	movs	r1, #12
 8004e96:	438b      	bics	r3, r1
 8004e98:	61d3      	str	r3, [r2, #28]
    htim->Instance->CCMR2 |= sConfig->ICPrescaler;
 8004e9a:	6822      	ldr	r2, [r4, #0]
 8004e9c:	69d3      	ldr	r3, [r2, #28]
 8004e9e:	68a9      	ldr	r1, [r5, #8]
 8004ea0:	430b      	orrs	r3, r1
 8004ea2:	61d3      	str	r3, [r2, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004ea4:	2000      	movs	r0, #0
 8004ea6:	e7c4      	b.n	8004e32 <HAL_TIM_IC_ConfigChannel+0x26>
    TIM_TI4_SetConfig(htim->Instance,
 8004ea8:	68eb      	ldr	r3, [r5, #12]
 8004eaa:	686a      	ldr	r2, [r5, #4]
 8004eac:	6829      	ldr	r1, [r5, #0]
 8004eae:	6800      	ldr	r0, [r0, #0]
 8004eb0:	f7ff fdc4 	bl	8004a3c <TIM_TI4_SetConfig>
    htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
 8004eb4:	6822      	ldr	r2, [r4, #0]
 8004eb6:	69d3      	ldr	r3, [r2, #28]
 8004eb8:	4906      	ldr	r1, [pc, #24]	; (8004ed4 <HAL_TIM_IC_ConfigChannel+0xc8>)
 8004eba:	400b      	ands	r3, r1
 8004ebc:	61d3      	str	r3, [r2, #28]
    htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
 8004ebe:	6821      	ldr	r1, [r4, #0]
 8004ec0:	69cb      	ldr	r3, [r1, #28]
 8004ec2:	68aa      	ldr	r2, [r5, #8]
 8004ec4:	0212      	lsls	r2, r2, #8
 8004ec6:	4313      	orrs	r3, r2
 8004ec8:	61cb      	str	r3, [r1, #28]
  HAL_StatusTypeDef status = HAL_OK;
 8004eca:	2000      	movs	r0, #0
 8004ecc:	e7b1      	b.n	8004e32 <HAL_TIM_IC_ConfigChannel+0x26>
  __HAL_LOCK(htim);
 8004ece:	2002      	movs	r0, #2
 8004ed0:	e7b2      	b.n	8004e38 <HAL_TIM_IC_ConfigChannel+0x2c>
 8004ed2:	46c0      	nop			; (mov r8, r8)
 8004ed4:	fffff3ff 	.word	0xfffff3ff

08004ed8 <TIM_CCxChannelCmd>:
  * @param  ChannelState specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_DISABLE.
  * @retval None
  */
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
 8004ed8:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
  assert_param(IS_TIM_CHANNELS(Channel));

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 8004eda:	231f      	movs	r3, #31
 8004edc:	4019      	ands	r1, r3
 8004ede:	2401      	movs	r4, #1
 8004ee0:	408c      	lsls	r4, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 8004ee2:	6a03      	ldr	r3, [r0, #32]
 8004ee4:	43a3      	bics	r3, r4
 8004ee6:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 8004ee8:	6a03      	ldr	r3, [r0, #32]
 8004eea:	408a      	lsls	r2, r1
 8004eec:	4313      	orrs	r3, r2
 8004eee:	6203      	str	r3, [r0, #32]
}
 8004ef0:	bd10      	pop	{r4, pc}
	...

08004ef4 <HAL_TIM_PWM_Start>:
{
 8004ef4:	b510      	push	{r4, lr}
 8004ef6:	0004      	movs	r4, r0
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8004ef8:	2900      	cmp	r1, #0
 8004efa:	d12c      	bne.n	8004f56 <HAL_TIM_PWM_Start+0x62>
 8004efc:	233e      	movs	r3, #62	; 0x3e
 8004efe:	5cc3      	ldrb	r3, [r0, r3]
 8004f00:	3b01      	subs	r3, #1
 8004f02:	1e5a      	subs	r2, r3, #1
 8004f04:	4193      	sbcs	r3, r2
 8004f06:	b2db      	uxtb	r3, r3
 8004f08:	2b00      	cmp	r3, #0
 8004f0a:	d179      	bne.n	8005000 <HAL_TIM_PWM_Start+0x10c>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8004f0c:	2900      	cmp	r1, #0
 8004f0e:	d14d      	bne.n	8004fac <HAL_TIM_PWM_Start+0xb8>
 8004f10:	333e      	adds	r3, #62	; 0x3e
 8004f12:	2202      	movs	r2, #2
 8004f14:	54e2      	strb	r2, [r4, r3]
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8004f16:	2201      	movs	r2, #1
 8004f18:	6820      	ldr	r0, [r4, #0]
 8004f1a:	f7ff ffdd 	bl	8004ed8 <TIM_CCxChannelCmd>
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 8004f1e:	6823      	ldr	r3, [r4, #0]
 8004f20:	4a3a      	ldr	r2, [pc, #232]	; (800500c <HAL_TIM_PWM_Start+0x118>)
 8004f22:	4293      	cmp	r3, r2
 8004f24:	d005      	beq.n	8004f32 <HAL_TIM_PWM_Start+0x3e>
 8004f26:	4a3a      	ldr	r2, [pc, #232]	; (8005010 <HAL_TIM_PWM_Start+0x11c>)
 8004f28:	4293      	cmp	r3, r2
 8004f2a:	d002      	beq.n	8004f32 <HAL_TIM_PWM_Start+0x3e>
 8004f2c:	4a39      	ldr	r2, [pc, #228]	; (8005014 <HAL_TIM_PWM_Start+0x120>)
 8004f2e:	4293      	cmp	r3, r2
 8004f30:	d104      	bne.n	8004f3c <HAL_TIM_PWM_Start+0x48>
    __HAL_TIM_MOE_ENABLE(htim);
 8004f32:	6c59      	ldr	r1, [r3, #68]	; 0x44
 8004f34:	2280      	movs	r2, #128	; 0x80
 8004f36:	0212      	lsls	r2, r2, #8
 8004f38:	430a      	orrs	r2, r1
 8004f3a:	645a      	str	r2, [r3, #68]	; 0x44
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8004f3c:	6823      	ldr	r3, [r4, #0]
 8004f3e:	4a33      	ldr	r2, [pc, #204]	; (800500c <HAL_TIM_PWM_Start+0x118>)
 8004f40:	4293      	cmp	r3, r2
 8004f42:	d04f      	beq.n	8004fe4 <HAL_TIM_PWM_Start+0xf0>
 8004f44:	4a34      	ldr	r2, [pc, #208]	; (8005018 <HAL_TIM_PWM_Start+0x124>)
 8004f46:	4293      	cmp	r3, r2
 8004f48:	d04c      	beq.n	8004fe4 <HAL_TIM_PWM_Start+0xf0>
    __HAL_TIM_ENABLE(htim);
 8004f4a:	681a      	ldr	r2, [r3, #0]
 8004f4c:	2101      	movs	r1, #1
 8004f4e:	430a      	orrs	r2, r1
 8004f50:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004f52:	2000      	movs	r0, #0
 8004f54:	e055      	b.n	8005002 <HAL_TIM_PWM_Start+0x10e>
  if (TIM_CHANNEL_STATE_GET(htim, Channel) != HAL_TIM_CHANNEL_STATE_READY)
 8004f56:	2904      	cmp	r1, #4
 8004f58:	d00c      	beq.n	8004f74 <HAL_TIM_PWM_Start+0x80>
 8004f5a:	2908      	cmp	r1, #8
 8004f5c:	d011      	beq.n	8004f82 <HAL_TIM_PWM_Start+0x8e>
 8004f5e:	290c      	cmp	r1, #12
 8004f60:	d016      	beq.n	8004f90 <HAL_TIM_PWM_Start+0x9c>
 8004f62:	2910      	cmp	r1, #16
 8004f64:	d01b      	beq.n	8004f9e <HAL_TIM_PWM_Start+0xaa>
 8004f66:	2343      	movs	r3, #67	; 0x43
 8004f68:	5cc3      	ldrb	r3, [r0, r3]
 8004f6a:	3b01      	subs	r3, #1
 8004f6c:	1e5a      	subs	r2, r3, #1
 8004f6e:	4193      	sbcs	r3, r2
 8004f70:	b2db      	uxtb	r3, r3
 8004f72:	e7c9      	b.n	8004f08 <HAL_TIM_PWM_Start+0x14>
 8004f74:	233f      	movs	r3, #63	; 0x3f
 8004f76:	5cc3      	ldrb	r3, [r0, r3]
 8004f78:	3b01      	subs	r3, #1
 8004f7a:	1e5a      	subs	r2, r3, #1
 8004f7c:	4193      	sbcs	r3, r2
 8004f7e:	b2db      	uxtb	r3, r3
 8004f80:	e7c2      	b.n	8004f08 <HAL_TIM_PWM_Start+0x14>
 8004f82:	2340      	movs	r3, #64	; 0x40
 8004f84:	5cc3      	ldrb	r3, [r0, r3]
 8004f86:	3b01      	subs	r3, #1
 8004f88:	1e5a      	subs	r2, r3, #1
 8004f8a:	4193      	sbcs	r3, r2
 8004f8c:	b2db      	uxtb	r3, r3
 8004f8e:	e7bb      	b.n	8004f08 <HAL_TIM_PWM_Start+0x14>
 8004f90:	2341      	movs	r3, #65	; 0x41
 8004f92:	5cc3      	ldrb	r3, [r0, r3]
 8004f94:	3b01      	subs	r3, #1
 8004f96:	1e5a      	subs	r2, r3, #1
 8004f98:	4193      	sbcs	r3, r2
 8004f9a:	b2db      	uxtb	r3, r3
 8004f9c:	e7b4      	b.n	8004f08 <HAL_TIM_PWM_Start+0x14>
 8004f9e:	2342      	movs	r3, #66	; 0x42
 8004fa0:	5cc3      	ldrb	r3, [r0, r3]
 8004fa2:	3b01      	subs	r3, #1
 8004fa4:	1e5a      	subs	r2, r3, #1
 8004fa6:	4193      	sbcs	r3, r2
 8004fa8:	b2db      	uxtb	r3, r3
 8004faa:	e7ad      	b.n	8004f08 <HAL_TIM_PWM_Start+0x14>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8004fac:	2904      	cmp	r1, #4
 8004fae:	d009      	beq.n	8004fc4 <HAL_TIM_PWM_Start+0xd0>
 8004fb0:	2908      	cmp	r1, #8
 8004fb2:	d00b      	beq.n	8004fcc <HAL_TIM_PWM_Start+0xd8>
 8004fb4:	290c      	cmp	r1, #12
 8004fb6:	d00d      	beq.n	8004fd4 <HAL_TIM_PWM_Start+0xe0>
 8004fb8:	2910      	cmp	r1, #16
 8004fba:	d00f      	beq.n	8004fdc <HAL_TIM_PWM_Start+0xe8>
 8004fbc:	2343      	movs	r3, #67	; 0x43
 8004fbe:	2202      	movs	r2, #2
 8004fc0:	54e2      	strb	r2, [r4, r3]
 8004fc2:	e7a8      	b.n	8004f16 <HAL_TIM_PWM_Start+0x22>
 8004fc4:	233f      	movs	r3, #63	; 0x3f
 8004fc6:	2202      	movs	r2, #2
 8004fc8:	54e2      	strb	r2, [r4, r3]
 8004fca:	e7a4      	b.n	8004f16 <HAL_TIM_PWM_Start+0x22>
 8004fcc:	2340      	movs	r3, #64	; 0x40
 8004fce:	2202      	movs	r2, #2
 8004fd0:	54e2      	strb	r2, [r4, r3]
 8004fd2:	e7a0      	b.n	8004f16 <HAL_TIM_PWM_Start+0x22>
 8004fd4:	2341      	movs	r3, #65	; 0x41
 8004fd6:	2202      	movs	r2, #2
 8004fd8:	54e2      	strb	r2, [r4, r3]
 8004fda:	e79c      	b.n	8004f16 <HAL_TIM_PWM_Start+0x22>
 8004fdc:	2342      	movs	r3, #66	; 0x42
 8004fde:	2202      	movs	r2, #2
 8004fe0:	54e2      	strb	r2, [r4, r3]
 8004fe2:	e798      	b.n	8004f16 <HAL_TIM_PWM_Start+0x22>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8004fe4:	689a      	ldr	r2, [r3, #8]
 8004fe6:	490d      	ldr	r1, [pc, #52]	; (800501c <HAL_TIM_PWM_Start+0x128>)
 8004fe8:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8004fea:	2a06      	cmp	r2, #6
 8004fec:	d00a      	beq.n	8005004 <HAL_TIM_PWM_Start+0x110>
 8004fee:	3907      	subs	r1, #7
 8004ff0:	428a      	cmp	r2, r1
 8004ff2:	d009      	beq.n	8005008 <HAL_TIM_PWM_Start+0x114>
      __HAL_TIM_ENABLE(htim);
 8004ff4:	681a      	ldr	r2, [r3, #0]
 8004ff6:	2101      	movs	r1, #1
 8004ff8:	430a      	orrs	r2, r1
 8004ffa:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8004ffc:	2000      	movs	r0, #0
 8004ffe:	e000      	b.n	8005002 <HAL_TIM_PWM_Start+0x10e>
    return HAL_ERROR;
 8005000:	2001      	movs	r0, #1
}
 8005002:	bd10      	pop	{r4, pc}
  return HAL_OK;
 8005004:	2000      	movs	r0, #0
 8005006:	e7fc      	b.n	8005002 <HAL_TIM_PWM_Start+0x10e>
 8005008:	2000      	movs	r0, #0
 800500a:	e7fa      	b.n	8005002 <HAL_TIM_PWM_Start+0x10e>
 800500c:	40012c00 	.word	0x40012c00
 8005010:	40014400 	.word	0x40014400
 8005014:	40014800 	.word	0x40014800
 8005018:	40000400 	.word	0x40000400
 800501c:	00010007 	.word	0x00010007

08005020 <HAL_TIM_IC_Start_IT>:
{
 8005020:	b510      	push	{r4, lr}
 8005022:	0004      	movs	r4, r0
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8005024:	2900      	cmp	r1, #0
 8005026:	d125      	bne.n	8005074 <HAL_TIM_IC_Start_IT+0x54>
 8005028:	233e      	movs	r3, #62	; 0x3e
 800502a:	5cc0      	ldrb	r0, [r0, r3]
 800502c:	b2c0      	uxtb	r0, r0
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 800502e:	2900      	cmp	r1, #0
 8005030:	d13c      	bne.n	80050ac <HAL_TIM_IC_Start_IT+0x8c>
 8005032:	2344      	movs	r3, #68	; 0x44
 8005034:	5ce3      	ldrb	r3, [r4, r3]
 8005036:	b2db      	uxtb	r3, r3
  if ((channel_state != HAL_TIM_CHANNEL_STATE_READY)
 8005038:	2801      	cmp	r0, #1
 800503a:	d000      	beq.n	800503e <HAL_TIM_IC_Start_IT+0x1e>
 800503c:	e0a8      	b.n	8005190 <HAL_TIM_IC_Start_IT+0x170>
      || (complementary_channel_state != HAL_TIM_CHANNEL_STATE_READY))
 800503e:	2b01      	cmp	r3, #1
 8005040:	d000      	beq.n	8005044 <HAL_TIM_IC_Start_IT+0x24>
 8005042:	e0a6      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8005044:	2900      	cmp	r1, #0
 8005046:	d141      	bne.n	80050cc <HAL_TIM_IC_Start_IT+0xac>
 8005048:	223e      	movs	r2, #62	; 0x3e
 800504a:	3001      	adds	r0, #1
 800504c:	54a0      	strb	r0, [r4, r2]
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 800504e:	2900      	cmp	r1, #0
 8005050:	d158      	bne.n	8005104 <HAL_TIM_IC_Start_IT+0xe4>
 8005052:	2244      	movs	r2, #68	; 0x44
 8005054:	2002      	movs	r0, #2
 8005056:	54a0      	strb	r0, [r4, r2]
  switch (Channel)
 8005058:	2908      	cmp	r1, #8
 800505a:	d100      	bne.n	800505e <HAL_TIM_IC_Start_IT+0x3e>
 800505c:	e084      	b.n	8005168 <HAL_TIM_IC_Start_IT+0x148>
 800505e:	d863      	bhi.n	8005128 <HAL_TIM_IC_Start_IT+0x108>
 8005060:	2900      	cmp	r1, #0
 8005062:	d06b      	beq.n	800513c <HAL_TIM_IC_Start_IT+0x11c>
 8005064:	2904      	cmp	r1, #4
 8005066:	d15d      	bne.n	8005124 <HAL_TIM_IC_Start_IT+0x104>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
 8005068:	6822      	ldr	r2, [r4, #0]
 800506a:	68d3      	ldr	r3, [r2, #12]
 800506c:	2004      	movs	r0, #4
 800506e:	4303      	orrs	r3, r0
 8005070:	60d3      	str	r3, [r2, #12]
  if (status == HAL_OK)
 8005072:	e068      	b.n	8005146 <HAL_TIM_IC_Start_IT+0x126>
  HAL_TIM_ChannelStateTypeDef channel_state = TIM_CHANNEL_STATE_GET(htim, Channel);
 8005074:	2904      	cmp	r1, #4
 8005076:	d009      	beq.n	800508c <HAL_TIM_IC_Start_IT+0x6c>
 8005078:	2908      	cmp	r1, #8
 800507a:	d00b      	beq.n	8005094 <HAL_TIM_IC_Start_IT+0x74>
 800507c:	290c      	cmp	r1, #12
 800507e:	d00d      	beq.n	800509c <HAL_TIM_IC_Start_IT+0x7c>
 8005080:	2910      	cmp	r1, #16
 8005082:	d00f      	beq.n	80050a4 <HAL_TIM_IC_Start_IT+0x84>
 8005084:	2343      	movs	r3, #67	; 0x43
 8005086:	5cc0      	ldrb	r0, [r0, r3]
 8005088:	b2c0      	uxtb	r0, r0
 800508a:	e7d0      	b.n	800502e <HAL_TIM_IC_Start_IT+0xe>
 800508c:	233f      	movs	r3, #63	; 0x3f
 800508e:	5cc0      	ldrb	r0, [r0, r3]
 8005090:	b2c0      	uxtb	r0, r0
 8005092:	e7cc      	b.n	800502e <HAL_TIM_IC_Start_IT+0xe>
 8005094:	2340      	movs	r3, #64	; 0x40
 8005096:	5cc0      	ldrb	r0, [r0, r3]
 8005098:	b2c0      	uxtb	r0, r0
 800509a:	e7c8      	b.n	800502e <HAL_TIM_IC_Start_IT+0xe>
 800509c:	2341      	movs	r3, #65	; 0x41
 800509e:	5cc0      	ldrb	r0, [r0, r3]
 80050a0:	b2c0      	uxtb	r0, r0
 80050a2:	e7c4      	b.n	800502e <HAL_TIM_IC_Start_IT+0xe>
 80050a4:	2342      	movs	r3, #66	; 0x42
 80050a6:	5cc0      	ldrb	r0, [r0, r3]
 80050a8:	b2c0      	uxtb	r0, r0
 80050aa:	e7c0      	b.n	800502e <HAL_TIM_IC_Start_IT+0xe>
  HAL_TIM_ChannelStateTypeDef complementary_channel_state = TIM_CHANNEL_N_STATE_GET(htim, Channel);
 80050ac:	2904      	cmp	r1, #4
 80050ae:	d005      	beq.n	80050bc <HAL_TIM_IC_Start_IT+0x9c>
 80050b0:	2908      	cmp	r1, #8
 80050b2:	d007      	beq.n	80050c4 <HAL_TIM_IC_Start_IT+0xa4>
 80050b4:	2347      	movs	r3, #71	; 0x47
 80050b6:	5ce3      	ldrb	r3, [r4, r3]
 80050b8:	b2db      	uxtb	r3, r3
 80050ba:	e7bd      	b.n	8005038 <HAL_TIM_IC_Start_IT+0x18>
 80050bc:	2345      	movs	r3, #69	; 0x45
 80050be:	5ce3      	ldrb	r3, [r4, r3]
 80050c0:	b2db      	uxtb	r3, r3
 80050c2:	e7b9      	b.n	8005038 <HAL_TIM_IC_Start_IT+0x18>
 80050c4:	2346      	movs	r3, #70	; 0x46
 80050c6:	5ce3      	ldrb	r3, [r4, r3]
 80050c8:	b2db      	uxtb	r3, r3
 80050ca:	e7b5      	b.n	8005038 <HAL_TIM_IC_Start_IT+0x18>
  TIM_CHANNEL_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 80050cc:	2904      	cmp	r1, #4
 80050ce:	d009      	beq.n	80050e4 <HAL_TIM_IC_Start_IT+0xc4>
 80050d0:	2908      	cmp	r1, #8
 80050d2:	d00b      	beq.n	80050ec <HAL_TIM_IC_Start_IT+0xcc>
 80050d4:	290c      	cmp	r1, #12
 80050d6:	d00d      	beq.n	80050f4 <HAL_TIM_IC_Start_IT+0xd4>
 80050d8:	2910      	cmp	r1, #16
 80050da:	d00f      	beq.n	80050fc <HAL_TIM_IC_Start_IT+0xdc>
 80050dc:	2243      	movs	r2, #67	; 0x43
 80050de:	2002      	movs	r0, #2
 80050e0:	54a0      	strb	r0, [r4, r2]
 80050e2:	e7b4      	b.n	800504e <HAL_TIM_IC_Start_IT+0x2e>
 80050e4:	223f      	movs	r2, #63	; 0x3f
 80050e6:	2002      	movs	r0, #2
 80050e8:	54a0      	strb	r0, [r4, r2]
 80050ea:	e7b0      	b.n	800504e <HAL_TIM_IC_Start_IT+0x2e>
 80050ec:	2240      	movs	r2, #64	; 0x40
 80050ee:	2002      	movs	r0, #2
 80050f0:	54a0      	strb	r0, [r4, r2]
 80050f2:	e7ac      	b.n	800504e <HAL_TIM_IC_Start_IT+0x2e>
 80050f4:	2241      	movs	r2, #65	; 0x41
 80050f6:	2002      	movs	r0, #2
 80050f8:	54a0      	strb	r0, [r4, r2]
 80050fa:	e7a8      	b.n	800504e <HAL_TIM_IC_Start_IT+0x2e>
 80050fc:	2242      	movs	r2, #66	; 0x42
 80050fe:	2002      	movs	r0, #2
 8005100:	54a0      	strb	r0, [r4, r2]
 8005102:	e7a4      	b.n	800504e <HAL_TIM_IC_Start_IT+0x2e>
  TIM_CHANNEL_N_STATE_SET(htim, Channel, HAL_TIM_CHANNEL_STATE_BUSY);
 8005104:	2904      	cmp	r1, #4
 8005106:	d005      	beq.n	8005114 <HAL_TIM_IC_Start_IT+0xf4>
 8005108:	2908      	cmp	r1, #8
 800510a:	d007      	beq.n	800511c <HAL_TIM_IC_Start_IT+0xfc>
 800510c:	2247      	movs	r2, #71	; 0x47
 800510e:	2002      	movs	r0, #2
 8005110:	54a0      	strb	r0, [r4, r2]
 8005112:	e7a1      	b.n	8005058 <HAL_TIM_IC_Start_IT+0x38>
 8005114:	2245      	movs	r2, #69	; 0x45
 8005116:	2002      	movs	r0, #2
 8005118:	54a0      	strb	r0, [r4, r2]
 800511a:	e79d      	b.n	8005058 <HAL_TIM_IC_Start_IT+0x38>
 800511c:	2246      	movs	r2, #70	; 0x46
 800511e:	2002      	movs	r0, #2
 8005120:	54a0      	strb	r0, [r4, r2]
 8005122:	e799      	b.n	8005058 <HAL_TIM_IC_Start_IT+0x38>
  switch (Channel)
 8005124:	0018      	movs	r0, r3
 8005126:	e034      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
 8005128:	290c      	cmp	r1, #12
 800512a:	d105      	bne.n	8005138 <HAL_TIM_IC_Start_IT+0x118>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
 800512c:	6822      	ldr	r2, [r4, #0]
 800512e:	68d3      	ldr	r3, [r2, #12]
 8005130:	2010      	movs	r0, #16
 8005132:	4303      	orrs	r3, r0
 8005134:	60d3      	str	r3, [r2, #12]
  if (status == HAL_OK)
 8005136:	e006      	b.n	8005146 <HAL_TIM_IC_Start_IT+0x126>
  switch (Channel)
 8005138:	0018      	movs	r0, r3
 800513a:	e02a      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
 800513c:	6822      	ldr	r2, [r4, #0]
 800513e:	68d3      	ldr	r3, [r2, #12]
 8005140:	2002      	movs	r0, #2
 8005142:	4303      	orrs	r3, r0
 8005144:	60d3      	str	r3, [r2, #12]
    TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 8005146:	2201      	movs	r2, #1
 8005148:	6820      	ldr	r0, [r4, #0]
 800514a:	f7ff fec5 	bl	8004ed8 <TIM_CCxChannelCmd>
    if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800514e:	6823      	ldr	r3, [r4, #0]
 8005150:	4a12      	ldr	r2, [pc, #72]	; (800519c <HAL_TIM_IC_Start_IT+0x17c>)
 8005152:	4293      	cmp	r3, r2
 8005154:	d00e      	beq.n	8005174 <HAL_TIM_IC_Start_IT+0x154>
 8005156:	4a12      	ldr	r2, [pc, #72]	; (80051a0 <HAL_TIM_IC_Start_IT+0x180>)
 8005158:	4293      	cmp	r3, r2
 800515a:	d00b      	beq.n	8005174 <HAL_TIM_IC_Start_IT+0x154>
      __HAL_TIM_ENABLE(htim);
 800515c:	681a      	ldr	r2, [r3, #0]
 800515e:	2101      	movs	r1, #1
 8005160:	430a      	orrs	r2, r1
 8005162:	601a      	str	r2, [r3, #0]
 8005164:	2000      	movs	r0, #0
 8005166:	e014      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
      __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
 8005168:	6822      	ldr	r2, [r4, #0]
 800516a:	68d3      	ldr	r3, [r2, #12]
 800516c:	2008      	movs	r0, #8
 800516e:	4303      	orrs	r3, r0
 8005170:	60d3      	str	r3, [r2, #12]
  if (status == HAL_OK)
 8005172:	e7e8      	b.n	8005146 <HAL_TIM_IC_Start_IT+0x126>
      tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8005174:	689a      	ldr	r2, [r3, #8]
 8005176:	490b      	ldr	r1, [pc, #44]	; (80051a4 <HAL_TIM_IC_Start_IT+0x184>)
 8005178:	400a      	ands	r2, r1
      if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800517a:	2a06      	cmp	r2, #6
 800517c:	d00a      	beq.n	8005194 <HAL_TIM_IC_Start_IT+0x174>
 800517e:	3907      	subs	r1, #7
 8005180:	428a      	cmp	r2, r1
 8005182:	d009      	beq.n	8005198 <HAL_TIM_IC_Start_IT+0x178>
        __HAL_TIM_ENABLE(htim);
 8005184:	681a      	ldr	r2, [r3, #0]
 8005186:	2101      	movs	r1, #1
 8005188:	430a      	orrs	r2, r1
 800518a:	601a      	str	r2, [r3, #0]
 800518c:	2000      	movs	r0, #0
 800518e:	e000      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
    return HAL_ERROR;
 8005190:	2001      	movs	r0, #1
}
 8005192:	bd10      	pop	{r4, pc}
 8005194:	2000      	movs	r0, #0
 8005196:	e7fc      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
 8005198:	2000      	movs	r0, #0
 800519a:	e7fa      	b.n	8005192 <HAL_TIM_IC_Start_IT+0x172>
 800519c:	40012c00 	.word	0x40012c00
 80051a0:	40000400 	.word	0x40000400
 80051a4:	00010007 	.word	0x00010007

080051a8 <RCC_GetSystemClockFreq>:
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_LSI
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_STATUS_LSE
  */
__STATIC_INLINE uint32_t LL_RCC_GetSysClkSource(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80051a8:	4b07      	ldr	r3, [pc, #28]	; (80051c8 <RCC_GetSystemClockFreq+0x20>)
 80051aa:	689a      	ldr	r2, [r3, #8]
 80051ac:	2338      	movs	r3, #56	; 0x38
 80051ae:	4013      	ands	r3, r2
{
  uint32_t frequency;
  uint32_t hsidiv;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (LL_RCC_GetSysClkSource())
 80051b0:	2b08      	cmp	r3, #8
 80051b2:	d007      	beq.n	80051c4 <RCC_GetSystemClockFreq+0x1c>
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      frequency = HSE_VALUE;
      break;
    case LL_RCC_SYS_CLKSOURCE_STATUS_HSI:  /* HSI used as system clock  source */
    default:
      hsidiv = (1UL << ((READ_BIT(RCC->CR, RCC_CR_HSIDIV)) >> RCC_CR_HSIDIV_Pos));
 80051b4:	4b04      	ldr	r3, [pc, #16]	; (80051c8 <RCC_GetSystemClockFreq+0x20>)
 80051b6:	681a      	ldr	r2, [r3, #0]
 80051b8:	0ad2      	lsrs	r2, r2, #11
 80051ba:	2307      	movs	r3, #7
 80051bc:	4013      	ands	r3, r2
      frequency = (HSI_VALUE / hsidiv);
 80051be:	4803      	ldr	r0, [pc, #12]	; (80051cc <RCC_GetSystemClockFreq+0x24>)
 80051c0:	40d8      	lsrs	r0, r3
      break;
  }

  return frequency;
}
 80051c2:	4770      	bx	lr
      frequency = HSE_VALUE;
 80051c4:	4802      	ldr	r0, [pc, #8]	; (80051d0 <RCC_GetSystemClockFreq+0x28>)
  return frequency;
 80051c6:	e7fc      	b.n	80051c2 <RCC_GetSystemClockFreq+0x1a>
 80051c8:	40021000 	.word	0x40021000
 80051cc:	02dc6c00 	.word	0x02dc6c00
 80051d0:	007a1200 	.word	0x007a1200

080051d4 <RCC_GetHCLKClockFreq>:
  * @retval Returned value can be one of the following values:
  *         @arg @ref LL_RCC_SYSCLK_DIV_1
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 80051d4:	4b05      	ldr	r3, [pc, #20]	; (80051ec <RCC_GetHCLKClockFreq+0x18>)
 80051d6:	689a      	ldr	r2, [r3, #8]
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 80051d8:	0a12      	lsrs	r2, r2, #8
 80051da:	230f      	movs	r3, #15
 80051dc:	4013      	ands	r3, r2
 80051de:	009b      	lsls	r3, r3, #2
 80051e0:	4a03      	ldr	r2, [pc, #12]	; (80051f0 <RCC_GetHCLKClockFreq+0x1c>)
 80051e2:	589a      	ldr	r2, [r3, r2]
 80051e4:	231f      	movs	r3, #31
 80051e6:	4013      	ands	r3, r2
 80051e8:	40d8      	lsrs	r0, r3
}
 80051ea:	4770      	bx	lr
 80051ec:	40021000 	.word	0x40021000
 80051f0:	08006500 	.word	0x08006500

080051f4 <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE));
 80051f4:	4b05      	ldr	r3, [pc, #20]	; (800520c <RCC_GetPCLK1ClockFreq+0x18>)
 80051f6:	689a      	ldr	r2, [r3, #8]
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 80051f8:	0b12      	lsrs	r2, r2, #12
 80051fa:	2307      	movs	r3, #7
 80051fc:	4013      	ands	r3, r2
 80051fe:	009b      	lsls	r3, r3, #2
 8005200:	4a03      	ldr	r2, [pc, #12]	; (8005210 <RCC_GetPCLK1ClockFreq+0x1c>)
 8005202:	589a      	ldr	r2, [r3, r2]
 8005204:	231f      	movs	r3, #31
 8005206:	4013      	ands	r3, r2
 8005208:	40d8      	lsrs	r0, r3
}
 800520a:	4770      	bx	lr
 800520c:	40021000 	.word	0x40021000
 8005210:	08006540 	.word	0x08006540

08005214 <LL_RCC_GetSystemClocksFreq>:
{
 8005214:	b510      	push	{r4, lr}
 8005216:	0004      	movs	r4, r0
  RCC_Clocks->SYSCLK_Frequency = RCC_GetSystemClockFreq();
 8005218:	f7ff ffc6 	bl	80051a8 <RCC_GetSystemClockFreq>
 800521c:	6020      	str	r0, [r4, #0]
  RCC_Clocks->HCLK_Frequency   = RCC_GetHCLKClockFreq(RCC_Clocks->SYSCLK_Frequency);
 800521e:	f7ff ffd9 	bl	80051d4 <RCC_GetHCLKClockFreq>
 8005222:	6060      	str	r0, [r4, #4]
  RCC_Clocks->PCLK1_Frequency  = RCC_GetPCLK1ClockFreq(RCC_Clocks->HCLK_Frequency);
 8005224:	f7ff ffe6 	bl	80051f4 <RCC_GetPCLK1ClockFreq>
 8005228:	60a0      	str	r0, [r4, #8]
}
 800522a:	bd10      	pop	{r4, pc}

0800522c <LL_RCC_GetUSARTClockFreq>:
{
 800522c:	b510      	push	{r4, lr}
  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
 800522e:	2803      	cmp	r0, #3
 8005230:	d001      	beq.n	8005236 <LL_RCC_GetUSARTClockFreq+0xa>
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 8005232:	2000      	movs	r0, #0
}
 8005234:	bd10      	pop	{r4, pc}
  *         @arg @ref LL_RCC_USART1_CLKSOURCE_HSIKER
  *         @arg @ref LL_RCC_USART1_CLKSOURCE_LSE
  */
__STATIC_INLINE uint32_t LL_RCC_GetUSARTClockSource(uint32_t USARTx)
{
  return (uint32_t)(READ_BIT(RCC->CCIPR, USARTx) | (USARTx << 16U));
 8005236:	4b1a      	ldr	r3, [pc, #104]	; (80052a0 <LL_RCC_GetUSARTClockFreq+0x74>)
 8005238:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800523a:	4003      	ands	r3, r0
 800523c:	0400      	lsls	r0, r0, #16
 800523e:	4318      	orrs	r0, r3
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8005240:	4b18      	ldr	r3, [pc, #96]	; (80052a4 <LL_RCC_GetUSARTClockFreq+0x78>)
 8005242:	4298      	cmp	r0, r3
 8005244:	d00f      	beq.n	8005266 <LL_RCC_GetUSARTClockFreq+0x3a>
 8005246:	4b18      	ldr	r3, [pc, #96]	; (80052a8 <LL_RCC_GetUSARTClockFreq+0x7c>)
 8005248:	4298      	cmp	r0, r3
 800524a:	d01e      	beq.n	800528a <LL_RCC_GetUSARTClockFreq+0x5e>
 800524c:	4b17      	ldr	r3, [pc, #92]	; (80052ac <LL_RCC_GetUSARTClockFreq+0x80>)
 800524e:	4298      	cmp	r0, r3
 8005250:	d006      	beq.n	8005260 <LL_RCC_GetUSARTClockFreq+0x34>
        usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8005252:	f7ff ffa9 	bl	80051a8 <RCC_GetSystemClockFreq>
 8005256:	f7ff ffbd 	bl	80051d4 <RCC_GetHCLKClockFreq>
 800525a:	f7ff ffcb 	bl	80051f4 <RCC_GetPCLK1ClockFreq>
        break;
 800525e:	e7e9      	b.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
        usart_frequency = RCC_GetSystemClockFreq();
 8005260:	f7ff ffa2 	bl	80051a8 <RCC_GetSystemClockFreq>
        break;
 8005264:	e7e6      	b.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
  return ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY)) ? 1UL : 0UL);
 8005266:	4b0e      	ldr	r3, [pc, #56]	; (80052a0 <LL_RCC_GetUSARTClockFreq+0x74>)
 8005268:	681a      	ldr	r2, [r3, #0]
 800526a:	2380      	movs	r3, #128	; 0x80
 800526c:	00db      	lsls	r3, r3, #3
 800526e:	0010      	movs	r0, r2
 8005270:	4018      	ands	r0, r3
 8005272:	421a      	tst	r2, r3
 8005274:	d0de      	beq.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
  return (READ_BIT(RCC->CR, RCC_CR_HSIKERDIV));
 8005276:	4b0a      	ldr	r3, [pc, #40]	; (80052a0 <LL_RCC_GetUSARTClockFreq+0x74>)
 8005278:	681b      	ldr	r3, [r3, #0]
          usart_frequency = (HSI_VALUE / ((LL_RCC_HSIKER_GetDivider() >> RCC_CR_HSIKERDIV_Pos) + 1U));
 800527a:	095b      	lsrs	r3, r3, #5
 800527c:	2107      	movs	r1, #7
 800527e:	4019      	ands	r1, r3
 8005280:	3101      	adds	r1, #1
 8005282:	480b      	ldr	r0, [pc, #44]	; (80052b0 <LL_RCC_GetUSARTClockFreq+0x84>)
 8005284:	f7fa ff40 	bl	8000108 <__udivsi3>
 8005288:	e7d4      	b.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
  return ((READ_BIT(RCC->CSR1, RCC_CSR1_LSERDY) == (RCC_CSR1_LSERDY)) ? 1UL : 0UL);
 800528a:	4b05      	ldr	r3, [pc, #20]	; (80052a0 <LL_RCC_GetUSARTClockFreq+0x74>)
 800528c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800528e:	2202      	movs	r2, #2
 8005290:	0010      	movs	r0, r2
 8005292:	4018      	ands	r0, r3
 8005294:	421a      	tst	r2, r3
 8005296:	d0cd      	beq.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
          usart_frequency = LSE_VALUE;
 8005298:	2080      	movs	r0, #128	; 0x80
 800529a:	0200      	lsls	r0, r0, #8
  return usart_frequency;
 800529c:	e7ca      	b.n	8005234 <LL_RCC_GetUSARTClockFreq+0x8>
 800529e:	46c0      	nop			; (mov r8, r8)
 80052a0:	40021000 	.word	0x40021000
 80052a4:	00030002 	.word	0x00030002
 80052a8:	00030003 	.word	0x00030003
 80052ac:	00030001 	.word	0x00030001
 80052b0:	02dc6c00 	.word	0x02dc6c00

080052b4 <LL_USART_DeInit>:
  ErrorStatus status = SUCCESS;

  /* Check the parameters */
  assert_param(IS_UART_INSTANCE(USARTx));

  if (USARTx == USART1)
 80052b4:	4b0f      	ldr	r3, [pc, #60]	; (80052f4 <LL_USART_DeInit+0x40>)
 80052b6:	4298      	cmp	r0, r3
 80052b8:	d004      	beq.n	80052c4 <LL_USART_DeInit+0x10>
    LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_USART1);

    /* Release reset of USART clock */
    LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_USART1);
  }
  else if (USARTx == USART2)
 80052ba:	4b0f      	ldr	r3, [pc, #60]	; (80052f8 <LL_USART_DeInit+0x44>)
 80052bc:	4298      	cmp	r0, r3
 80052be:	d00d      	beq.n	80052dc <LL_USART_DeInit+0x28>
    /* Release reset of USART clock */
    LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_USART2);
  }
  else
  {
    status = ERROR;
 80052c0:	2001      	movs	r0, #1
  }

  return (status);
}
 80052c2:	4770      	bx	lr
  *         @arg @ref LL_APB2_GRP1_PERIPH_ADC
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_ForceReset(uint32_t Periphs)
{
  SET_BIT(RCC->APBRSTR2, Periphs);
 80052c4:	4b0d      	ldr	r3, [pc, #52]	; (80052fc <LL_USART_DeInit+0x48>)
 80052c6:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80052c8:	2280      	movs	r2, #128	; 0x80
 80052ca:	01d2      	lsls	r2, r2, #7
 80052cc:	430a      	orrs	r2, r1
 80052ce:	631a      	str	r2, [r3, #48]	; 0x30
  *         @arg @ref LL_APB2_GRP1_PERIPH_ADC
  * @retval None
  */
__STATIC_INLINE void LL_APB2_GRP1_ReleaseReset(uint32_t Periphs)
{
  CLEAR_BIT(RCC->APBRSTR2, Periphs);
 80052d0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80052d2:	490b      	ldr	r1, [pc, #44]	; (8005300 <LL_USART_DeInit+0x4c>)
 80052d4:	400a      	ands	r2, r1
 80052d6:	631a      	str	r2, [r3, #48]	; 0x30
  ErrorStatus status = SUCCESS;
 80052d8:	2000      	movs	r0, #0
}
 80052da:	e7f2      	b.n	80052c2 <LL_USART_DeInit+0xe>
  SET_BIT(RCC->APBRSTR1, Periphs);
 80052dc:	4b07      	ldr	r3, [pc, #28]	; (80052fc <LL_USART_DeInit+0x48>)
 80052de:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80052e0:	2280      	movs	r2, #128	; 0x80
 80052e2:	0292      	lsls	r2, r2, #10
 80052e4:	430a      	orrs	r2, r1
 80052e6:	62da      	str	r2, [r3, #44]	; 0x2c
  CLEAR_BIT(RCC->APBRSTR1, Periphs);
 80052e8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80052ea:	4906      	ldr	r1, [pc, #24]	; (8005304 <LL_USART_DeInit+0x50>)
 80052ec:	400a      	ands	r2, r1
 80052ee:	62da      	str	r2, [r3, #44]	; 0x2c
 80052f0:	2000      	movs	r0, #0
}
 80052f2:	e7e6      	b.n	80052c2 <LL_USART_DeInit+0xe>
 80052f4:	40013800 	.word	0x40013800
 80052f8:	40004400 	.word	0x40004400
 80052fc:	40021000 	.word	0x40021000
 8005300:	ffffbfff 	.word	0xffffbfff
 8005304:	fffdffff 	.word	0xfffdffff

08005308 <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)
{
 8005308:	b570      	push	{r4, r5, r6, lr}
 800530a:	b084      	sub	sp, #16
 800530c:	0004      	movs	r4, r0
 800530e:	000d      	movs	r5, r1
  return ((READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE)) ? 1UL : 0UL);
 8005310:	6803      	ldr	r3, [r0, #0]
 8005312:	07db      	lsls	r3, r3, #31
 8005314:	d500      	bpl.n	8005318 <LL_USART_Init+0x10>
 8005316:	e06b      	b.n	80053f0 <LL_USART_Init+0xe8>
     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
     */
    MODIFY_REG(USARTx->CR1,
 8005318:	6803      	ldr	r3, [r0, #0]
 800531a:	4a36      	ldr	r2, [pc, #216]	; (80053f4 <LL_USART_Init+0xec>)
 800531c:	401a      	ands	r2, r3
 800531e:	688b      	ldr	r3, [r1, #8]
 8005320:	6909      	ldr	r1, [r1, #16]
 8005322:	430b      	orrs	r3, r1
 8005324:	6969      	ldr	r1, [r5, #20]
 8005326:	430b      	orrs	r3, r1
 8005328:	69e9      	ldr	r1, [r5, #28]
 800532a:	430b      	orrs	r3, r1
 800532c:	4313      	orrs	r3, r2
 800532e:	6003      	str	r3, [r0, #0]
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8005330:	6843      	ldr	r3, [r0, #4]
 8005332:	4a31      	ldr	r2, [pc, #196]	; (80053f8 <LL_USART_Init+0xf0>)
 8005334:	4013      	ands	r3, r2
 8005336:	68ea      	ldr	r2, [r5, #12]
 8005338:	4313      	orrs	r3, r2
 800533a:	6043      	str	r3, [r0, #4]
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 800533c:	6883      	ldr	r3, [r0, #8]
 800533e:	4a2f      	ldr	r2, [pc, #188]	; (80053fc <LL_USART_Init+0xf4>)
 8005340:	4013      	ands	r3, r2
 8005342:	69aa      	ldr	r2, [r5, #24]
 8005344:	4313      	orrs	r3, r2
 8005346:	6083      	str	r3, [r0, #8]
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);

    /*---------------------------- USART BRR Configuration ---------------------
     * Retrieve Clock frequency used for USART Peripheral
     */
    if (USARTx == USART1)
 8005348:	4b2d      	ldr	r3, [pc, #180]	; (8005400 <LL_USART_Init+0xf8>)
 800534a:	4298      	cmp	r0, r3
 800534c:	d00e      	beq.n	800536c <LL_USART_Init+0x64>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);
    }
    else if (USARTx == USART2)
 800534e:	4b2d      	ldr	r3, [pc, #180]	; (8005404 <LL_USART_Init+0xfc>)
 8005350:	4298      	cmp	r0, r3
 8005352:	d015      	beq.n	8005380 <LL_USART_Init+0x78>
  ErrorStatus status = ERROR;
 8005354:	2001      	movs	r0, #1

    /*---------------------------- USART PRESC Configuration -----------------------
     * Configure USARTx PRESC (Prescaler) with parameters:
     * - PrescalerValue: USART_PRESC_PRESCALER bits according to USART_InitStruct->PrescalerValue value.
     */
    LL_USART_SetPrescaler(USARTx, USART_InitStruct->PrescalerValue);
 8005356:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(USARTx->PRESC, USART_PRESC_PRESCALER, (uint16_t)PrescalerValue);
 8005358:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800535a:	210f      	movs	r1, #15
 800535c:	438b      	bics	r3, r1
 800535e:	0019      	movs	r1, r3
 8005360:	0412      	lsls	r2, r2, #16
 8005362:	0c13      	lsrs	r3, r2, #16
 8005364:	430b      	orrs	r3, r1
 8005366:	62e3      	str	r3, [r4, #44]	; 0x2c
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 8005368:	b004      	add	sp, #16
 800536a:	bd70      	pop	{r4, r5, r6, pc}
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);
 800536c:	2003      	movs	r0, #3
 800536e:	f7ff ff5d 	bl	800522c <LL_RCC_GetUSARTClockFreq>
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 8005372:	2800      	cmp	r0, #0
 8005374:	d03a      	beq.n	80053ec <LL_USART_Init+0xe4>
        && (USART_InitStruct->BaudRate != 0U))
 8005376:	686e      	ldr	r6, [r5, #4]
 8005378:	2e00      	cmp	r6, #0
 800537a:	d106      	bne.n	800538a <LL_USART_Init+0x82>
  ErrorStatus status = ERROR;
 800537c:	2001      	movs	r0, #1
 800537e:	e7ea      	b.n	8005356 <LL_USART_Init+0x4e>
      LL_RCC_GetSystemClocksFreq(&RCC_Clocks);
 8005380:	a801      	add	r0, sp, #4
 8005382:	f7ff ff47 	bl	8005214 <LL_RCC_GetSystemClocksFreq>
      periphclk = RCC_Clocks.PCLK1_Frequency;
 8005386:	9803      	ldr	r0, [sp, #12]
 8005388:	e7f3      	b.n	8005372 <LL_USART_Init+0x6a>
      LL_USART_SetBaudRate(USARTx,
 800538a:	682b      	ldr	r3, [r5, #0]
 800538c:	69ea      	ldr	r2, [r5, #28]
  if (PrescalerValue > LL_USART_PRESCALER_DIV256)
 800538e:	2b0b      	cmp	r3, #11
 8005390:	d814      	bhi.n	80053bc <LL_USART_Init+0xb4>
  else if (BaudRate == 0U)
 8005392:	2e00      	cmp	r6, #0
 8005394:	d012      	beq.n	80053bc <LL_USART_Init+0xb4>
  else if (OverSampling == LL_USART_OVERSAMPLING_8)
 8005396:	2180      	movs	r1, #128	; 0x80
 8005398:	0209      	lsls	r1, r1, #8
 800539a:	428a      	cmp	r2, r1
 800539c:	d010      	beq.n	80053c0 <LL_USART_Init+0xb8>
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 800539e:	22ff      	movs	r2, #255	; 0xff
 80053a0:	4013      	ands	r3, r2
 80053a2:	009b      	lsls	r3, r3, #2
 80053a4:	4a18      	ldr	r2, [pc, #96]	; (8005408 <LL_USART_Init+0x100>)
 80053a6:	5899      	ldr	r1, [r3, r2]
 80053a8:	f7fa feae 	bl	8000108 <__udivsi3>
 80053ac:	0873      	lsrs	r3, r6, #1
 80053ae:	18c0      	adds	r0, r0, r3
 80053b0:	0031      	movs	r1, r6
 80053b2:	f7fa fea9 	bl	8000108 <__udivsi3>
 80053b6:	0403      	lsls	r3, r0, #16
 80053b8:	0c1b      	lsrs	r3, r3, #16
 80053ba:	60e3      	str	r3, [r4, #12]
      status = SUCCESS;
 80053bc:	2000      	movs	r0, #0
}
 80053be:	e7ca      	b.n	8005356 <LL_USART_Init+0x4e>
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint8_t)PrescalerValue, BaudRate));
 80053c0:	22ff      	movs	r2, #255	; 0xff
 80053c2:	4013      	ands	r3, r2
 80053c4:	009b      	lsls	r3, r3, #2
 80053c6:	4a10      	ldr	r2, [pc, #64]	; (8005408 <LL_USART_Init+0x100>)
 80053c8:	5899      	ldr	r1, [r3, r2]
 80053ca:	f7fa fe9d 	bl	8000108 <__udivsi3>
 80053ce:	0040      	lsls	r0, r0, #1
 80053d0:	0873      	lsrs	r3, r6, #1
 80053d2:	18c0      	adds	r0, r0, r3
 80053d4:	0031      	movs	r1, r6
 80053d6:	f7fa fe97 	bl	8000108 <__udivsi3>
    brrtemp = usartdiv & 0xFFF0U;
 80053da:	4b0c      	ldr	r3, [pc, #48]	; (800540c <LL_USART_Init+0x104>)
 80053dc:	4003      	ands	r3, r0
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 80053de:	0400      	lsls	r0, r0, #16
 80053e0:	0c40      	lsrs	r0, r0, #17
 80053e2:	2207      	movs	r2, #7
 80053e4:	4010      	ands	r0, r2
 80053e6:	4318      	orrs	r0, r3
    USARTx->BRR = brrtemp;
 80053e8:	60e0      	str	r0, [r4, #12]
 80053ea:	e7e7      	b.n	80053bc <LL_USART_Init+0xb4>
  ErrorStatus status = ERROR;
 80053ec:	2001      	movs	r0, #1
 80053ee:	e7b2      	b.n	8005356 <LL_USART_Init+0x4e>
 80053f0:	2001      	movs	r0, #1
 80053f2:	e7b9      	b.n	8005368 <LL_USART_Init+0x60>
 80053f4:	efff69f3 	.word	0xefff69f3
 80053f8:	ffffcfff 	.word	0xffffcfff
 80053fc:	fffffcff 	.word	0xfffffcff
 8005400:	40013800 	.word	0x40013800
 8005404:	40004400 	.word	0x40004400
 8005408:	080065b4 	.word	0x080065b4
 800540c:	0000fff0 	.word	0x0000fff0

08005410 <LL_USART_StructInit>:
  */

void LL_USART_StructInit(LL_USART_InitTypeDef *USART_InitStruct)
{
  /* Set USART_InitStruct fields to default values */
  USART_InitStruct->PrescalerValue      = LL_USART_PRESCALER_DIV1;
 8005410:	2300      	movs	r3, #0
 8005412:	6003      	str	r3, [r0, #0]
  USART_InitStruct->BaudRate            = 9600U;
 8005414:	2296      	movs	r2, #150	; 0x96
 8005416:	0192      	lsls	r2, r2, #6
 8005418:	6042      	str	r2, [r0, #4]
  USART_InitStruct->DataWidth           = LL_USART_DATAWIDTH_8B;
 800541a:	6083      	str	r3, [r0, #8]
  USART_InitStruct->StopBits            = LL_USART_STOPBITS_1;
 800541c:	60c3      	str	r3, [r0, #12]
  USART_InitStruct->Parity              = LL_USART_PARITY_NONE ;
 800541e:	6103      	str	r3, [r0, #16]
  USART_InitStruct->TransferDirection   = LL_USART_DIRECTION_TX_RX;
 8005420:	220c      	movs	r2, #12
 8005422:	6142      	str	r2, [r0, #20]
  USART_InitStruct->HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 8005424:	6183      	str	r3, [r0, #24]
  USART_InitStruct->OverSampling        = LL_USART_OVERSAMPLING_16;
 8005426:	61c3      	str	r3, [r0, #28]
}
 8005428:	4770      	bx	lr
	...

0800542c <pDS_PAD_MatchByPinAndSignal>:
*/

// find the entry for the corresponding pinname and signal name (because one pin can have multiple signals from same peripheral...)
// we return a pointer to the entry so C code can directly -> its elements
// this is not itterative as there should be only one solution.
DS_PAD_t const* pDS_PAD_MatchByPinAndSignal(PadName_t PinName, STM32_SignalName_t SignalName) {
 800542c:	b510      	push	{r4, lr}
  
  uint32_t i;
  for(i=0;i<countof(DS_PADs);i++) {
 800542e:	2300      	movs	r3, #0
 8005430:	e000      	b.n	8005434 <pDS_PAD_MatchByPinAndSignal+0x8>
 8005432:	3301      	adds	r3, #1
 8005434:	2bb1      	cmp	r3, #177	; 0xb1
 8005436:	d80e      	bhi.n	8005456 <pDS_PAD_MatchByPinAndSignal+0x2a>
    
    if(DS_PADs[i].PinName==PinName)
 8005438:	011a      	lsls	r2, r3, #4
 800543a:	4c07      	ldr	r4, [pc, #28]	; (8005458 <pDS_PAD_MatchByPinAndSignal+0x2c>)
 800543c:	5712      	ldrsb	r2, [r2, r4]
 800543e:	4282      	cmp	r2, r0
 8005440:	d1f7      	bne.n	8005432 <pDS_PAD_MatchByPinAndSignal+0x6>
      if(DS_PADs[i].SignalName==SignalName) {
 8005442:	011c      	lsls	r4, r3, #4
 8005444:	4a04      	ldr	r2, [pc, #16]	; (8005458 <pDS_PAD_MatchByPinAndSignal+0x2c>)
 8005446:	1912      	adds	r2, r2, r4
 8005448:	7a12      	ldrb	r2, [r2, #8]
 800544a:	428a      	cmp	r2, r1
 800544c:	d1f1      	bne.n	8005432 <pDS_PAD_MatchByPinAndSignal+0x6>
        // we found the pin!
        return &DS_PADs[i]; 
 800544e:	0118      	lsls	r0, r3, #4
 8005450:	4b01      	ldr	r3, [pc, #4]	; (8005458 <pDS_PAD_MatchByPinAndSignal+0x2c>)
 8005452:	18c0      	adds	r0, r0, r3
      };
  };
  
  while(1); // nothing found...
  //return NULL; // failed.
}
 8005454:	bd10      	pop	{r4, pc}
  while(1); // nothing found...
 8005456:	e7fe      	b.n	8005456 <pDS_PAD_MatchByPinAndSignal+0x2a>
 8005458:	080065e4 	.word	0x080065e4

0800545c <IO_AddPadToRawPortPads>:
// use PCB signal name in the naming is allowed
const IO_Pad_t LEDtest1_AsPWM = { PA_5, {.Mode = IO_SIGNAL, .Pull = IO_NOPULL, .Drive = IO_PUSHPULL, .Speed = IO_SPEED_00, .Odr = IO_ODR_NO_INIT, .Signal = IO_AF_05 } /*TIM1_1 signal name to seach in dbase*/ };
//const IO_Pad_t LEDtest2_AsPWM = { PA5, {IO_NOPULL, IO_SIGNAL, IO_PUSHPULL, IO_SPEED_00}, IO_AF_05 /*TIM1_1 signal name to seach in dbase*/ }; // this generates a warning! better than #define version
#endif

int32_t IO_AddPadToRawPortPads(PadName_t PadName, RawPortPads_t* pRPP ) {
 800545c:	b510      	push	{r4, lr}

  uint8_t gpio_index = PadName>>4;
 800545e:	1103      	asrs	r3, r0, #4
 8005460:	b2db      	uxtb	r3, r3
  // first is it a valid gpio?
  if(gpio_index>=countof(IO_GPIOx))
 8005462:	2b05      	cmp	r3, #5
 8005464:	d810      	bhi.n	8005488 <IO_AddPadToRawPortPads+0x2c>
    return -1;
  
  uint8_t pad_position = PadName & 0x000F;
 8005466:	220f      	movs	r2, #15
 8005468:	4010      	ands	r0, r2
  pRPP->bfPin = 1<<pad_position;  
 800546a:	3a0e      	subs	r2, #14
 800546c:	4082      	lsls	r2, r0
 800546e:	b292      	uxth	r2, r2
 8005470:	808a      	strh	r2, [r1, #4]
  if((pGPIO_PadValidMask[gpio_index] & pRPP->bfPin)==0)
 8005472:	0058      	lsls	r0, r3, #1
 8005474:	4c07      	ldr	r4, [pc, #28]	; (8005494 <IO_AddPadToRawPortPads+0x38>)
 8005476:	5b00      	ldrh	r0, [r0, r4]
 8005478:	4210      	tst	r0, r2
 800547a:	d008      	beq.n	800548e <IO_AddPadToRawPortPads+0x32>
    return -1;
  
  // valid port, valid pin
  pRPP->pPort = (GPIO_TypeDef*) IO_GPIOx[gpio_index];
 800547c:	009b      	lsls	r3, r3, #2
 800547e:	4a06      	ldr	r2, [pc, #24]	; (8005498 <IO_AddPadToRawPortPads+0x3c>)
 8005480:	589b      	ldr	r3, [r3, r2]
 8005482:	600b      	str	r3, [r1, #0]
  return 0;
 8005484:	2000      	movs	r0, #0
}
 8005486:	bd10      	pop	{r4, pc}
    return -1;
 8005488:	2001      	movs	r0, #1
 800548a:	4240      	negs	r0, r0
 800548c:	e7fb      	b.n	8005486 <IO_AddPadToRawPortPads+0x2a>
    return -1;
 800548e:	2001      	movs	r0, #1
 8005490:	4240      	negs	r0, r0
 8005492:	e7f8      	b.n	8005486 <IO_AddPadToRawPortPads+0x2a>
 8005494:	0800711c 	.word	0x0800711c
 8005498:	20000200 	.word	0x20000200

0800549c <IO_PadInit>:
  pRPP->pPort = NULL;
  return 0;
}

//static uint32_t tmp, bfmask, bfval; // for debug watch purpose
int32_t IO_PadInit(IO_Pad_t* pIO ) { // this is for a single pin
 800549c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800549e:	46d6      	mov	lr, sl
 80054a0:	464f      	mov	r7, r9
 80054a2:	4646      	mov	r6, r8
 80054a4:	b5c0      	push	{r6, r7, lr}
 80054a6:	0005      	movs	r5, r0
  RawPortPads_t RPP;
  if(IO_MakeRawPortPadsFromPin(&RPP, pIO->Name)<0)
    return -1; // wrong padname
  */
  //--- original code for checking here --- to use RRP instead
  uint8_t gpio_index = pIO->PadName>>4;
 80054a8:	2700      	movs	r7, #0
 80054aa:	57c7      	ldrsb	r7, [r0, r7]
 80054ac:	113c      	asrs	r4, r7, #4
 80054ae:	b2e4      	uxtb	r4, r4
  // first is it a valid gpio?
  if(gpio_index>=countof(IO_GPIOx))
 80054b0:	2c05      	cmp	r4, #5
 80054b2:	d900      	bls.n	80054b6 <IO_PadInit+0x1a>
 80054b4:	e0cd      	b.n	8005652 <IO_PadInit+0x1b6>
    return -1;
  
  uint8_t pad_position = pIO->PadName & 0x000F;
 80054b6:	b2fb      	uxtb	r3, r7
 80054b8:	469a      	mov	sl, r3
 80054ba:	230f      	movs	r3, #15
 80054bc:	401f      	ands	r7, r3
  uint32_t pin_mask = 1<<pad_position;  
 80054be:	3b0e      	subs	r3, #14
 80054c0:	40bb      	lsls	r3, r7
 80054c2:	4698      	mov	r8, r3
  if((pGPIO_PadValidMask[gpio_index] & pin_mask)==0)
 80054c4:	0063      	lsls	r3, r4, #1
 80054c6:	4a67      	ldr	r2, [pc, #412]	; (8005664 <IO_PadInit+0x1c8>)
 80054c8:	5a9b      	ldrh	r3, [r3, r2]
 80054ca:	4642      	mov	r2, r8
 80054cc:	421a      	tst	r2, r3
 80054ce:	d100      	bne.n	80054d2 <IO_PadInit+0x36>
 80054d0:	e0c2      	b.n	8005658 <IO_PadInit+0x1bc>
    return -1;
  
  // valid port, valid pin
  GPIO_TypeDef *GPIOx = (GPIO_TypeDef*) IO_GPIOx[gpio_index];
 80054d2:	00a3      	lsls	r3, r4, #2
 80054d4:	4a64      	ldr	r2, [pc, #400]	; (8005668 <IO_PadInit+0x1cc>)
 80054d6:	589b      	ldr	r3, [r3, r2]
 80054d8:	4699      	mov	r9, r3
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80054da:	f3ef 8610 	mrs	r6, PRIMASK

  uint32_t primask  = __get_PRIMASK(); // save current interrupt context
  
  // if needed, enable GPIO Clock
  while(READ_BIT(RCC->IOPENR, RCC_GPIOx_ClockEnBitMask[gpio_index])==0) {
 80054de:	e00e      	b.n	80054fe <IO_PadInit+0x62>
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80054e0:	2301      	movs	r3, #1
 80054e2:	f383 8810 	msr	PRIMASK, r3
    
    __set_PRIMASK(1);// atomic start
    SET_BIT(RCC->IOPENR, RCC_GPIOx_ClockEnBitMask[gpio_index]); 
 80054e6:	4961      	ldr	r1, [pc, #388]	; (800566c <IO_PadInit+0x1d0>)
 80054e8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80054ea:	00a2      	lsls	r2, r4, #2
 80054ec:	4860      	ldr	r0, [pc, #384]	; (8005670 <IO_PadInit+0x1d4>)
 80054ee:	5812      	ldr	r2, [r2, r0]
 80054f0:	4313      	orrs	r3, r2
 80054f2:	634b      	str	r3, [r1, #52]	; 0x34
 80054f4:	f386 8810 	msr	PRIMASK, r6
    __set_PRIMASK(primask);// atomic end
    
    NOPs(4);
 80054f8:	2004      	movs	r0, #4
 80054fa:	f7fd fec7 	bl	800328c <NOPs>
  while(READ_BIT(RCC->IOPENR, RCC_GPIOx_ClockEnBitMask[gpio_index])==0) {
 80054fe:	4b5b      	ldr	r3, [pc, #364]	; (800566c <IO_PadInit+0x1d0>)
 8005500:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8005502:	00a3      	lsls	r3, r4, #2
 8005504:	495a      	ldr	r1, [pc, #360]	; (8005670 <IO_PadInit+0x1d4>)
 8005506:	585b      	ldr	r3, [r3, r1]
 8005508:	4213      	tst	r3, r2
 800550a:	d0e9      	beq.n	80054e0 <IO_PadInit+0x44>
  };

  /* Configure the IO Speed */
  if(pIO->Config.Speed) {
 800550c:	78ab      	ldrb	r3, [r5, #2]
 800550e:	075b      	lsls	r3, r3, #29
 8005510:	d013      	beq.n	800553a <IO_PadInit+0x9e>
    bfmask = ~(0x3<<(pad_position * 2));
 8005512:	0079      	lsls	r1, r7, #1
 8005514:	2203      	movs	r2, #3
 8005516:	408a      	lsls	r2, r1
 8005518:	43d2      	mvns	r2, r2
    bfval = (pIO->Config.Speed-1) << (pad_position * 2); 
 800551a:	78ab      	ldrb	r3, [r5, #2]
 800551c:	075b      	lsls	r3, r3, #29
 800551e:	0f5b      	lsrs	r3, r3, #29
 8005520:	3b01      	subs	r3, #1
 8005522:	408b      	lsls	r3, r1
 8005524:	2101      	movs	r1, #1
 8005526:	f381 8810 	msr	PRIMASK, r1
    __set_PRIMASK(1);// atomic start
    tmp = (GPIOx->OSPEEDR & bfmask) | bfval;
 800552a:	4649      	mov	r1, r9
 800552c:	6889      	ldr	r1, [r1, #8]
 800552e:	400a      	ands	r2, r1
 8005530:	4313      	orrs	r3, r2
    GPIOx->OSPEEDR = tmp;
 8005532:	464a      	mov	r2, r9
 8005534:	6093      	str	r3, [r2, #8]
 8005536:	f386 8810 	msr	PRIMASK, r6
    __set_PRIMASK(primask);// atomic end
  }

  /* Configure the IO Output Type */  
  if(pIO->Config.Pull) {
 800553a:	786b      	ldrb	r3, [r5, #1]
 800553c:	2238      	movs	r2, #56	; 0x38
 800553e:	421a      	tst	r2, r3
 8005540:	d012      	beq.n	8005568 <IO_PadInit+0xcc>
    
    bfmask = ~(0x3<<(pad_position * 2));
 8005542:	0079      	lsls	r1, r7, #1
 8005544:	3a35      	subs	r2, #53	; 0x35
 8005546:	408a      	lsls	r2, r1
 8005548:	43d2      	mvns	r2, r2
    bfval = (pIO->Config.Pull-1) << (pad_position * 2);
 800554a:	069b      	lsls	r3, r3, #26
 800554c:	0f5b      	lsrs	r3, r3, #29
 800554e:	3b01      	subs	r3, #1
 8005550:	408b      	lsls	r3, r1
 8005552:	2101      	movs	r1, #1
 8005554:	f381 8810 	msr	PRIMASK, r1
    __set_PRIMASK(1);// atomic start
    tmp = (GPIOx->OTYPER & bfmask) | bfval;
 8005558:	4649      	mov	r1, r9
 800555a:	6849      	ldr	r1, [r1, #4]
 800555c:	400a      	ands	r2, r1
 800555e:	4313      	orrs	r3, r2
    GPIOx->PUPDR = tmp;
 8005560:	464a      	mov	r2, r9
 8005562:	60d3      	str	r3, [r2, #12]
 8005564:	f386 8810 	msr	PRIMASK, r6
    __set_PRIMASK(primask);    // atomic end
  }
  
  /* Configure the output type */
  if(pIO->Config.Drive) {
 8005568:	786b      	ldrb	r3, [r5, #1]
 800556a:	223f      	movs	r2, #63	; 0x3f
 800556c:	4393      	bics	r3, r2
 800556e:	d010      	beq.n	8005592 <IO_PadInit+0xf6>

    bfmask = ~(1<<pad_position);
 8005570:	4643      	mov	r3, r8
 8005572:	43db      	mvns	r3, r3
    bfval = (pIO->Config.Drive-1) << (pad_position);
 8005574:	786a      	ldrb	r2, [r5, #1]
 8005576:	0992      	lsrs	r2, r2, #6
 8005578:	3a01      	subs	r2, #1
 800557a:	40ba      	lsls	r2, r7
 800557c:	2101      	movs	r1, #1
 800557e:	f381 8810 	msr	PRIMASK, r1
    __set_PRIMASK(1);// atomic start
    tmp = (GPIOx->OTYPER & bfmask)|bfval;
 8005582:	4649      	mov	r1, r9
 8005584:	6849      	ldr	r1, [r1, #4]
 8005586:	400b      	ands	r3, r1
 8005588:	4313      	orrs	r3, r2
    GPIOx->OTYPER = tmp;
 800558a:	464a      	mov	r2, r9
 800558c:	6053      	str	r3, [r2, #4]
 800558e:	f386 8810 	msr	PRIMASK, r6
  }

  // to improve, output should be set BEFORE being an output and AFTER being an input ? to avoid glitch if mode is changing.
  // for now, refrain to set the output when asking the pin to become an input
  // also refrain to use this function to change only the ouput level, there are dedicated speedy functions for it
  if(pIO->Config.Odr) {
 8005592:	78ab      	ldrb	r3, [r5, #2]
 8005594:	2218      	movs	r2, #24
 8005596:	421a      	tst	r2, r3
 8005598:	d011      	beq.n	80055be <IO_PadInit+0x122>

    bfmask = ~(1<<pad_position);
 800559a:	4643      	mov	r3, r8
 800559c:	43db      	mvns	r3, r3
    bfval = (pIO->Config.Odr-1) << pad_position;
 800559e:	78aa      	ldrb	r2, [r5, #2]
 80055a0:	06d2      	lsls	r2, r2, #27
 80055a2:	0f92      	lsrs	r2, r2, #30
 80055a4:	3a01      	subs	r2, #1
 80055a6:	40ba      	lsls	r2, r7
 80055a8:	2101      	movs	r1, #1
 80055aa:	f381 8810 	msr	PRIMASK, r1
    __set_PRIMASK(1);// atomic start
    tmp = (GPIOx->ODR & bfmask)|bfval;
 80055ae:	4649      	mov	r1, r9
 80055b0:	6949      	ldr	r1, [r1, #20]
 80055b2:	400b      	ands	r3, r1
 80055b4:	4313      	orrs	r3, r2
    GPIOx->ODR = tmp;
 80055b6:	464a      	mov	r2, r9
 80055b8:	6153      	str	r3, [r2, #20]
 80055ba:	f386 8810 	msr	PRIMASK, r6
  
  /*--------------------- GPIO Mode Configuration ------------------------*/

  // analog: nothing to do here
  /* In case of Alternate function mode selection */
  if( pIO->Config.Mode == IO_SIGNAL )
 80055be:	786a      	ldrb	r2, [r5, #1]
 80055c0:	2307      	movs	r3, #7
 80055c2:	4013      	ands	r3, r2
 80055c4:	2b03      	cmp	r3, #3
 80055c6:	d01c      	beq.n	8005602 <IO_PadInit+0x166>
    tmp = (GPIOx->AFR[pad_position >> 3U] & bfmask)|bfval;
    GPIOx->AFR[pad_position >> 3U] = tmp;
    __set_PRIMASK(primask);// atomic end
  }
  
  if(pIO->Config.Mode) {
 80055c8:	786b      	ldrb	r3, [r5, #1]
 80055ca:	075b      	lsls	r3, r3, #29
 80055cc:	d047      	beq.n	800565e <IO_PadInit+0x1c2>

    bfmask = ~(0x3<<(pad_position * 2));
 80055ce:	007f      	lsls	r7, r7, #1
 80055d0:	2303      	movs	r3, #3
 80055d2:	40bb      	lsls	r3, r7
 80055d4:	43db      	mvns	r3, r3
    bfval = (pIO->Config.Mode-1) << (pad_position * 2);
 80055d6:	786a      	ldrb	r2, [r5, #1]
 80055d8:	0752      	lsls	r2, r2, #29
 80055da:	0f52      	lsrs	r2, r2, #29
 80055dc:	3a01      	subs	r2, #1
 80055de:	40ba      	lsls	r2, r7
 80055e0:	2101      	movs	r1, #1
 80055e2:	f381 8810 	msr	PRIMASK, r1
    __set_PRIMASK(1); // atomic start
    tmp = (GPIOx->MODER & bfmask )|bfval;
 80055e6:	4649      	mov	r1, r9
 80055e8:	6809      	ldr	r1, [r1, #0]
 80055ea:	400b      	ands	r3, r1
 80055ec:	4313      	orrs	r3, r2
    GPIOx->MODER = tmp;
 80055ee:	464a      	mov	r2, r9
 80055f0:	6013      	str	r3, [r2, #0]
 80055f2:	f386 8810 	msr	PRIMASK, r6
    __set_PRIMASK(primask);//atomic end
    // atomic end
  }
 
  return 0;
 80055f6:	2000      	movs	r0, #0
}
 80055f8:	bce0      	pop	{r5, r6, r7}
 80055fa:	46ba      	mov	sl, r7
 80055fc:	46b1      	mov	r9, r6
 80055fe:	46a8      	mov	r8, r5
 8005600:	bdf0      	pop	{r4, r5, r6, r7, pc}
    int8_t Alternate = pIO->Config.Signal;
 8005602:	78e9      	ldrb	r1, [r5, #3]
 8005604:	2303      	movs	r3, #3
 8005606:	56eb      	ldrsb	r3, [r5, r3]
    if(Alternate > 0x0F) // if it's not a direct value [0..16] (legacy)
 8005608:	2b0f      	cmp	r3, #15
 800560a:	dc18      	bgt.n	800563e <IO_PadInit+0x1a2>
    bfmask = ~(0xF << ((pad_position & 0x07U) * 4U));
 800560c:	2207      	movs	r2, #7
 800560e:	4651      	mov	r1, sl
 8005610:	400a      	ands	r2, r1
 8005612:	0092      	lsls	r2, r2, #2
 8005614:	210f      	movs	r1, #15
 8005616:	4091      	lsls	r1, r2
 8005618:	43c9      	mvns	r1, r1
    bfval = (Alternate & 0x0FUL) << ((pad_position & 0x07U) * 4U);
 800561a:	200f      	movs	r0, #15
 800561c:	4003      	ands	r3, r0
 800561e:	4093      	lsls	r3, r2
 8005620:	2201      	movs	r2, #1
 8005622:	f382 8810 	msr	PRIMASK, r2
    tmp = (GPIOx->AFR[pad_position >> 3U] & bfmask)|bfval;
 8005626:	08fa      	lsrs	r2, r7, #3
 8005628:	3208      	adds	r2, #8
 800562a:	0092      	lsls	r2, r2, #2
 800562c:	4648      	mov	r0, r9
 800562e:	5810      	ldr	r0, [r2, r0]
 8005630:	4001      	ands	r1, r0
 8005632:	430b      	orrs	r3, r1
    GPIOx->AFR[pad_position >> 3U] = tmp;
 8005634:	4649      	mov	r1, r9
 8005636:	5053      	str	r3, [r2, r1]
 8005638:	f386 8810 	msr	PRIMASK, r6
}
 800563c:	e7c4      	b.n	80055c8 <IO_PadInit+0x12c>
      DS_PAD_t const* pDS_PAD = pDS_PAD_MatchByPinAndSignal(pIO->PadName, pIO->Config.Signal); // function freeze if no solution
 800563e:	2000      	movs	r0, #0
 8005640:	5628      	ldrsb	r0, [r5, r0]
 8005642:	f7ff fef3 	bl	800542c <pDS_PAD_MatchByPinAndSignal>
      if( pDS_PAD == NULL ) while(1); // freeze. issue.
 8005646:	2800      	cmp	r0, #0
 8005648:	d002      	beq.n	8005650 <IO_PadInit+0x1b4>
      Alternate = pDS_PAD->AF;
 800564a:	230c      	movs	r3, #12
 800564c:	56c3      	ldrsb	r3, [r0, r3]
 800564e:	e7dd      	b.n	800560c <IO_PadInit+0x170>
      if( pDS_PAD == NULL ) while(1); // freeze. issue.
 8005650:	e7fe      	b.n	8005650 <IO_PadInit+0x1b4>
    return -1;
 8005652:	2001      	movs	r0, #1
 8005654:	4240      	negs	r0, r0
 8005656:	e7cf      	b.n	80055f8 <IO_PadInit+0x15c>
    return -1;
 8005658:	2001      	movs	r0, #1
 800565a:	4240      	negs	r0, r0
 800565c:	e7cc      	b.n	80055f8 <IO_PadInit+0x15c>
  return 0;
 800565e:	2000      	movs	r0, #0
 8005660:	e7ca      	b.n	80055f8 <IO_PadInit+0x15c>
 8005662:	46c0      	nop			; (mov r8, r8)
 8005664:	0800711c 	.word	0x0800711c
 8005668:	20000200 	.word	0x20000200
 800566c:	40021000 	.word	0x40021000
 8005670:	08007104 	.word	0x08007104

08005674 <IO_PadDeInit>:

int32_t IO_PadDeInit(PadName_t  PadName) {
 8005674:	b500      	push	{lr}
 8005676:	b083      	sub	sp, #12
  
  IO_Pad_t DeInitPad = { PadName, {.Mode=IO_ANALOG, .Pull=IO_NOPULL, .Drive=IO_PUSHPULL, .Speed=IO_SPEED_00, .Signal = IO_AF_00 } }; // stack based local
 8005678:	ab01      	add	r3, sp, #4
 800567a:	2200      	movs	r2, #0
 800567c:	9201      	str	r2, [sp, #4]
 800567e:	7018      	strb	r0, [r3, #0]
 8005680:	785a      	ldrb	r2, [r3, #1]
 8005682:	2107      	movs	r1, #7
 8005684:	438a      	bics	r2, r1
 8005686:	2004      	movs	r0, #4
 8005688:	4302      	orrs	r2, r0
 800568a:	705a      	strb	r2, [r3, #1]
 800568c:	b2d2      	uxtb	r2, r2
 800568e:	2038      	movs	r0, #56	; 0x38
 8005690:	4382      	bics	r2, r0
 8005692:	2008      	movs	r0, #8
 8005694:	4302      	orrs	r2, r0
 8005696:	705a      	strb	r2, [r3, #1]
 8005698:	b2d0      	uxtb	r0, r2
 800569a:	223f      	movs	r2, #63	; 0x3f
 800569c:	4002      	ands	r2, r0
 800569e:	2040      	movs	r0, #64	; 0x40
 80056a0:	4302      	orrs	r2, r0
 80056a2:	705a      	strb	r2, [r3, #1]
 80056a4:	789a      	ldrb	r2, [r3, #2]
 80056a6:	438a      	bics	r2, r1
 80056a8:	2101      	movs	r1, #1
 80056aa:	430a      	orrs	r2, r1
 80056ac:	709a      	strb	r2, [r3, #2]
  return IO_PadInit( &DeInitPad ); // deinit register sequence could be inverted. To check should be mode dependent?
 80056ae:	0018      	movs	r0, r3
 80056b0:	f7ff fef4 	bl	800549c <IO_PadInit>
  /* Configure IO in Analog Mode */
  /* Configure the default Alternate Function in current IO */
  /* Configure the default value for IO Speed */
  /* Configure the default value IO Output Type */
  /* Deactivate the Pull-up and Pull-down resistor for the current IO */
}
 80056b4:	b003      	add	sp, #12
 80056b6:	bd00      	pop	{pc}

080056b8 <IO_PadSetHigh>:


int32_t IO_PadSetHigh(PadName_t PadName) {
  //GPIOx->BSRR = (uint32_t)GPIO_Pin;
  
  uint8_t gpio_index = PadName>>4;
 80056b8:	1103      	asrs	r3, r0, #4
 80056ba:	b2db      	uxtb	r3, r3
  uint8_t pad_position = PadName & 0x000F;
 80056bc:	220f      	movs	r2, #15
 80056be:	4010      	ands	r0, r2
  uint32_t pin_mask = 1<<pad_position;  
 80056c0:	3a0e      	subs	r2, #14
 80056c2:	4082      	lsls	r2, r0
  
  GPIO_TypeDef* GPIOx = (GPIO_TypeDef*) IO_GPIOx[gpio_index];
 80056c4:	009b      	lsls	r3, r3, #2
 80056c6:	4902      	ldr	r1, [pc, #8]	; (80056d0 <IO_PadSetHigh+0x18>)
 80056c8:	585b      	ldr	r3, [r3, r1]
  GPIOx->BSRR = pin_mask; // atomic
 80056ca:	619a      	str	r2, [r3, #24]
  return 0;
}
 80056cc:	2000      	movs	r0, #0
 80056ce:	4770      	bx	lr
 80056d0:	20000200 	.word	0x20000200

080056d4 <IO_PadSetLow>:

int32_t IO_PadSetLow(PadName_t PadName) {
  //GPIOx->BRR = (uint32_t)GPIO_Pin;
  uint8_t gpio_index = PadName>>4;
 80056d4:	1103      	asrs	r3, r0, #4
 80056d6:	b2db      	uxtb	r3, r3
  uint8_t pad_position = PadName & 0x000F;
 80056d8:	220f      	movs	r2, #15
 80056da:	4010      	ands	r0, r2
  
  GPIO_TypeDef* GPIOx = (GPIO_TypeDef*) IO_GPIOx[gpio_index];
 80056dc:	009b      	lsls	r3, r3, #2
 80056de:	4a03      	ldr	r2, [pc, #12]	; (80056ec <IO_PadSetLow+0x18>)
 80056e0:	589a      	ldr	r2, [r3, r2]
  uint32_t pin_mask = 1<<pad_position;
 80056e2:	2301      	movs	r3, #1
 80056e4:	4083      	lsls	r3, r0
  GPIOx->BRR = pin_mask; // atomic
 80056e6:	6293      	str	r3, [r2, #40]	; 0x28
  return 0;
}
 80056e8:	2000      	movs	r0, #0
 80056ea:	4770      	bx	lr
 80056ec:	20000200 	.word	0x20000200

080056f0 <IO_RawPadSetHigh>:
}

#include "stm32c0xx_ll_gpio.h"
void IO_RawPadSetHigh(RawPortPads_t* RawPad) {
  
  if(RawPad==NULL)  while(1) {};
 80056f0:	2800      	cmp	r0, #0
 80056f2:	d003      	beq.n	80056fc <IO_RawPadSetHigh+0xc>
  LL_GPIO_SetOutputPin(RawPad->pPort, RawPad->bfPin);
 80056f4:	6803      	ldr	r3, [r0, #0]
 80056f6:	8882      	ldrh	r2, [r0, #4]
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 80056f8:	619a      	str	r2, [r3, #24]
}
 80056fa:	4770      	bx	lr
  if(RawPad==NULL)  while(1) {};
 80056fc:	e7fe      	b.n	80056fc <IO_RawPadSetHigh+0xc>

080056fe <IO_RawPadSetLow>:

void IO_RawPadSetLow(RawPortPads_t* RawPad) {
  
  if(RawPad==NULL)  while(1) {};
 80056fe:	2800      	cmp	r0, #0
 8005700:	d003      	beq.n	800570a <IO_RawPadSetLow+0xc>
  LL_GPIO_ResetOutputPin(RawPad->pPort, RawPad->bfPin);
 8005702:	6803      	ldr	r3, [r0, #0]
 8005704:	8882      	ldrh	r2, [r0, #4]
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 8005706:	629a      	str	r2, [r3, #40]	; 0x28
}
 8005708:	4770      	bx	lr
  if(RawPad==NULL)  while(1) {};
 800570a:	e7fe      	b.n	800570a <IO_RawPadSetLow+0xc>

0800570c <IO_RawPadGet>:

uint32_t IO_RawPadGet(RawPortPads_t* RawPad) {
  
  if(RawPad==NULL)  while(1) {};
 800570c:	2800      	cmp	r0, #0
 800570e:	d007      	beq.n	8005720 <IO_RawPadGet+0x14>
  return LL_GPIO_IsInputPinSet(RawPad->pPort, RawPad->bfPin);
 8005710:	6803      	ldr	r3, [r0, #0]
 8005712:	8882      	ldrh	r2, [r0, #4]
  return ((READ_BIT(GPIOx->IDR, PinMask) == (PinMask)) ? 1UL : 0UL);
 8005714:	691b      	ldr	r3, [r3, #16]
 8005716:	4013      	ands	r3, r2
 8005718:	429a      	cmp	r2, r3
 800571a:	d002      	beq.n	8005722 <IO_RawPadGet+0x16>
 800571c:	2000      	movs	r0, #0
}
 800571e:	4770      	bx	lr
  if(RawPad==NULL)  while(1) {};
 8005720:	e7fe      	b.n	8005720 <IO_RawPadGet+0x14>
 8005722:	2001      	movs	r0, #1
 8005724:	e7fb      	b.n	800571e <IO_RawPadGet+0x12>
	...

08005728 <IO_EXTI_Config>:


// EXTI is independent of the IO configuration, 16 input lines of EXTI can come from IO Port/pin.
// for legacy purpose, we put here the function which added to IO_INIT() will have equivalent functionality to HAL_GPIO_Init()
int32_t IO_EXTI_Config( PadName_t PadName, EXTI_Config_t EXTI_Config) {
 8005728:	b5f0      	push	{r4, r5, r6, r7, lr}
 800572a:	46c6      	mov	lr, r8
 800572c:	b500      	push	{lr}

  uint8_t gpio_index = PadName>>4;
 800572e:	1102      	asrs	r2, r0, #4
 8005730:	b2d2      	uxtb	r2, r2
  // first is it a valid gpio?
  if(gpio_index>=countof(IO_GPIOx))
 8005732:	2a05      	cmp	r2, #5
 8005734:	d84c      	bhi.n	80057d0 <IO_EXTI_Config+0xa8>
    return -1;
  
  uint8_t pad_position = PadName & 0x000F;
 8005736:	230f      	movs	r3, #15
 8005738:	4018      	ands	r0, r3
  uint32_t pin_mask = 1<<pad_position;  
 800573a:	3b0e      	subs	r3, #14
 800573c:	4083      	lsls	r3, r0
  if((pGPIO_PadValidMask[gpio_index] & pin_mask)==0)
 800573e:	0054      	lsls	r4, r2, #1
 8005740:	4d26      	ldr	r5, [pc, #152]	; (80057dc <IO_EXTI_Config+0xb4>)
 8005742:	5b64      	ldrh	r4, [r4, r5]
 8005744:	4223      	tst	r3, r4
 8005746:	d046      	beq.n	80057d6 <IO_EXTI_Config+0xae>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8005748:	f3ef 8c10 	mrs	ip, PRIMASK
//  GPIO_TypeDef *GPIOx = (GPIO_TypeDef*) IO_GPIOx[gpio_index];
  uint32_t primask  = __get_PRIMASK(); // save current interrupt context
  
  // EXTI_IO_MUX_SETUP
  volatile uint8_t* pu8 = (uint8_t *)&EXTI->EXTICR[0]; // we switch to byte so we have an array of 16 bytes for bit 0..15, simple with byte access!
  pu8[pad_position] = port_offset; // no need to mask interrupt as it's a byte write, no read modify write here
 800574c:	4c24      	ldr	r4, [pc, #144]	; (80057e0 <IO_EXTI_Config+0xb8>)
 800574e:	46a0      	mov	r8, r4
 8005750:	4440      	add	r0, r8
 8005752:	7002      	strb	r2, [r0, #0]
//  EXTI->EXTICR[position >> 2U] = tmp;

  /* Clear EXTI line configuration */
  uint32_t tmp, bfmask, bfval; // for debug watch purpose
  
  bfmask = ~pin_mask;
 8005754:	43db      	mvns	r3, r3
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8005756:	2001      	movs	r0, #1
 8005758:	f380 8810 	msr	PRIMASK, r0
  
  __set_PRIMASK(1);// atomic start
//+ here we clear all pending edge detection  
  EXTI->RTSR1 = bfmask;
 800575c:	4a21      	ldr	r2, [pc, #132]	; (80057e4 <IO_EXTI_Config+0xbc>)
 800575e:	6013      	str	r3, [r2, #0]
  EXTI->FTSR1 = bfmask;
 8005760:	6053      	str	r3, [r2, #4]
 8005762:	f38c 8810 	msr	PRIMASK, ip
 8005766:	f38c 8810 	msr	PRIMASK, ip
  __set_PRIMASK(primask);// atomic end
  // leave here interrupt opportunity to minimize jitter...
  
  __set_PRIMASK(primask);// atomic start
  
  bfval = (EXTI_Config.Trigger & EXTI_CHANNEL_TRIGGER_INTERRUPT) ? 1 : 0;
 800576a:	070c      	lsls	r4, r1, #28
 800576c:	0fa7      	lsrs	r7, r4, #30
 800576e:	2601      	movs	r6, #1
 8005770:	4037      	ands	r7, r6
 8005772:	f380 8810 	msr	PRIMASK, r0
  __set_PRIMASK(1);// atomic start
  tmp = EXTI->IMR1;
 8005776:	2580      	movs	r5, #128	; 0x80
 8005778:	46a8      	mov	r8, r5
 800577a:	5955      	ldr	r5, [r2, r5]
  tmp = (tmp & bfmask) | bfval;
 800577c:	401d      	ands	r5, r3
 800577e:	433d      	orrs	r5, r7
  EXTI->IMR1 = tmp;
 8005780:	4647      	mov	r7, r8
 8005782:	51d5      	str	r5, [r2, r7]
 8005784:	f38c 8810 	msr	PRIMASK, ip
//  tmp &= ~pin_mask;
//  if (EXTI_Config.Trigger & EXTI_CHANNEL_TRIGGER_INTERRUPT)
//    tmp |= pin_mask;
//  EXTI->IMR1 = tmp;
  
  bfval = (EXTI_Config.Trigger & EXTI_CHANNEL_TRIGGER_EVENT) ? 1 : 0;
 8005788:	0fe4      	lsrs	r4, r4, #31
 800578a:	4004      	ands	r4, r0
 800578c:	f380 8810 	msr	PRIMASK, r0
  __set_PRIMASK(1);// atomic start
  tmp = EXTI->EMR1;
 8005790:	3704      	adds	r7, #4
 8005792:	59d5      	ldr	r5, [r2, r7]
  tmp = (tmp & bfmask) | bfval;
 8005794:	401d      	ands	r5, r3
 8005796:	432c      	orrs	r4, r5
  EXTI->EMR1 = tmp;
 8005798:	51d4      	str	r4, [r2, r7]
 800579a:	f38c 8810 	msr	PRIMASK, ip
//    tmp |= pin_mask;
//  EXTI->EMR1 = tmp;

  /* Clear Rising Falling edge configuration */
  
  bfval = (EXTI_Config.Edge & EXTI_RISING_EDGE) ? 1 : 0;
 800579e:	0789      	lsls	r1, r1, #30
 80057a0:	0f8c      	lsrs	r4, r1, #30
 80057a2:	4026      	ands	r6, r4
 80057a4:	f380 8810 	msr	PRIMASK, r0
  __set_PRIMASK(1);// atomic start
  tmp = EXTI->RTSR1;
 80057a8:	6814      	ldr	r4, [r2, #0]
  tmp = (tmp & bfmask) | bfval;
 80057aa:	401c      	ands	r4, r3
 80057ac:	4334      	orrs	r4, r6
  EXTI->RTSR1 = tmp;
 80057ae:	6014      	str	r4, [r2, #0]
 80057b0:	f38c 8810 	msr	PRIMASK, ip
//  tmp &= ~pin_mask;
//  if (EXTI_Config.Edge & EXTI_RISING_EDGE)
//    tmp |= pin_mask;
//  EXTI->RTSR1 = tmp;

  bfval = (EXTI_Config.Edge & EXTI_FALLING_EDGE) ? 1 : 0;
 80057b4:	0fc9      	lsrs	r1, r1, #31
 80057b6:	4001      	ands	r1, r0
 80057b8:	f380 8810 	msr	PRIMASK, r0
  __set_PRIMASK(1);// atomic start
  tmp = EXTI->FTSR1;
 80057bc:	6850      	ldr	r0, [r2, #4]
  tmp = (tmp & bfmask) | bfval;
 80057be:	4003      	ands	r3, r0
 80057c0:	4319      	orrs	r1, r3
  EXTI->FTSR1 = tmp;
 80057c2:	6051      	str	r1, [r2, #4]
 80057c4:	f38c 8810 	msr	PRIMASK, ip
//  tmp &= ~pin_mask;
//  if (EXTI_Config.Edge & EXTI_FALLING_EDGE)
//    tmp |= pin_mask;
//  EXTI->FTSR1 = tmp;

  return 0;
 80057c8:	2000      	movs	r0, #0
}
 80057ca:	bc80      	pop	{r7}
 80057cc:	46b8      	mov	r8, r7
 80057ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
    return -1;
 80057d0:	2001      	movs	r0, #1
 80057d2:	4240      	negs	r0, r0
 80057d4:	e7f9      	b.n	80057ca <IO_EXTI_Config+0xa2>
    return -1;
 80057d6:	2001      	movs	r0, #1
 80057d8:	4240      	negs	r0, r0
 80057da:	e7f6      	b.n	80057ca <IO_EXTI_Config+0xa2>
 80057dc:	0800711c 	.word	0x0800711c
 80057e0:	40021860 	.word	0x40021860
 80057e4:	40021800 	.word	0x40021800

080057e8 <__libc_init_array>:
 80057e8:	b570      	push	{r4, r5, r6, lr}
 80057ea:	2600      	movs	r6, #0
 80057ec:	4d0c      	ldr	r5, [pc, #48]	; (8005820 <__libc_init_array+0x38>)
 80057ee:	4c0d      	ldr	r4, [pc, #52]	; (8005824 <__libc_init_array+0x3c>)
 80057f0:	1b64      	subs	r4, r4, r5
 80057f2:	10a4      	asrs	r4, r4, #2
 80057f4:	42a6      	cmp	r6, r4
 80057f6:	d109      	bne.n	800580c <__libc_init_array+0x24>
 80057f8:	2600      	movs	r6, #0
 80057fa:	f000 f821 	bl	8005840 <_init>
 80057fe:	4d0a      	ldr	r5, [pc, #40]	; (8005828 <__libc_init_array+0x40>)
 8005800:	4c0a      	ldr	r4, [pc, #40]	; (800582c <__libc_init_array+0x44>)
 8005802:	1b64      	subs	r4, r4, r5
 8005804:	10a4      	asrs	r4, r4, #2
 8005806:	42a6      	cmp	r6, r4
 8005808:	d105      	bne.n	8005816 <__libc_init_array+0x2e>
 800580a:	bd70      	pop	{r4, r5, r6, pc}
 800580c:	00b3      	lsls	r3, r6, #2
 800580e:	58eb      	ldr	r3, [r5, r3]
 8005810:	4798      	blx	r3
 8005812:	3601      	adds	r6, #1
 8005814:	e7ee      	b.n	80057f4 <__libc_init_array+0xc>
 8005816:	00b3      	lsls	r3, r6, #2
 8005818:	58eb      	ldr	r3, [r5, r3]
 800581a:	4798      	blx	r3
 800581c:	3601      	adds	r6, #1
 800581e:	e7f2      	b.n	8005806 <__libc_init_array+0x1e>
 8005820:	08007128 	.word	0x08007128
 8005824:	08007128 	.word	0x08007128
 8005828:	08007128 	.word	0x08007128
 800582c:	0800712c 	.word	0x0800712c

08005830 <memset>:
 8005830:	0003      	movs	r3, r0
 8005832:	1882      	adds	r2, r0, r2
 8005834:	4293      	cmp	r3, r2
 8005836:	d100      	bne.n	800583a <memset+0xa>
 8005838:	4770      	bx	lr
 800583a:	7019      	strb	r1, [r3, #0]
 800583c:	3301      	adds	r3, #1
 800583e:	e7f9      	b.n	8005834 <memset+0x4>

08005840 <_init>:
 8005840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005842:	46c0      	nop			; (mov r8, r8)
 8005844:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005846:	bc08      	pop	{r3}
 8005848:	469e      	mov	lr, r3
 800584a:	4770      	bx	lr

0800584c <_fini>:
 800584c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800584e:	46c0      	nop			; (mov r8, r8)
 8005850:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8005852:	bc08      	pop	{r3}
 8005854:	469e      	mov	lr, r3
 8005856:	4770      	bx	lr
